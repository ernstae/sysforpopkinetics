<html>
<head>
<title>
SPK Compiler
</title>
</head>
<body>
<center><h1>
SPK Compiler
</h1></center>
<p>
SPK Compiler translates <a href="SpkML.html">SpkML</a> documents to C++
source code files.  The overall picture of package structure is demonstrated
in the diagram below:
</p>
<pre>
         +--------------------+
         |  class SpkMLToCpp  |
         +--------------------+-------------------------------+
         | void translate()                                   |
         | const vector&gt;string&lt; getFilenameList() const |
         +----------------------------------------------------+
            |
            | USES
            |
           \|/
         +--------------------------------+
         | abstract class ClientTransltor |
         +--------------------------------+---------------------------+
         | virtual void translate()                                   |
         | virtual const vector&gt;string&lt; getFilenameList() const |
         | ...                                                        |
         +------------------------------------------------------------+
                    /|\
                   /-+-\
                     |
                     | DERIVE
                     |
         +---------------------+
         | class xxxTranslator |
         +---------------------+---------------------------+
         | void translate()                                |
         | const vector&gt;string&lt; getFilenames() const |
         | ...                                             |
         +-------------------------------------------------+
           |
           | USES
          \|/
          yyparse() and yylex() (implemented specific to the client)

</pre>
A driver creats an SpkMLToCpp object and the object, in turn, plugs in a
client specific (which is determined from the contents of the input XML document)
ClientTranslator object.  SpkMLToCpp::translate() and SpkMLToCpp::getFilenameList()
<i>use</i> ClientTranslator::translate() and ClientTranslate::getFilenameList(), 
respectively.  Note that, it is "use" not "inherit".

<p>
The SpkML document is first converted to a DOM parse tree within SpkMLToCpp object.
The object determines the MDA client (ex. NONMEM, MatLab, SAAM-II...) from which
the document is originated.  Depending on the client, the compiler switches
the behavior accordingly.  For NONMEM, for example, the compiler
determines whether the end-user has requested to use one of the predefined (canned)
models or not and plug-in appropriate components.
</p>
<p>
For all clients, however, there is at least one common kind of elements that appears in
the SpkML document.  That is, sets of algebraic expressions.  One of the sets
may constitute partially or fully the definition of a model (either statistical or
physiological).  These expressions are handled by client-specific Expression Translators.
The Expression Translator looks up a symbol table for variable names that appear on the left/right hand side of expressions and checkes their 
consistency in usage.
</p>
The end product of SpkML-to-C++ translation is a list of the paths to C++ source
code files that have been generated, togther define a <a href="#driver">driver</a>,
the parts or the entire body of an instance of SpkModel and
the <a href="#inddata">IndData</a> class.  Whether it is a part or the entire body of
an instance of SpkModel depends on the type of MDA client.  For the MDA for 
NONMEM users, for example, only a part of canned models (ex. ADVAN1, ADVAN2...)
are dynamically defined.  These parts are defined as functions which are in turn 
called/used by one of SpkModel sub-classes found in the NONMEM <a href="#model_lib">Model Library</a>.
The <a href="#exp_lib">expression lookup table</a> maintains 
pre-determined mappings between client-expression elements 
and C++/Spk elements.  
</p>

<h3>Related Documents: </h3>
<ul>
<li><a href="SpkMLSpec.txt">SpkInML for Unknown Users</a></li>
<li><a href="SpkML_nonmem.txt">SpkInML for NONMEM Users</a></li>
<li><a href="symbolTable.html">Symbol Table Specification</a></li>
<li><a href="html/index.html">API Documentations</a></li>
</ul>
<hr>

<a name="model_lib">
<h2>
C++/Spk Model Library
</h2>
</a>
<p>
A model in a Model Library can be in any form (i.e. abstract, template, concrete).  The decision as to
which form a model shall take is best left for meeting the specific needs imposed by the type of MDA client.
</p>
<p>
For instance, for SAAM-II, it <i>may</i> make most sense to provide abstract classes shown in the diagram below:
</p>

<pre>
  +------------------------ SAAM-II Model Library -----------------------+
  |                                                                      |
  |                           +---------------+                          |
  |                           |   SpkModel    |                          |
  |                           |               |                          |
  |                           |  (abstract)   |                          |
  |                           +---------------+                          |
  |                             /|\       /|\                            |
  |                              |         |                             |
  |                              |         |                             |
  |     +---------------------------+   +--------------------------+     |
  |     |   Differential equation   |   |     Non-differential     |     |
  |     | based Physiological Model |   |   equation based model   |     |
  |     |         (abstract)        |   |        (abstract)        |     |
  |     +---------------------------+   +--------------------------+     |
  |            /|\        /|\                 /|\        /|\             |
  |             |          |                   |          |              |
  |             |          |                   |          |              |
  |     +---------------+  |            +---------------+ |              |
  |     | Compartmental |  |            | Compartmental | |              |
  |     |  (abstract)   |-------+       |  (abstract)   |-------+        |
  |     +---+-----------+       |       +---+-----------+       |        |
  |         | non-Compartmental |           | non-Compartmental |        |
  |         |    (abstract)     |           |    (abstract)     |        |
  |         +-------------------+ ...       +-------------------+ ...    |
  |                                                                      |
  +----------------------------------------------------------------------+
</pre>

<p>
Whereas, for NONMEM, its library <i>may</i> consists of concrete subclasses of SpkModel which requires/uses
certain functions that have to be dynamically generated/defined by SPK Compiler:
</p>
<pre>
                 +-------  NONMEM Model Libarary --------+
                 |                                       |
                 |            +--------------+           |
                 |            |   SpkModel   |           |
                 |            |              |           |
                 |            |  (abstract)  |           |
                 |            +--------------+           |
                 |              /|\      /|\             |
                 |               |        |              |  (these ones are dynamically defined)
                 |               |        |              |
                 |    +-------------+  +------------+    |     +- - - - - -+
                 |    |   One Comp. |  |  One Comp. | =====&lt | Predict y |
                 |    |  Non Linear |  |   Linear   |  (uses)  +- - - - - -+ - - +
                 |    |  (concrete) |  | (concrete) |    |        | Compute error |
                 |    +-------------+  +------------+    |        +- - - - - - - -+
                 |                                       |
                 +---------------------------------------+
</pre>

<a name="exp_lib">
<h2>
C++/Spk Expression Compiler(s)
</h2>
</a>
<p>
One (or more) parser is required per MDA client for SPK Compiler 
to translate algebraic expressions embedded in SpkML documents.
The expression parser shall be provided as a function named <pre>int yyparse()</pre>
which can be generated by a <a href="http://dinosaur.compilertools.net/yacc/index.html">
YACC</a> definition file.  The features an expression
parser shall be able to handle are listed in <a href="SpkExpLanguage.html">
Spk Expression Language Specification</a>.
</p>

<h2>
Generated C++ Code
</h2>
<a name="inddata">
<h3>
IndData Class
</h3>
</a>
<p>
The data set associated with an individual is organized and expressed as an object.  
Its class shall be dynamically generated by SPK Compiler and be named, IndData.
This class provides a mechanism for the caller to access a value by multiple names
if the end-user has given it more than one names (aliases).
</p>
<p>
The below demonstrates the idea (and an example) 
of dynamically generated IndData class definition, 
from a data set containing the sampling points "t", the measurements at these sampling points "dv",
the doses at various time points "dose", and the weight of the sample compartment "wt".
"dv" data has a synonym (alias), which is "y".
</p>
<code><pre>
class IndData
{
public:
   const string ID;
   const double *wt;
   const double *t;
   const double *dv;
   const double *y;
   const double *dose;

   IndData( const string & idIn, 
            const double * wtIn, 
            const double * tIn, 
            const double * dvIn, 
            const double * doseIn )
   : ID(idIn), wt(wtIn), t(tIn), dv(dvIn), y(dvIn), dose(doseIn)
   {}
}
</pre></code>

An IndData object has to be created and initialized per individual.  The process has to be
done somewhere before it is used during the evaluation of models.

<a name="driver">
<h3>
A Driver
</h3>
</a>
<p>
It is the driver that prepares the parameters needed to call
<code>fitPopulation()</code> or <code>fitIndividual</code>.
Such parameters include the intial estimates for the population parameter 
vector and individual paramters vector, 
a vector composed of all individuals' time-dependent
measurements against which the estimated values are compared, and values
that control optimizer's behavior.  One way to provide such a driver is
to have a pre-defined generic driver that takes these parameters as 
command line arguments.  The problem of this approach is
that the number of arguments changes from a problem to another and
could be very, very large (hundreds).  Thus, it has to be genrated
dynamically.
</p>

<a name="model">
<h3>
Partial/Entire Definition of SpkModel Sub-Class
</h3>
</a>
<p>
Depending on the type of MDA client, either only a part or the entire
body of an SpkModel sub-class will be generated (see <a href="#model_lib">
Model Library</a>).
</p>

<hr>
<a href="mailto:honda99@u.washington.edu">Sachiko</a>
</body>
</html>
