<html>
<head>
<title>Spk Compiler Symbol Tables</title>
</head>
<body>
<h1>Spk Compiler Symbol Tables</h1>
<p>
A symbol table is a data structure maintained by compiler
that records various symbols defined and used in a program
and used to resolve cross referencings.
</p>
<p>
Each version of Spk compiler (ex. a compiler for Fortran->C++, a compilar for 
Matlab->C++, etc.) will have more than one symbol table.  For a source language
that distinguishes locals and non-locals, it may make sense to have
a table for keeping track of <a href="#required">Spk-required</a> locals/non-locals as to
whether they have been provided or not, another table to maintain 
<a href="#global">user-defined non-locals</a>, 
and another for <a href="#local">user-defined locals</a>.  In other situations,
the tables for locals and non-locals may be combined to one.

</p>
<!------------------------------------------------------------------------------------------

   Table Entries

-------------------------------------------------------------------------------------------->
<a name="global">
<h2>User-defined Non-Locals</h2>
</a>
<p>
This table is used to record the identifiers of user-defined non-local variables and functions
which can be referenced anywhere in the target C++ code.

The actual implementation of the table will be a linked list and
each record will be indexed by its key reflecting the symbol being
stored.  Since the expected grown size of the table is small, probably only to hold
a dozen or so, the keys will are simply, most likely, the symbols themselves, instead
of hash codes.
</p>

<pre>
          +------+
          | var1 |
          |      |
          +------+    +------+    +------+
          | fn1  |    | arg1 |    | arg2 |
          |      |--->|      |--->|      |
          +------+    +------+    +------+
          | var2 |
          |      |
             .
             .
             .
          | var8 |
          |      |
          +------+    +------+    +------+    +------+
          | fn5  |    | arg1 |    | arg2 |    | arg3 |
          |      |--->|      |--->|      |--->|      |
          +------+    +------+    +------+    +------+
          | var9 |    
          |      |
          +------+

</pre>

<table border=1>
<thead>
<tr>
<th rowspan=4>Identifier</th><th colspan=7>Object Type</th>
</tr>
<tr>
<th colspan=3>Variable</th><th colspan=4>Function</th>
</tr>
<tr>
<th rowspan=2>Structure</th><th rowspan=2>Data Type</th><th rowspan=2>Pointer to Elements List</th>
<th colspan=3>Return Value</th><th rowspan=2>Arguments</th>
</tr>
<tr>
<th>Structure</th><th>Data Type</th><th>Pointer to Elements List</th>
</tr>
</thead>
<tbody>
<tr>
<td>unknown</td><td>scalar</td><td>integer</td><td>null</td>
                <td>scalar</td><td>integer</td><td>null</td><td>null</td>
</tr>
<tr>
<td>unknown</td><td>scalar</td><td>double</td><td>null</td>
                <td>scalar</td><td>double</td><td>null</td><td>null</td>
</tr>
<tr>
<td>unknown</td><td>scalar</td><td>boolean</td><td>null</td>
                <td>scalar</td><td>boolean</td><td>null</td><td>null</td>
</tr>
<tr>
<td>unknown</td><td>scalar</td><td>enumulator</td><td>null</td>
                <td>scalar</td><td>enumulator</td><td>null</td><td>null</td>
</tr>
<tr>
<td>unknown</td><td>class</td><td>unknown</td><td>null</td>
                <td>class</td><td>unknown</td><td>null</td><td>null</td>
</tr>
<tr>
<td>unknown</td><td>struct</td><td>unknown</td><td>null</td>
                <td>struct</td><td>unknown</td><td>null</td><td>null</td>
</tr>
<tr>
<td>unknown</td><td>scalar</td><td>integer</td><td>null</td>
                <td>scalar</td><td>integer</td><td>null</td>
                <td>pointer to the head of arguments list</td>
</tr>
<tr>
<td>unknown</td><td>scalar</td><td>double</td><td>null</td>
                <td>scalar</td><td>double</td><td>null</td>
                <td>pointer to the head of arguments list</td>
</tr>
<tr>
<td>unknown</td><td>scalar</td><td>boolean</td><td>null</td>
                <td>scalar</td><td>boolean</td><td>null</td>
                <td>pointer to the head of arguments list</td>
</tr>
<tr>
<td>unknown</td><td>scalar</td><td>enumulator</td><td>null</td>
                <td>scalar</td><td>enumulator</td><td>null</td>
                <td>pointer to the head of arguments list</td>
</tr>
<tr>
<td>unknown</td><td>class</td><td>unknown</td><td>null</td>
                <td>class</td><td>unknown</td><td>null</td>
                <td>pointer to the head of arguments list</td>
</tr>
<tr>
<td>unknown</td><td>struct</td><td>unknown</td><td>null</td>
                <td>struct</td><td>unknown</td><td>null</td>
                <td>pointer to the head of arguments list</td>
</tr>
<tr>
<td>unknown</td><td>array</td><td>integer</td><td>pointer to the head of element list</td>
                <td>array</td><td>integer</td><td>pointer to the head of element list</td>
                <td>null</td>
</tr>
<tr>
<td>unknown</td><td>array</td><td>double</td><td>pointer to the head of element list</td>
                <td>array</td><td>double</td><td>pointer to the head of element list</td>
                <td>null</td>
</tr>
<tr>
<td>unknown</td><td>array</td><td>boolean</td><td>pointer to the head of element list</td>
                <td>array</td><td>boolean</td><td>pointer to the head of element list</td>
                <td>null</td>
</tr>
<tr>
<td>unknown</td><td>array</td><td>a named class</td><td>pointer to the head of element list</td>
                <td>array</td><td>a named class</td><td>pointer to the head of element list</td>
                <td>null</td>
</tr>
<tr>
<td>unknown</td><td>array</td><td>a named struct</td><td>pointer to the head of element list</td>
                <td>array</td><td>a named struct</td><td>pointer to the head of element list</td>
                <td>null</td>
</tr><tr>
<td>unknown</td><td>array</td><td>integer</td><td>pointer to the head of element list</td>
                <td>array</td><td>integer</td><td>pointer to the head of element list</td>
                <td>pointer to the head of arguments list</td>
</tr>
<tr>
<td>unknown</td><td>array</td><td>double</td><td>pointer to the head of element list</td>
                <td>array</td><td>double</td><td>pointer to the head of element list</td>
                <td>pointer to the head of arguments list</td>
</tr>
<tr>
<td>unknown</td><td>array</td><td>boolean</td><td>pointer to the head of element list</td>
                <td>array</td><td>boolean</td><td>pointer to the head of element list</td>
                <td>pointer to the head of arguments list</td>
</tr>
<tr>
<td>unknown</td><td>array</td><td>a named class</td><td>pointer to the head of element list</td>
                <td>array</td><td>a named class</td><td>pointer to the head of element list</td>
                <td>pointer to the head of arguments list</td>
</tr>
<tr>
<td>unknown</td><td>array</td><td>a named struct</td><td>pointer to the head of element list</td>
                <td>array</td><td>a named struct</td><td>pointer to the head of element list</td>
                <td>pointer to the head of arguments list</td>
</tr>
</tbody>
</table>

<a name="local">
<h2>User-defined Locals</h2>
</a>
<p>
This table is used to record user-defined local variables and functions.  
The table will be likely implemented as a stack so that the records associated
with local entities are removed as they go out of scope.  Other than that,
the table looks like exactly the same as the one for non-locals.
</p>


<a name="required">
<h2>Spk-Required Locals and Non-Locals</h2>
</a>
This table is used to ensure that those information which are required by Spk are
provided by the user.  Thus, the table has a fixed number of records.  Each record
has an identifier field that is initialied to a fixed value and empty fields to be
filled as compilation process proceeds.

<h3>
Individual Analysis
</h3>
<table border=1>
<thead>
<tr>
<th colspan=2>C++ Entity</th>
<th rowspan=2>Corresponding Identifier in Client Space</th>
<th rowspan=2>Value</th>
<th rowspan=2 colspan=3>Description</th>
</tr>
<tr>
<th>Identifier</td><th>Object Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>nIndPar</td>
<td>int</td>
<td></td>
<td></td>
<td colspan=3>the length of individual parameter vector</td>
</tr>
<tr>
<td>indParIn</td>
<td>valarray&lt;double&gt;(nIndPar)</td>
<td></td>
<td></td>
<td colspan=3>initial estimates for the individual parameter</td>
</tr>
<tr>
<td>indParStep</td>
<td>valarray&lt;double&gt;(nIndPar)</td>
<td></td>
<td></td>
<td colspan=3>step size used during differentiation</td>
</tr>
<tr>
<td>indParLow</td>
<td>valarray&lt;double&gt;(nIndPar)</td>
<td></td>
<td></td>
<td colspan=3>lower boundary value used during optimization</td>
</tr>
<tr>
<td>indParUp</td>
<td>valarray&lt;double&gt;(nIndPar)</td>
<td></td>
<td></td>
<td colspan=3>upper boundary value used during optimization</td>
</tr>
<tr>
<td>indEpsilon</td>
<td>double</td>
<td></td>
<td></td>
<td colspan=3>convergence criteria for individual level optimization</td>
</tr>
<tr>
<td>indTrace</td>
<td>int</td>
<td></td>
<td></td>
<td colspan=3>trace level during individual level optimization</td>
</tr>
<tr>
<td>indMitr</td>
<td>int</td>
<td></td>
<td></td>
<td colspan=3>maximum iterations attempted before giving up convergence at individual level opt.</td>
</tr>
<tr>
<td>indRestart</td>
<td>bool</td>
<td></td>
<td></td>
<td colspan=3>flag indicating as to whether warm-start individual level opt.</td>
</tr>
<tr>
<td>isIndParStdError</td>
<td>bool</td>
<td></td>
<td></td>
<td colspan=3>flag indicating as to whether the standard error of final estimate of individual parameter to be computed</td>
</tr>
<tr>
<td>isIndParCorrelation</td>
<td>bool</td>
<td></td>
<td></td>
<td colspan=3>flag indicating as to whether the correlation of final estimate of individual parameter to be computed</td>
</tr>
<tr>
<td>isIndParCov</td>
<td>bool</td>
<td></td>
<td></td>
<td colspan=3>flag indicating as to whether the covariance of final estimate of individual parameter to be computed</td>
</tr>
<tr>
<td>isIndParCoefficient</td>
<td>bool</td>
<td></td>
<td></td>
<td colspan=3>flag indicating as to whether the coefficient of error of final estimate of individual parameter to be computed</td>
</tr>
<tr>
<td>isIndParConfidence</td>
<td>bool</td>
<td></td>
<td></td>
<td colspan=3>flag indicating as to whether the confidence interval of final estimate of individual parameter to be computed</td>
</tr>
<tr>
<td>nMeasurements</td>
<td>int</td>
<td></td>
<td></td>
<td colspan=3>the number of measurements for the individual</td>
</tr>
<tr>
<td>measurements</td>
<td>valarray&lt;double&gt;(nMeasurements)</td>
<td></td>
<td></td>
<td colspan=3>a vector containing the measurements for the individual</td>
</tr>
</tbody>
<thead>
<tr>
<th colspan=2>C++ Entity</th>
<th rowspan=2>Corresponding Identifier in Client Space</th>
<th rowspan=2>Defined?</th>
<th colspan=3>Description</th>
</tr>
<tr>
<th>Identifier</td>
<th>Object Type</th>
<th>Individual Analysis</th>
<th>Individual Analysis with Prior</th>
<th>Population Analysis</th>
</tr>
</thead>
<tbody>
<tr>
<td>doDataMean</td>
<td>function</td>
<td></td>
<td></td>
<td>f(b)</td>
<td>f(alp,b)</td>
<td>fi(alp,b)</td>
</tr>
<tr>
<td>doDataMean_indPar</td>
<td>function</td>
<td></td>
<td></td>
<td>f_b(b)</td>
<td>f_b(alp,b)</td>
<td>fi_b(alp,b)</td>
</tr>
<td>doDataVariance</td>
<td>function</td>
<td></td>
<td></td>
<td>R(b)</td>
<td>R(alp,b)</td>
<td>Ri(alp,b)</td>
</tr>
<tr>
<td>doDataVariance_indPar</td>
<td>function</td>
<td></td>
<td></td>
<td>R_b(b)</td>
<td>R_b(alp,b)</td>
<td>Ri_b(alp,b)</td>
</tr>
<tr>
<td>doDataVarianceInv</td>
<td>function</td>
<td></td>
<td><i>optional</i></td>
<td>RInv(b)</td>
<td>RInv(alp,b)</td>
<td>RiInv(alp,b)</td>
</tr>
<tr>
<td>doDataVarianceInv_indPar</td>
<td>function</td>
<td></td>
<td><i>optional</i></td>
<td>RInv_b(b)</td>
<td>RInv_b(alp,b)</td>
<td>RiInv_b(alp,b)</td>
</tr>
</tbody>
</table>

<!------------------------------------------------------------------------------------------
   Required for Individual Analysis with D(alp)
-------------------------------------------------------------------------------------------->
<h3>Individual Analysis with Prior Distribution Matrix</h3>
<p>
The following entities must be provided by the user in addition to the requirements
in preceding analysis.
</p>

<table border=1>
<thead>
<tr>
<th colspan=2>C++ Entity</th>
<th rowspan=2>Corresponding Identifier in Client Space</th>
<th rowspan=2>Value</th>
<th rowspan=2 colspan=3>Description</th>
</tr>
<tr>
<th>Identifier</td><th>Object Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>nPopPar</td>
<td>int</td>
<td></td>
<td></td>
<td colspan=3>the length of population parameter vector</td>
</tr>
<tr>
<td>popParIn</td>
<td>valarray&lt;double&gt;(nPopPar)</td>
<td></td>
<td></td>
<td colspan=3>initial estimates for the population parameter</td>
</tr>
</tbody>
<thead>
<tr>
<th colspan=2>C++ Entity</th>
<th rowspan=2>Corresponding Identifier in Client Space</th>
<th rowspan=2>Defined?</th>
<th colspan=3>Description</th>
</tr>
<tr>
<th>Identifier</td>
<th>Object Type</th>
<th>Individual Analysis</th>
<th>Individual Analysis with Prior</th>
<th>Population Analysis</th>
</tr>
</thead>
<tbody>
<tr>
<td>doIndParVariance</td>
<td>function</td>
<td></td>
<td></td>
<td><i>N/A</i></td>
<td>D(alp)</td>
<td>D(alp)</td>
</tr>
<tr>
<td>doIndParVariance_popPar</td>
<td>function</td>
<td></td>
<td></td>
<td><i>N/A</i></td>
<td>D_alp(alp)</td>
<td>D_alp(alp)</td>
</tr>
<tr>
<td>doIndParVarianceInv</td>
<td>function</td>
<td></td>
<td><i>optional</i></td>
<td><i>N/A</i></td>
<td>DInv(alp)</td>
<td>DInv(alp)</td>
</tr>
<tr>
<td>doIndParVarianceInv_popPar</td>
<td>function</td>
<td></td>
<td><i>optional</i></td>
<td><i>N/A</i></td>
<td>DInv_alp(alp)</td>
<td>DInv_alp(alp)</td>
</tr>
</tbody>
</table>

<!------------------------------------------------------------------------------------------
   Required for Population Analysis
-------------------------------------------------------------------------------------------->
<h3>Population Analysis</h3>
<p>
The following entities must be provided by the user in addition to the requirements
in preceding analysis.
</p>
<table border=1>
<thead>
<tr>
<th colspan=2>C++ Entity</th>
<th rowspan=2>Corresponding Identifier in Client Space</th>
<th rowspan=2>Value</th>
<th rowspan=2 colspan=3>Description</th>
</tr>
<tr>
<th>Identifier</td><th>Object Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>popParStep</td>
<td>valarray&lt;double&gt;(nPopPar)</td>
<td></td>
<td></td>
<td colspan=3>step size used during differentiation</td>
</tr>
<tr>
<td>popParLow</td>
<td>valarray&lt;double&gt;(nPopPar)</td>
<td></td>
<td></td>
<td colspan=3>lower boundary value used during optimization</td>
</tr>
<tr>
<td>popParUp</td>
<td>valarray&lt;double&gt;(nPopPar)</td>
<td></td>
<td></td>
<td colspan=3>upper boundary value used during optimization</td>
</tr>
<tr>
<td>approximation</td>
<td>enum Objective</td>
<td></td>
<td></td>
<td colspan=3>objective approximation method</td>
</tr>
<tr>
<td>popEpsilon</td>
<td>double</td>
<td></td>
<td></td>
<td colspan=3>convergence criteria for population level optimization</td>
</tr>
<tr>
<td>popTrace</td>
<td>int</td>
<td></td>
<td></td>
<td colspan=3>trace level during population level optimization</td>
</tr>
<tr>
<td>popMitr</td>
<td>int</td>
<td></td>
<td></td>
<td colspan=3>maximum iterations attempted before giving up convergence at population level opt.</td>
</tr>
<tr>
<td>popRestart</td>
<td>bool</td>
<td></td>
<td></td>
<td colspan=3>flag indicating as to whether warm-start population level opt.</td>
</tr>
<tr>
<td>isPopObjOut</td>
<td>bool</td>
<td></td>
<td></td>
<td colspan=3>flag indicating as to whether the final objective value to be returned</td>
</tr>
<tr>
<td>isPopObj_popParOut</td>
<td>bool</td>
<td></td>
<td></td>
<td colspan=3>flag indicating as to whether the derivative of final objective value to be returned</td>
</tr>
<tr>
<td>isPopObj_popPar_popParOut</td>
<td>bool</td>
<td></td>
<td></td>
<td colspan=3>flag indicating as to whether the 2nd derivative of final objective value to be returned</td>
</tr>
<tr>
<td>isPopParStdError</td>
<td>bool</td>
<td></td>
<td></td>
<td colspan=3>flag indicating as to whether the standard error of final estimate of population parameter to be computed</td>
</tr>
<tr>
<td>isPopParCorrelation</td>
<td>bool</td>
<td></td>
<td></td>
<td colspan=3>flag indicating as to whether the correlation of final estimate of population parameter to be computed</td>
</tr>
<tr>
<td>isPopParCov</td>
<td>bool</td>
<td></td>
<td></td>
<td colspan=3>flag indicating as to whether the covariance of final estimate of population parameter to be computed</td>
</tr>
<tr>
<td>isPopParCoefficient</td>
<td>bool</td>
<td></td>
<td></td>
<td colspan=3>flag indicating as to whether the coefficient of error of final estimate of population parameter to be computed</td>
</tr>
<tr>
<td>isPopParConfidence</td>
<td>bool</td>
<td></td>
<td></td>
<td colspan=3>flag indicating as to whether the confidence interval of final estimate of population parameter to be computed</td>
</tr>
<tr>
<td>nIndividuals</td>
<td>int</td>
<td></td>
<td></td>
<td colspan=3>the number of individuals in the population</td>
</tr>
<tr>
<td>nMeasurementsForAll</td>
<td>valarray&lt;int&gt;(nIndividuals)</td>
<td></td>
<td></td>
<td colspan=3>vector containing the number of measurements for each individual</td>
</tr>
<tr>
<td>measurementsForAll</td>
<td>valarray&lt;double&gt;(<i>the total number of measurements in the whole population</i>)</td>
<td></td>
<td></td>
<td colspan=3>vector containing all measurements in the whole population</td>
</tr>
</tbody>

<thead>
<tr>
<th colspan=2>C++ Entity</th>
<th rowspan=2>Corresponding Identifier in Client Space</th>
<th rowspan=2>Defined?</th>
<th colspan=3>Description</th>
</tr>
<tr>
<th>Identifier</td>
<th>Object Type</th>
<th>Individual Analysis</th>
<th>Individual Analysis with Prior</th>
<th>Population Analysis</th>
</tr>
</thead>
<tbody>
<tr>
<td>doDataMean</td>
<td>function</td>
<td></td>
<td></td>
<td>f(b)</td>
<td>f(alp,b)</td>
<td>fi(alp,b)</td>
</tr>
<tr>
<td>doDataMean_indPar</td>
<td>function</td>
<td></td>
<td></td>
<td>f_b(b)</td>
<td>f_b(alp,b)</td>
<td>fi_b(alp,b)</td>
</tr>
<tr>
<td>doDataMean_popPar</td>
<td>function</td>
<td></td>
<td></td>
<td><i>N/A</i></td>
<td>f_alp(alp,b)</td>
<td>fi_alp(alp,b)</td>
</tr>
<tr>
<td>doDataVariance</td>
<td>function</td>
<td></td>
<td></td>
<td>R(b)</td>
<td>R(alp,b)</td>
<td>Ri(alp,b)</td>
</tr>
<tr>
<td>doDataVariance_indPar</td>
<td>function</td>
<td></td>
<td></td>
<td>R_b(b)</td>
<td>R_b(alp,b)</td>
<td>Ri_b(alp,b)</td>
</tr>
<tr>
<td>doDataVariance_popPar</td>
<td>function</td>
<td></td>
<td></td>
<td><i>N/A</i></td>
<td>R_alp(alp,b)</td>
<td>Ri_alp(alp,b)</td>
</tr>
<tr>
<td>doDataVarianceInv</td>
<td>function</td>
<td></td>
<td><i>optional</i></td>
<td>RInv(b)</td>
<td>RInv(alp,b)</td>
<td>RiInv(alp,b)</td>
</tr>
<tr>
<td>doDataVarianceInv_indPar</td>
<td>function</td>
<td></td>
<td><i>optional</i></td>
<td>RInv_b(b)</td>
<td>RInv_b(alp,b)</td>
<td>RiInv_b(alp,b)</td>
</tr>
<tr>
<td>doDataVarianceInv_popPar</td>
<td>function</td>
<td></td>
<td><i>optional</i></td>
<td><i>N/A</i></td>
<td>RInv_alp(alp,b)</td>
<td>RiInv_alp(alp,b)</td>
</tr>
<tr>
<td>doIndParVariance</td>
<td>function</td>
<td></td>
<td></td>
<td><i>N/A</i></td>
<td>D(alp)</td>
<td>D(alp)</td>
</tr>
<tr>
<td>doIndParVariance_popPar</td>
<td>function</td>
<td></td>
<td></td>
<td><i>N/A</i></td>
<td>D_alp(alp)</td>
<td>D_alp(alp)</td>
</tr>
<tr>
<td>doIndParVarianceInv</td>
<td>function</td>
<td></td>
<td><i>optional</i></td>
<td><i>N/A</i></td>
<td>DInv(alp)</td>
<td>DInv(alp)</td>
</tr>
<tr>
<td>doIndParVarianceInv_popPar</td>
<td>function</td>
<td></td>
<td><i>optional</i></td>
<td><i>N/A</i></td>
<td>DInv_alp(alp)</td>
<td>DInv_alp(alp)</td>
</tr>
</tbody>
</table>




</body>
</html>