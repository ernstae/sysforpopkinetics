#include <fstream>

#include "NonmemTranslator.h"
#include "explang.h"
#include "../lower.h"

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOM.hpp>
#include <xercesc/util/XMLString.hpp>

using namespace std;
using namespace xercesc;

//========================================
// Local namespace
//----------------------------------------
namespace{

  // n!
  unsigned int factorial( unsigned int n )
  {
    if( n == 0 )
      return 0;
    else
      return n + factorial( n-1 );
  }
};
//========================================

//========================================
// The global variables used by
// yyparse() and yylex() (or equivalent).
//----------------------------------------
extern int gSpkExpErrors;
extern int gSpkExpLines;
extern SymbolTable * gSpkExpSymbolTable;
extern FILE * gSpkExpOutput;
extern FILE * nm_in;
extern int NM_ACCEPT;
extern int NM_ABORT;

extern "C"{
     int nm_parse(void);
};
//========================================

NonmemTranslator::NonmemTranslator( DOMDocument* sourceIn, DOMDocument* dataIn )
  : ClientTranslator ( sourceIn, dataIn ),
    fIndData_h  ( "IndData.h" ),
    fIndData_cpp( "IndData.cpp" ),
    fDataSet_h  ( "DataSet.h" ),
    fDataSet_cpp( "DataSet.cpp" ),
    fPredEqn_fortran( "predEqn.fortran" ),
    fPredEqn_cpp( "predEqn.cpp" ),
    fPred_h     ( "Pred.h" ),
    fPred_cpp   ( "Pred.cpp" ),
    fOmega_h    ( "Omega.h" ),
    fOmega_cpp  ( "Omega.cpp" ),
    BURNER( "// THIS FILE IS GENERATED BY THE ASPK COMPILER" ),
    X_YES            ( XMLString::transcode("yes") ),
    X_NO             ( XMLString::transcode("no") ),
    X_FIXED          ( XMLString::transcode("fixed") ),
    X_IN             ( XMLString::transcode("in") ),
    X_LOW            ( XMLString::transcode("low") ),
    X_UP             ( XMLString::transcode("up") ),
    X_DIAGONAL       ( XMLString::transcode("diagonal") ),
    X_BLOCK          ( XMLString::transcode("block") ),
    X_VALUE          ( XMLString::transcode("value") ),
    X_STRUCT         ( XMLString::transcode("struct") ),
    X_DIMENSION      ( XMLString::transcode("dimension") ),
    X_LABEL          ( XMLString::transcode("label") ),
    X_IS_ERR_OUT     ( XMLString::transcode("is_stderr_out") ),
    X_IS_CORR_OUT    ( XMLString::transcode("is_correlation_out") ),
    X_IS_COV_OUT     ( XMLString::transcode("is_covariance_out") ),
    X_IS_INV_COV_OUT ( XMLString::transcode("is_inverse_covariance_out") ),
    X_IS_COEF_OUT    ( XMLString::transcode("is_coefficent_out") ),
    X_IS_CONF_OUT    ( XMLString::transcode("is_confidence_out") ),
    X_NONMEM         ( XMLString::transcode("nonmem") ),
    X_POP_ANALYSIS   ( XMLString::transcode("pop_analysis") ),
    X_IND_ANALYSIS   ( XMLString::transcode("ind_analysis") ),
    X_CONSTRAINT     ( XMLString::transcode("constraint") ),
    X_MODEL          ( XMLString::transcode("model") ),
    X_PRED           ( XMLString::transcode("pred") ),
    X_PRESENTATION   ( XMLString::transcode("presentation") ),
    X_TABLE          ( XMLString::transcode("table") ),
    X_SCATTERPLOT    ( XMLString::transcode("scatterplot") ),
    X_COLUMN         ( XMLString::transcode("column") ),
    X_X              ( XMLString::transcode("x") ),
    X_Y              ( XMLString::transcode("y") ),
    X_BY             ( XMLString::transcode("by") ),
    X_APPROXIMATION  ( XMLString::transcode("approximation") ),
    X_FO             ( XMLString::transcode("fo") ),
    X_FOCE           ( XMLString::transcode("foce") ),
    X_LAPLACE        ( XMLString::transcode("laplace") ),
    X_POP_SIZE       ( XMLString::transcode("pop_size" ) ),
    X_IS_ESTIMATION  ( XMLString::transcode("is_estimation") ),
    X_IS_ETA_OUT     ( XMLString::transcode("is_eta_out") ),
    X_IS_RESTART     ( XMLString::transcode("is_restart") ),
    X_DATA_LABELS    ( XMLString::transcode("data_labels") ),
    X_FILENAME       ( XMLString::transcode("filename") ),
    X_NAME           ( XMLString::transcode("name") ),
    X_SYNONYM        ( XMLString::transcode("synonym") ),
    X_THETA          ( XMLString::transcode("theta") ),
    X_LENGTH         ( XMLString::transcode("length") ),
    X_OMEGA          ( XMLString::transcode("omega") ),
    X_SIGMA          ( XMLString::transcode("sigma") ),
    X_SIMULATION     ( XMLString::transcode("simulation") ),
    X_SEED           ( XMLString::transcode("seed") ),
    X_POP_STAT       ( XMLString::transcode("pop_stat") ),
    X_COVARIANCE_FORM( XMLString::transcode("covariance_form") ),
    X_MITR           ( XMLString::transcode("mitr") ),
    X_IND_STAT       ( XMLString::transcode("ind_stat") )
{
}
NonmemTranslator::NonmemTranslator()
{
}
NonmemTranslator::~NonmemTranslator()
{
  XMLString::release( &X_YES );
  XMLString::release( &X_NO );
  XMLString::release( &X_FIXED );
  XMLString::release( &X_IN );
  XMLString::release( &X_LOW );
  XMLString::release( &X_UP );
  XMLString::release( &X_DIAGONAL );
  XMLString::release( &X_BLOCK );
  XMLString::release( &X_VALUE );
  XMLString::release( &X_STRUCT );
  XMLString::release( &X_DIMENSION );
  XMLString::release( &X_LABEL );
  XMLString::release( &X_IS_ERR_OUT );
  XMLString::release( &X_IS_CORR_OUT );
  XMLString::release( &X_IS_COV_OUT );
  XMLString::release( &X_IS_INV_COV_OUT );
  XMLString::release( &X_IS_COEF_OUT );
  XMLString::release( &X_IS_CONF_OUT );
  
  XMLString::release( &X_NONMEM );
  XMLString::release( &X_POP_ANALYSIS );
  XMLString::release( &X_IND_ANALYSIS );
  XMLString::release( &X_CONSTRAINT );
  XMLString::release( &X_MODEL );
  XMLString::release( &X_PRED );
  XMLString::release( &X_PRESENTATION );
  XMLString::release( &X_TABLE );
  XMLString::release( &X_SCATTERPLOT );
  XMLString::release( &X_COLUMN );
  XMLString::release( &X_X );
  XMLString::release( &X_Y );
  XMLString::release( &X_BY );
  XMLString::release( &X_APPROXIMATION );
  XMLString::release( &X_FO );
  XMLString::release( &X_FOCE );
  XMLString::release( &X_LAPLACE );
  XMLString::release( &X_POP_SIZE );
  XMLString::release( &X_IS_ESTIMATION );
  XMLString::release( &X_IS_ETA_OUT );
  XMLString::release( &X_IS_RESTART );
  XMLString::release( &X_DATA_LABELS );
  XMLString::release( &X_FILENAME );
  XMLString::release( &X_NAME );
  XMLString::release( &X_SYNONYM );
  XMLString::release( &X_THETA );
  XMLString::release( &X_LENGTH );
  XMLString::release( &X_OMEGA );
  XMLString::release( &X_SIGMA );
  XMLString::release( &X_SIMULATION );
  XMLString::release( &X_SEED );
  XMLString::release( &X_POP_STAT );
  XMLString::release( &X_COVARIANCE_FORM );
  XMLString::release( &X_MITR );
  XMLString::release( &X_IND_STAT );
}
NonmemTranslator::NonmemTranslator( const NonmemTranslator& )
{
}
NonmemTranslator& NonmemTranslator::operator=( const NonmemTranslator& )
{
}
void NonmemTranslator::parseSource()
{
  assert( table.getLabels()->size() > 0 );

  enum TARGET {IND, POP};
  enum TARGET target;  
  enum MODEL_SPEC { PRED };

  int pop_size = 1;

  DOMElement * spksouce = source->getDocumentElement();
  DOMNodeList * nonmems = spksouce->getElementsByTagName( X_NONMEM );
  assert( nonmems->getLength() == 1 );
  DOMElement * nonmem = dynamic_cast<DOMElement*>( nonmems->item(0) );

  //------------------------------------------------------
  // <constraint>
  //------------------------------------------------------
  DOMNodeList * constraints = nonmem->getElementsByTagName( X_CONSTRAINT );
  assert( constraints->getLength() == 1 );
  DOMElement * constraint = dynamic_cast<DOMElement*>( constraints->item(0) );
  assert( constraint->hasChildNodes() );

  DOMNodeList * pop_analysises = constraint->getElementsByTagName( X_POP_ANALYSIS );
  DOMNodeList * ind_analysises = constraint->getElementsByTagName( X_IND_ANALYSIS );
  DOMElement * analysis;
  bool isAnalysisDone = false;
  if( pop_analysises->getLength() == 1 )
    {
      target = POP;
      analysis = dynamic_cast<DOMElement*>( pop_analysises->item(0) );
      pop_size = parsePopAnalysis( analysis );
      isAnalysisDone = true;
    }
  else if( ind_analysises->getLength() == 1 )
    {
      target = IND;
      analysis = dynamic_cast<DOMElement*>( ind_analysises->item(0) );
      parseIndAnalysis( analysis );
      isAnalysisDone = true;
      pop_size = 1;
    }
  else
    {
      // illegal
      assert( pop_analysises->getLength() == 1 || ind_analysises->getLength() == 1 );
    }
  //------------------------------------------------------
  // <model>
  // NOTE: only <pred> is allowed under <model> for v0.1.
  //------------------------------------------------------
  DOMNodeList * models = nonmem->getElementsByTagName( X_MODEL );
  assert( models->getLength() == 1 );
  DOMElement * model = dynamic_cast<DOMElement*>( models->item(0) );
  DOMNodeList * preds = model->getElementsByTagName( X_PRED );
  assert( preds->getLength() == 1 );
  DOMElement * pred = dynamic_cast<DOMElement*>( preds->item(0) );
  MODEL_SPEC model_spec = PRED;

  bool isPredDone = false;
  parsePred( pred, table);
  isPredDone = true;

  //------------------------------------------------------
  // <presentation>
  //------------------------------------------------------
  // PRED parsing and <xxx_analysis> parsing must have been completed so that the symbol table
  // contains entries for the user defined variables and THETA/OMEGA/SIGMA/ETA, respectively.
  assert( isPredDone );
  assert( isAnalysisDone );
  
  DOMNodeList * presentations = nonmem->getElementsByTagName( X_PRESENTATION );
  assert( presentations->getLength() == 1 );
  DOMElement * presentation = dynamic_cast<DOMElement*>( presentations->item(0) );

  vector<int> recordNums( pop_size );
  Symbol * id = table.findi( "ID" );
  assert( id != NULL || id != Symbol::empty() );
  for( int i=0; i<pop_size; i++ )
    {
      recordNums[i] = id->initial[i].size();
    }

  // For PRED, a label allowed in table/scatterplot specification is one of:
  // * THETA, OMEGA, (SIGMA), (ETA) --- <xxx_analysis> should have been done by now
  // * data labels  --- parseData() should have been done by now
  // * user defined variables in PRED definition --- PRED parsing should have been done by now
  // * PRED, RES, WRES
  if( table.findi( "PRED" ) == Symbol::empty() )
    table.insertUserVar( "PRED" );
  if( table.findi( "WRES" ) == Symbol::empty() )
    table.insertUserVar( "WRES" );
  if( table.findi( "RES" )  == Symbol::empty() )
    table.insertUserVar( "RES" );

  // <table> and <scatterplot> information are NOT needed by the compiler or SPK.
  /*
  DOMNodeList * display_tables = presentation->getElementsByTagName( X_TABLE );
  parseTables( display_tables, recordNums );

  DOMNodeList * display_plots  = presentation->getElementsByTagName( X_SCATTERPLOT );
  parseScatterplots( display_plots, recordNums );
  */

  //
  // Generate the headers and definition files for IndData class and
  // DataSet class.
  //
  // The symbol table (ie. the order of data labels in the list) must not change
  // in between the following two routines.
  //
  generateDataSet( pop_size, table );
  generateIndData( table );

  ifstream iPredEqn_cpp( fPredEqn_cpp );
  if( iPredEqn_cpp.good() )
    generatePred( table, iPredEqn_cpp );
  else
    assert( false );
}
/*
void NonmemTranslator::parseTables( DOMNodeList * display_tables, vector<int>& recordNums )
{
  const int nDisplayTables = display_tables->getLength();
  assert( nDisplayTables <= 10 );
  for( int i=0; i<nDisplayTables; i++ )
    {
      DOMElement* t = dynamic_cast<DOMElement*>( display_tables->item(i) );
      DOMNodeList * columns = t->getElementsByTagName( X_COLUMN );
      int nColumns = columns->getLength();
      assert( nColumns > 0 );
      for( int j=0; j<nColumns; j++ )
	{
	  DOMElement * column = dynamic_cast<DOMElement*>( columns->item(j) );
          assert( column->hasAttribute( X_LABEL ) );

	  const XMLCh* xml_label = column->getAttribute( X_LABEL );
	  char * str_label;
	  XMLCh * xml_sub = XMLString::replicate( xml_label );
	  int openParan = XMLString::indexOf( xml_label, '(' );
	  if( openParan > 0 )
	    {
	      XMLString::subString( xml_sub, xml_label, 0, openParan );
	      str_label = XMLString::transcode( xml_sub );
	    }
	  else
	    {
	      str_label = XMLString::transcode( xml_label );

	    }
	  if( table.findi(str_label) == Symbol::empty() )
	    cout << str_label << " was not found!" << endl;
	  assert( table.findi( str_label ) != Symbol::empty() );
	  delete str_label;
	}
    }
}
*/
/*
void NonmemTranslator::parseScatterplots( DOMNodeList* display_plots, vector<int>& recordNums )
{
  const int nDisplayPlots = display_plots->getLength();
  assert( nDisplayPlots <= 20 );
  for( int i=0; i<nDisplayPlots; i++ )
    {
      DOMElement* p = dynamic_cast<DOMElement*>( display_plots->item(i) );
      // x+
      DOMNodeList * x_list = p->getElementsByTagName( X_X );
      int nX = x_list->getLength();
      assert( nX > 0 );
      for( int j=0; j<nX; j++ )
	{
	  DOMElement * x = dynamic_cast<DOMElement*>( x_list->item(j) );
	  assert( x->hasAttribute( X_LABEL ) );

	  const XMLCh* xml_label = x->getAttribute( X_LABEL );
          char * str_label = XMLString::transcode( xml_label );
	  if( table.findi( str_label ) == Symbol::empty() )
	    table.insertLabel( str_label, "", recordNums );
	  delete str_label;
	}

      // y+
      DOMNodeList * y_list = p->getElementsByTagName( X_Y );
      int nY = y_list->getLength();
      assert( nY > 0 );
      for( int j=0; j<nY; j++ )
	{
	  DOMElement * y = dynamic_cast<DOMElement*>( y_list->item(j) );
	  assert( y->hasAttribute( X_LABEL ) );

	  const XMLCh* xml_label = y->getAttribute( X_LABEL );
          char * str_label = XMLString::transcode( xml_label );
	  if( table.findi( str_label ) == Symbol::empty() )
	    table.insertLabel( str_label, "", recordNums );
	  delete str_label;
	}

      // by*
      DOMNodeList * by_list = p->getElementsByTagName( X_BY );
      int nBy = by_list->getLength();
      for( int j=0; j<nBy; j++ )
	{
	  DOMElement * by = dynamic_cast<DOMElement*>( by_list->item(j) );
	  assert( by->hasAttribute( X_LABEL ) );

	  const XMLCh* xml_label = by->getAttribute( X_LABEL );
          char * str_label = XMLString::transcode( xml_label );
	  if( table.findi( str_label ) == Symbol::empty() )
	    table.insertLabel( str_label, "", recordNums );
	  delete str_label;
	}    
    }
}
*/
int NonmemTranslator::parsePopAnalysis( DOMElement* pop_analysis )
{
  enum APPROX {FO, FOCE, LAPLACE};
  
  //================================================================================
  // Required attributes
  //================================================================================
  // * approximation = {fo, foce, laplace}
  // * pop_size
  // * is_estimation = {yes, no}
  assert( pop_analysis->hasAttribute( X_APPROXIMATION ) );
  const XMLCh * xml_approx = pop_analysis->getAttribute( X_APPROXIMATION );

  APPROX approximation;
  if( XMLString::equals( xml_approx, X_FO ) )
    approximation = FO;
  else if( XMLString::equals( xml_approx, X_FOCE ) )
    approximation = FOCE;
  else if( XMLString::equals( xml_approx, X_LAPLACE ) )
    approximation = LAPLACE;
  else
    {
      assert( false );
    }

  assert( pop_analysis->hasAttribute( X_POP_SIZE ) );
  const XMLCh * xml_pop_size = pop_analysis->getAttribute( X_POP_SIZE );
  unsigned int pop_size = 0;
  if( !XMLString::textToBin( xml_pop_size, pop_size ) )
    {
      assert( false );
    }

  assert( pop_analysis->hasAttribute( X_IS_ESTIMATION ) );
  const XMLCh * xml_is_estimation = pop_analysis->getAttribute( X_IS_ESTIMATION );
  bool is_estimation = ( XMLString::equals( xml_is_estimation, X_YES )? true : false );

  //================================================================================
  // Optional attributes
  //================================================================================
  // * is_eta_out = {yes, "no"}
  // * is_restart = {"yes", no}
  bool is_eta_out = false;
  const XMLCh * xml_is_eta_out;
  if( pop_analysis->hasAttribute( X_IS_ETA_OUT ) )
    {
      xml_is_eta_out = pop_analysis->getAttribute( X_IS_ETA_OUT );
      is_eta_out = ( XMLString::equals( xml_is_eta_out, X_YES )? true : false );
    }

  bool is_restart = true;
  const XMLCh * xml_is_restart;
  if( pop_analysis->hasAttribute( X_IS_RESTART ) )
    {
      xml_is_restart = pop_analysis->getAttribute( X_IS_RESTART );
      is_restart = ( XMLString::equals( xml_is_restart, X_YES )? true : false );
    }
      
  //================================================================================
  // Required elements
  //================================================================================
  // <data_labels>
  // <theta>
  // <omega>+
  // <sigma>+
  DOMNodeList * data_labels_list = pop_analysis->getElementsByTagName( X_DATA_LABELS );
  assert( data_labels_list->getLength() == 1 );
  DOMElement * data_labels = dynamic_cast<DOMElement*>( data_labels_list->item(0) );
  {
     // Required <data_labels> attributes
     // * filename = CDATA
    assert( data_labels->hasAttribute( X_FILENAME ) );
     const XMLCh* xml_data_filename = data_labels->getAttribute( X_FILENAME );
     assert( XMLString::stringLen( xml_data_filename ) > 0 );

     DOMNodeList * labels = data_labels->getElementsByTagName( X_LABEL );
     int nLabels = labels->getLength();
     assert( nLabels > 0 );
     for( int i=0; i<nLabels; i++ )
       {
	 DOMElement * xml_label = dynamic_cast<DOMElement*>( labels->item(i) );
	 // <label> is an empty element

         // required attribute
	 // * name
	 assert( xml_label->hasAttribute( X_NAME ) );
	 const XMLCh* xml_name = xml_label->getAttribute( X_NAME );
	 assert( XMLString::stringLen( xml_name ) > 0 );
         char * c_name = XMLString::transcode( xml_name );
	 Symbol * name = table.findi( c_name );
	 assert( name != Symbol::empty() );
         delete c_name;

	 // optional attribute
	 // * synonym
         if( xml_label->hasAttribute( X_SYNONYM ) )
	   {
	     const XMLCh* xml_synonym = xml_label->getAttribute( X_SYNONYM );
	     char * c_synonym = XMLString::transcode( xml_synonym );
	     // register the synonym to the symbol table
	     name->synonym = string( c_synonym );
	     delete c_synonym;
	   }
       }
  }

  char valueDefault[] = "0.0";

  DOMNodeList * theta_list = pop_analysis->getElementsByTagName( X_THETA );
  assert( theta_list->getLength() == 1 );
  DOMElement * theta = dynamic_cast<DOMElement*>( theta_list->item(0) );
  assert( theta->hasAttribute( X_LENGTH ) );
  const XMLCh* xml_theta_len = theta->getAttribute( X_LENGTH );
  unsigned int theta_len = 0;
  if( !XMLString::textToBin( xml_theta_len, theta_len ) )
    {
      assert( theta_len > 0 );
    }
  Symbol * sym_theta = table.insertNMVector( "THETA", theta_len );
  {
    //<in>
    DOMNodeList * theta_in_list = theta->getElementsByTagName( X_IN );
    assert( theta_in_list->getLength() == 1 );
    DOMElement * theta_in = dynamic_cast<DOMElement*>( theta_in_list->item(0) );

    DOMNodeList * value_list = theta_in->getElementsByTagName( X_VALUE );
    assert( theta_len == value_list->getLength() );
    for( int i=0; i<theta_len; i++ )
      {
	char str_val[128];
        bool isFixed = false;
	DOMElement * value = dynamic_cast<DOMElement*>( value_list->item(i) );
	if( value->hasAttribute( X_FIXED ) )
	  {
	    const XMLCh* xml_fixed = value->getAttribute( X_FIXED );
	    isFixed = (XMLString::equals( xml_fixed, X_YES )? true : false );
	  }
	const XMLCh* xml_val = value->getFirstChild()->getNodeValue();
	if( XMLString::stringLen( xml_val ) == 0 )
	  strcpy( str_val, valueDefault );
	else
	  {
	    char * tmp_c_val = XMLString::transcode( xml_val );
	    strcpy( str_val, tmp_c_val );
	    delete tmp_c_val;
	  }
	sym_theta->initial[0][i] = str_val;
	sym_theta->fixed[0][i]   = isFixed;
      }
    //<low>
    DOMNodeList * theta_low_list = theta->getElementsByTagName( X_LOW );
    assert( theta_low_list->getLength() == 1 );
    DOMElement * theta_low = dynamic_cast<DOMElement*>( theta_low_list->item(0) );
    value_list = theta_low->getElementsByTagName( X_VALUE );
    assert( theta_len == value_list->getLength() );
    for( int i=0; i<theta_len; i++ )
      {
	char str_val[128];
	DOMElement * value = dynamic_cast<DOMElement*>( value_list->item(i) );
	const XMLCh* xml_val = value->getFirstChild()->getNodeValue();
	if( XMLString::stringLen( xml_val ) == 0 )
	  strcpy( str_val, valueDefault );
	else
	  {
	    char * tmp_c_val = XMLString::transcode( xml_val );
	    strcpy( str_val, tmp_c_val );
	    delete tmp_c_val;
	  }
	sym_theta->lower[0][i] = str_val;
      }

    //<up>
    DOMNodeList * theta_up_list = theta->getElementsByTagName( X_UP );
    assert( theta_up_list->getLength() == 1 );
    DOMElement * theta_up = dynamic_cast<DOMElement*>( theta_up_list->item(0) );
    value_list = theta_up->getElementsByTagName( X_VALUE );
    assert( theta_len == value_list->getLength() );
    for( int i=0; i<theta_len; i++ )
      {
	char str_val[128];
	const XMLCh* xml_val = value_list->item(i)->getFirstChild()->getNodeValue();
	if( XMLString::stringLen( xml_val ) == 0 )
	  strcpy( str_val, valueDefault );
	else
	  {
	    char * tmp_c_val = XMLString::transcode( xml_val );
	    strcpy( str_val, tmp_c_val );
	    delete tmp_c_val;
	  }
	sym_theta->upper[0][i] = str_val;
      }
  }

  DOMNodeList * omega_list = pop_analysis->getElementsByTagName( X_OMEGA );
  int nOmegaSpecs = omega_list->getLength();
  assert( nOmegaSpecs == 1 );// v0.1 supports only one (full) Omega specification
  DOMElement * omega = dynamic_cast<DOMElement*>( omega_list->item(0) );
  assert( omega->hasAttribute( X_DIMENSION ) );
  const XMLCh* xml_omega_dim = omega->getAttribute( X_DIMENSION );
  unsigned int omegaDim = 0;
  if( !XMLString::textToBin( xml_omega_dim, omegaDim ) )
    {
      assert( omegaDim > 0 );
    }

  assert( omega->hasAttribute( X_STRUCT ) );
  const XMLCh* xml_omega_struct = omega->getAttribute( X_STRUCT );
  enum Symbol::Structure omega_structure;
  int omegaElemNum = 0;
  if( XMLString::equals( xml_omega_struct, X_DIAGONAL ) )
    {
      omega_structure = Symbol::DIAGONAL;
      omegaElemNum = omegaDim;
    }
  else if( XMLString::equals( xml_omega_struct, X_BLOCK ) )
    {
      omega_structure = Symbol::TRIANGLE;
      omegaElemNum = factorial( omegaDim );
    }
  else
    assert( false );
  Symbol * sym_omega = table.insertNMMatrix( "OMEGA", omega_structure, omegaDim );
  {
    //<in>
    DOMNodeList * omega_in_list = omega->getElementsByTagName( X_IN );
    assert( omega_in_list->getLength() == 1 );
    DOMElement * omega_in = dynamic_cast<DOMElement*>( omega_in_list->item(0) );

    DOMNodeList * value_list = omega_in->getElementsByTagName( X_VALUE );
    assert( omegaElemNum == value_list->getLength() );
    for( int i=0; i<omegaElemNum; i++ )
      {
	char str_val[128];
        bool isFixed = false;
	DOMElement * value = dynamic_cast<DOMElement*>( value_list->item(i) );
	if( value->hasAttribute( X_FIXED ) )
	  {
	    const XMLCh* xml_fixed = value->getAttribute( X_FIXED );
	    isFixed = (XMLString::equals( xml_fixed, X_YES )? true : false );
	  }
	const XMLCh* xml_val = value->getFirstChild()->getNodeValue();

	if( XMLString::stringLen( xml_val ) == 0 )
	  strcpy( str_val, valueDefault );
	else
	  {
	    char * tmp_c_val = XMLString::transcode( xml_val );
	    strcpy( str_val, tmp_c_val );
	    delete tmp_c_val;
	  }
	sym_omega->initial[0][i] = str_val;
	sym_omega->fixed[0][i]   = isFixed;
      }
  }

  DOMNodeList * simga_list = pop_analysis->getElementsByTagName( X_SIGMA );
  int nSigmaSpecs = simga_list->getLength();
  assert( nSigmaSpecs == 1 );// v0.1 supports only one (full) Sigma specification
  DOMElement * sigma = dynamic_cast<DOMElement*>( simga_list->item(0) );
  assert( sigma->hasAttribute( X_DIMENSION ) );
  const XMLCh* xml_sigma_dim = sigma->getAttribute( X_DIMENSION );
  unsigned int sigmaDim = 0;
  if( !XMLString::textToBin( xml_sigma_dim, sigmaDim ) )
    {
      assert( sigmaDim > 0 );
    }

  assert( sigma->hasAttribute( X_STRUCT ) );
  const XMLCh* xml_sigma_struct = sigma->getAttribute( X_STRUCT );
  enum Symbol::Structure sigma_structure;
  int sigmaElemNum = 0;
  if( XMLString::equals( xml_sigma_struct, X_DIAGONAL ) )
    {
      sigma_structure = Symbol::DIAGONAL;
      sigmaElemNum = sigmaDim;
    }
  else if( XMLString::equals( xml_sigma_struct, X_BLOCK ) )
    {
      sigma_structure = Symbol::TRIANGLE;
      sigmaElemNum = factorial( sigmaDim );
    }
  else
    assert( false );
  Symbol * sym_sigma = table.insertNMMatrix( "SIGMA", sigma_structure, sigmaDim ); 
  {
    //<in>
    DOMNodeList * sigma_in_list = sigma->getElementsByTagName( X_IN );
    assert( sigma_in_list->getLength() == 1 );
    DOMElement * sigma_in = dynamic_cast<DOMElement*>( sigma_in_list->item(0) );

    DOMNodeList * value_list = sigma_in->getElementsByTagName( X_VALUE );
    assert( sigmaElemNum == value_list->getLength() );
    for( int i=0; i<sigmaElemNum; i++ )
      {
	char str_val[128];
        bool isFixed = false;
	DOMElement * value = dynamic_cast<DOMElement*>( value_list->item(i) );
	if( value->hasAttribute( X_FIXED ) )
	  {
	    const XMLCh* xml_fixed = value->getAttribute( X_FIXED );
	    isFixed = (XMLString::equals( xml_fixed, X_YES )? true : false );
	  }
	const XMLCh* xml_val = value->getFirstChild()->getNodeValue();

	if( XMLString::stringLen( xml_val ) == 0 )
	  strcpy( str_val, valueDefault );
	else
	  {
	    char * tmp_c_val = XMLString::transcode( xml_val );
	    strcpy( str_val, tmp_c_val );
	    delete tmp_c_val;
	  }
	sym_sigma->initial[0][i] = str_val;
	sym_sigma->fixed[0][i]   = isFixed;
      }
  }
  
  //----------------------------------------------------------
  // eta
  // NOTE: eta is not given by the user.  
  // eta's initial estimate is set to 0.0 automatically.
  //
  // REVISIT - Sachiko 01/22/04
  // The boundary values must be computed automatically too.
  //-----------------------------------------------------------
  const int eta_len = theta_len;
  char etaDefault[] = "0.0";
  Symbol * sym_eta = table.insertNMVector( "ETA", eta_len );
  sym_eta->initial[0] = etaDefault;
  sym_eta->fixed[0] = false;

  //================================================================================
  // Optional elements
  //================================================================================
  // <description>  --- ignore!
  // <simulation>
  // <pop_stat>
  bool isSimulate = false;
  unsigned int seed = 0;
  DOMNodeList * simulations = pop_analysis->getElementsByTagName( X_SIMULATION );
  if( simulations->getLength() > 0 )
    {
      assert( simulations->getLength() == 1 );
      isSimulate = true;
      DOMElement* simulation = dynamic_cast<DOMElement*>( simulations->item(0) );
      assert( simulation->hasAttribute( X_SEED ) );
      const XMLCh* xml_seed = simulation->getAttribute( X_SEED );
      if( !XMLString::textToBin( xml_seed, seed ) )
	{
	  assert( false );
	}
    }

  DOMNodeList * pop_stat_list = pop_analysis->getElementsByTagName( X_POP_STAT );
  if( pop_stat_list->getLength() > 0 )
    {
      assert( pop_stat_list->getLength() == 1 );
      DOMElement * pop_stat = dynamic_cast<DOMElement*>( pop_stat_list->item(0) );
      bool is_stderr_out             = false;//default
      bool is_correlation_out        = false;//default
      bool is_covariance_out         = false;//default
      bool is_inverse_covariance_out = false;//default
      bool is_confidence_out         = false;//default
      bool is_coefficient_out        = false;//default
      assert( pop_stat->hasAttribute( X_COVARIANCE_FORM ) );
      const XMLCh* cov_form = pop_stat->getAttribute( X_COVARIANCE_FORM ); // r, rsr, s

      if( pop_stat->hasAttribute( X_IS_ERR_OUT ) )
	{
	  const XMLCh* xml_stderr = pop_stat->getAttribute( X_IS_ERR_OUT );
	  is_stderr_out = (XMLString::equals( xml_stderr, X_YES )? true : false );
	}

      if( pop_stat->hasAttribute( X_IS_CORR_OUT ) )
	{
	  const XMLCh* xml_correlation = pop_stat->getAttribute( X_IS_CORR_OUT );
	  is_correlation_out = (XMLString::equals( xml_correlation, X_YES )? true : false );
	}

      if( pop_stat->hasAttribute( X_IS_COV_OUT ) )
	{
	  const XMLCh* xml_cov = pop_stat->getAttribute( X_IS_COV_OUT );
	  is_covariance_out = (XMLString::equals( xml_cov, X_YES )? true : false );
	}

      if( pop_stat->hasAttribute( X_IS_INV_COV_OUT ) )
	{
	  const XMLCh* xml_inv_cov = pop_stat->getAttribute( X_IS_INV_COV_OUT );
	  is_inverse_covariance_out = (XMLString::equals( xml_inv_cov, X_YES )? true : false );
	}

      if( pop_stat->hasAttribute( X_IS_CONF_OUT ) )
	{
	  const XMLCh* xml_conf = pop_stat->getAttribute( X_IS_CONF_OUT );
	  is_confidence_out = (XMLString::equals( xml_conf, X_YES )? true : false );
	}

      if( pop_stat->hasAttribute( X_IS_COEF_OUT ) )
	{
	  const XMLCh* xml_coef = pop_stat->getAttribute( X_IS_COEF_OUT );
	  is_coefficient_out = (XMLString::equals( xml_coef, X_YES )? true : false );
	}
    }
  return pop_size;
}
void NonmemTranslator::parseIndAnalysis( DOMElement* ind_analysis )
{
  //================================================================================
  // Required attributes
  //================================================================================
  // * is_estimation = {yes, no}
  const XMLCh * xml_is_estimation = ind_analysis->getAttribute( X_IS_ESTIMATION );
  assert( XMLString::stringLen( xml_is_estimation ) > 0 );
  bool is_estimation = ( XMLString::equals( xml_is_estimation, X_YES )? true : false );

  //================================================================================
  // Optional attributes
  //================================================================================
  // * mitr   --- required when is_estimation == "yes"
  // * is_restart = {"yes", no}
  bool is_restart = true;
  unsigned int mitr = 0;
  const XMLCh * xml_is_restart = ind_analysis->getAttribute( X_IS_RESTART );
  if( XMLString::stringLen( xml_is_restart ) )
      is_restart = ( XMLString::equals( xml_is_restart, X_YES )? true : false );
  if( is_estimation )
    {
      const XMLCh* xml_mitr = ind_analysis->getAttribute( X_MITR );
      assert( XMLString::stringLen( xml_mitr ) > 0 );
      if( !XMLString::textToBin( xml_mitr, mitr ) )
	assert( xml_mitr > 0 );
    }
  //================================================================================
  // Required elements
  //================================================================================
  // <data_labels>
  // <theta>
  // <omega>+
  DOMNodeList * data_labels_list = ind_analysis->getElementsByTagName( X_DATA_LABELS );
  assert( data_labels_list->getLength() == 1 );
  DOMElement * data_labels = dynamic_cast<DOMElement*>( data_labels_list->item(0) );
  {
     // Required <data_labels> attributes
     // * filename = CDATA
     const XMLCh* xml_data_filename = data_labels->getAttribute( X_FILENAME );
     assert( XMLString::stringLen( xml_data_filename ) > 0 );

     DOMNodeList * labels = data_labels->getElementsByTagName( X_LABEL );
     int nLabels = labels->getLength();
     assert( nLabels > 0 );
     for( int i=0; i<nLabels; i++ )
       {
	 DOMElement * xml_label = dynamic_cast<DOMElement*>( labels->item(i) );
	 // <label> is an empty element

         // required attribute
	 // * name
	 const XMLCh* xml_name = xml_label->getAttribute( X_NAME );
	 assert( XMLString::stringLen( xml_name ) > 0 );
	 char * c_name = XMLString::transcode( xml_name );
	 Symbol * name = table.findi( c_name );
	 assert( name != Symbol::empty() );
	 delete c_name;

	 // optional attribute
	 // * synonym
         const XMLCh* xml_synonym = xml_label->getAttribute( X_SYNONYM );
	 if( XMLString::stringLen( xml_synonym ) > 0 )
	   {
	     char * c_synonym = XMLString::transcode( xml_synonym );
	     // register the synonym to the symbol table
	     name->synonym = c_synonym;
	     delete c_synonym;
	   }
       }
  }

  DOMNodeList * theta_list = ind_analysis->getElementsByTagName( X_THETA );
  assert( theta_list->getLength() == 1 );
  DOMElement * theta = dynamic_cast<DOMElement*>( theta_list->item(0) );
  const XMLCh* xml_theta_len = theta->getAttribute( X_LENGTH );
  assert( XMLString::stringLen( xml_theta_len ) > 0 );
  unsigned int theta_len = 0;
  if( !XMLString::textToBin( xml_theta_len, theta_len ) )
    {
      assert( theta_len > 0 );
    }
  Symbol * sym_theta = table.insertNMVector( "THETA", theta_len );
  {
    //<in>
    DOMNodeList * theta_in_list = theta->getElementsByTagName( X_IN );
    assert( theta_in_list->getLength() == 1 );
    DOMElement * theta_in = dynamic_cast<DOMElement*>( theta_in_list->item(0) );

    DOMNodeList * value_list = theta_in->getElementsByTagName( X_VALUE );
    assert( theta_len == value_list->getLength() );
    for( int i=0; i<theta_len; i++ )
      {
	char str_val[128];
        bool isFixed = false;
	DOMElement * value = dynamic_cast<DOMElement*>( value_list->item(i) );
        const XMLCh* xml_fixed = value->getAttribute( X_FIXED );
	if( XMLString::stringLen( xml_fixed ) != 0 )
	  {
	    isFixed = (XMLString::equals( xml_fixed, X_YES )? true : false );
	  }
	const XMLCh* xml_val = value->getFirstChild()->getNodeValue();
	if( XMLString::stringLen( xml_val ) == 0 )
	  strcpy( str_val, "0.0" );
	else
	  {
	    char * tmp_c_val = XMLString::transcode( xml_val );
	    strcpy( str_val, tmp_c_val );
	    delete tmp_c_val;
	  }
	sym_theta->initial[0][i] = str_val;
	sym_theta->fixed[0][i]   = isFixed;
      }
    //<low>
    DOMNodeList * theta_low_list = theta->getElementsByTagName( X_LOW );
    assert( theta_low_list->getLength() == 1 );
    DOMElement * theta_low = dynamic_cast<DOMElement*>( theta_low_list->item(0) );
    value_list = theta_low->getElementsByTagName( X_VALUE );
    assert( theta_len == value_list->getLength() );
    for( int i=0; i<theta_len; i++ )
      {
	char str_val[128];
	DOMElement * value = dynamic_cast<DOMElement*>( value_list->item(i) );
	const XMLCh* xml_val = value->getFirstChild()->getNodeValue();
	if( XMLString::stringLen( xml_val ) == 0 )
	  strcpy( str_val, "0.0" );
	else
	  {
	    char * tmp_c_val = XMLString::transcode( xml_val );
	    strcpy( str_val, tmp_c_val );
	    delete tmp_c_val;
	  }
	sym_theta->lower[0][i] = str_val;
      }

    //<up>
    DOMNodeList * theta_up_list = theta->getElementsByTagName( X_UP );
    assert( theta_up_list->getLength() == 1 );
    DOMElement * theta_up = dynamic_cast<DOMElement*>( theta_up_list->item(0) );
    value_list = theta_up->getElementsByTagName( X_VALUE );
    assert( theta_len == value_list->getLength() );
    for( int i=0; i<theta_len; i++ )
      {
	char str_val[128];
	const XMLCh* xml_val = value_list->item(i)->getFirstChild()->getNodeValue();
	if( XMLString::stringLen( xml_val ) == 0 )
	  strcpy( str_val, "0.0" );
	else
	  {
	    char * tmp_c_val = XMLString::transcode( xml_val );
	    strcpy( str_val, tmp_c_val );
	    delete tmp_c_val;
	  }
	sym_theta->upper[0][i] = str_val;
      }
  }

  DOMNodeList * omega_list = ind_analysis->getElementsByTagName( X_OMEGA );
  int nOmegaSpecs = omega_list->getLength();
  assert( nOmegaSpecs == 1 );// v0.1 supports only one (full) Omega specification
  DOMElement * omega = dynamic_cast<DOMElement*>( omega_list->item(0) );
  const XMLCh* xml_omega_dim = omega->getAttribute( X_DIMENSION );
  assert( XMLString::stringLen( xml_omega_dim ) > 0 );
  unsigned int omegaDim = 0;
  if( !XMLString::textToBin( xml_omega_dim, omegaDim ) )
    {
      assert( omegaDim > 0 );
    }
  const XMLCh* xml_omega_struct = omega->getAttribute( X_STRUCT );
  assert( XMLString::stringLen( xml_omega_struct ) > 0 );
  enum Symbol::Structure omega_structure;
  int omegaElemNum = 0;
  if( XMLString::equals( xml_omega_struct, X_DIAGONAL ) )
    {
      omega_structure = Symbol::DIAGONAL;
      omegaElemNum = omegaDim;
    }
  else if( XMLString::equals( xml_omega_struct, X_BLOCK ) )
    {
      omega_structure = Symbol::TRIANGLE;
      omegaElemNum = factorial( omegaDim );
    }
  else
    assert( false );
  Symbol * sym_omega = table.insertNMMatrix( "OMEGA", omega_structure, omegaDim );
  {
    //<in>
    DOMNodeList * omega_in_list = omega->getElementsByTagName( X_IN );
    assert( omega_in_list->getLength() == 1 );
    DOMElement * omega_in = dynamic_cast<DOMElement*>( omega_in_list->item(0) );

    DOMNodeList * value_list = omega_in->getElementsByTagName( X_VALUE );
    assert( omegaElemNum == value_list->getLength() );
    for( int i=0; i<omegaElemNum; i++ )
      {
	char str_val[128];
        bool isFixed = false;
	DOMElement * value = dynamic_cast<DOMElement*>( value_list->item(i) );
        const XMLCh* xml_fixed = value->getAttribute( X_FIXED );
	if( XMLString::stringLen( xml_fixed ) != 0 )
	  {
	    isFixed = (XMLString::equals( xml_fixed, X_YES )? true : false );
	  }
	const XMLCh* xml_val = value->getFirstChild()->getNodeValue();

	if( XMLString::stringLen( xml_val ) == 0 )
	  strcpy( str_val, "0.0" );
	else
	  {
	    char * tmp_c_val = XMLString::transcode( xml_val );
	    strcpy( str_val, tmp_c_val );
	    delete tmp_c_val;
	  }
	sym_omega->initial[0][i] = str_val;
	sym_omega->fixed[0][i]   = isFixed;
      }
  }

  //================================================================================
  // Optional elements
  //================================================================================
  // <description>  --- ignore!
  // <simulation>
  // <ind_stat>
  bool isSimulate = false;
  unsigned int seed = 0;
  DOMNodeList * simulations = ind_analysis->getElementsByTagName( X_SIMULATION );
  if( simulations->getLength() > 0 )
    {
      assert( simulations->getLength() == 1 );
      isSimulate = true;
      DOMElement* simulation = dynamic_cast<DOMElement*>( simulations->item(0) );
      const XMLCh* xml_seed = simulation->getAttribute( X_SEED );
      assert( XMLString::stringLen( xml_seed ) > 0 );
      if( !XMLString::textToBin( xml_seed, seed ) )
	{
	  assert( false );
	}
    }

  DOMNodeList * ind_stat_list = ind_analysis->getElementsByTagName( X_IND_STAT );
  if( ind_stat_list->getLength() > 0 )
    {
      assert( ind_stat_list->getLength() == 1 );
      DOMElement * ind_stat = dynamic_cast<DOMElement*>( ind_stat_list->item(0) );
      bool is_stderr_out             = false;//default
      bool is_correlation_out        = false;//default
      bool is_covariance_out         = false;//default
      bool is_inverse_covariance_out = false;//default
      bool is_confidence_out         = false;//default
      bool is_coefficient_out        = false;//default

      const XMLCh* xml_stderr = ind_stat->getAttribute( X_IS_ERR_OUT );
      if( XMLString::stringLen( xml_stderr ) > 0 )
      {
	is_stderr_out = (XMLString::equals( xml_stderr, X_YES )? true : false );
      }
      const XMLCh* xml_correlation = ind_stat->getAttribute( X_IS_CORR_OUT );
      if( XMLString::stringLen( xml_correlation ) > 0 )
      {
	is_correlation_out = (XMLString::equals( xml_correlation, X_YES )? true : false );
      }
      const XMLCh* xml_cov = ind_stat->getAttribute( X_IS_COV_OUT );
      if( XMLString::stringLen( xml_cov ) > 0 )
      {
	is_covariance_out = (XMLString::equals( xml_cov, X_YES )? true : false );
      }
      const XMLCh* xml_inv_cov = ind_stat->getAttribute( X_IS_INV_COV_OUT );
      if( XMLString::stringLen( xml_inv_cov ) > 0 )
      {
	is_inverse_covariance_out = (XMLString::equals( xml_inv_cov, X_YES )? true : false );
      }
      const XMLCh* xml_conf = ind_stat->getAttribute( X_IS_CONF_OUT );
      if( XMLString::stringLen( xml_conf ) > 0 )
      {
	is_confidence_out = (XMLString::equals( xml_conf, X_YES )? true : false );
      }
      const XMLCh* xml_coef = ind_stat->getAttribute( X_IS_COEF_OUT );
      if( XMLString::stringLen( xml_coef ) > 0 )
      {
	is_coefficient_out = (XMLString::equals( xml_coef, X_YES )? true : false );
      }
    }
}
void NonmemTranslator::parsePred( DOMElement * pred, SymbolTable & table )
{
  char * c_equations = NULL;
  const XMLCh* xml_equations = pred->getFirstChild()->getNodeValue();
  int size = XMLString::stringLen( xml_equations );
  if( size > 0 )
    c_equations = XMLString::transcode( xml_equations );

  nm_in = fopen( fPredEqn_fortran, "w" );
  fprintf( nm_in, "%s", c_equations );
  fclose( nm_in );
  delete c_equations;

  nm_in = fopen( fPredEqn_fortran, "r" );
  gSpkExpOutput = fopen( fPredEqn_cpp, "w" );
  gSpkExpSymbolTable = &table;

  try{
    nm_parse();
  }
  catch( ... )
    {
      assert( false );
    }

  fclose( nm_in );
  fclose( gSpkExpOutput );
  remove( fPredEqn_fortran );
}
//=========================================================================================
// Generate the declaration and the definition files for each
// IndData class and IndDataSet class.
//=========================================================================================
void NonmemTranslator::generateIndData( const SymbolTable & final_symbol_table ) const
{
  // The constructor of IndData takes a data record as arguments.
  // The constructor initializer associates Label vs. Synonym.
  // The data items are all public.
  const Symbol * pID = final_symbol_table.findi( "id" );

  //
  // The order in which the label strings appear is crutial.
  // So, get a constant pointer to the list and the iterator
  // for throughout use.
  //
  const vector<string> * labels = final_symbol_table.getLabels();
  vector<string>::const_iterator pLabel;

  // 
  // rawTable points to the actual std::map object that
  // mapps the label strings and its associated data values.
  //
  const map<const string, Symbol> * const rawTable = final_symbol_table.getTable();
  map<const string, Symbol>::const_iterator pRawTable;

  //
  // Declare and define IndData template class.
  // For name binding reason, the declaration and the definition
  // are both stored in a single file: IndData.h
  //
  ofstream oIndData_h( fIndData_h );
  if( oIndData_h.good() )
    {
      oIndData_h << BURNER << " <" << __FILE__ << ">" << endl;

      oIndData_h << "#ifndef INDDATA_H" << endl;
      oIndData_h << "#define INDDATA_H" << endl;
      oIndData_h << "#include <valarray>" << endl;
      oIndData_h << endl;

      //-----------------------------------------------
      // Declaration
      //-----------------------------------------------
      oIndData_h << "template <class T>" << endl;
      oIndData_h << "class IndData{" << endl;

      //
      // Public member declaration
      //
      oIndData_h << "public:" << endl;

      //
      // The only legal constructor interface declaration.
      // The constructor takes a list of valarray objects as arguments.
      // The arguments are for the variables whose names
      // are defined as *the data labels* in the NONMEM term.
      //
      oIndData_h << "IndData( int nIn";
      pLabel = labels->begin();
      for( ; pLabel != labels->end(); pLabel++ )
	{
          bool isID = ( *pLabel == pID->name );
	  oIndData_h << "," << endl;
	  
	  //
	  // If the label is of "ID", then, the data type is char*.
	  // Otherwise, all others are double.
	  //
	  oIndData_h << '\t' << "const std::valarray<" << (isID? "char*":"T") << ">";
          oIndData_h << " & " << *pLabel << "In";
	}
      oIndData_h << ");" << endl;
      oIndData_h << endl;

      // 
      // Declare the valarray variables, both *the data labels* and *the synonyms*.
      //
      string synonym;
      pLabel = labels->begin();
      for( ; pLabel != labels->end(); pLabel++ )
	{
	  //
	  // If the label string is of "ID", then the data type is char*.
	  // Otherwise, double.
	  //
          bool isID = ( *pLabel == pID->name );
	  oIndData_h << "const std::valarray<" << (isID? "char*":"T") << ">";
          oIndData_h << " " << *pLabel << ";" << endl;
	  if( ( synonym = final_symbol_table.findi( *pLabel )->synonym ) != "" )
	  {
             oIndData_h << "const std::valarray<" << (isID? "char*":"T") << ">";
             oIndData_h << " " << synonym << ";" << endl;
          }
	}

      //
      // Declare the user defined variables that appear in the equations.
      // These are all double-precision floating point numbers.
      //
      pRawTable = rawTable->begin();
      for( ; pRawTable != rawTable->end(); pRawTable++ )
	{
	    if( find( labels->begin(), labels->end(), pRawTable->second.name ) == labels->end() )
	    {
	      oIndData_h << "std::valarray<T> " << pRawTable->second.name << ";" << endl;
	      oIndData_h << "std::valarray<T> " << pRawTable->second.name << "_tmp;" << endl;
	    }
	}

      oIndData_h << endl;
      oIndData_h << "~IndData();" << endl;

      // 
      // Protected member declarations.
      //
      oIndData_h << "protected:" << endl;
      oIndData_h << "IndData();" << endl;
      oIndData_h << "IndData( const IndData& );" << endl;
      oIndData_h << "IndData& operator=( const IndData& );" << endl;
      oIndData_h << endl;

      //
      // Private member declarations.
      //
      oIndData_h << "private:" << endl;
      oIndData_h << "const int n; // #of measurements." << endl;

      oIndData_h << "};" << endl;


      //-----------------------------------------------
      // Definition
      //-----------------------------------------------
      //
      // Definition of the constructor that takes a list of
      // valarray objects as arguments.
      // The order must be consistant with the declaration.
      //
      oIndData_h << "template <class T>" << endl;
      oIndData_h << "IndData<T>::IndData( int nIn";
      pLabel = labels->begin();
      for( ; pLabel != labels->end(); pLabel++ )
	{
          bool isID = ( *pLabel == pID->name );
	  oIndData_h << "," << endl;

	  //
	  // If the label string is of "ID", then the data type is char*.
	  // Othewise, double.
	  //
	  oIndData_h << "const std::valarray<" << (isID? "char*":"T") << "> ";
          oIndData_h << "& " << *pLabel << "In";
	}
      oIndData_h << ")" << endl;
      oIndData_h << ": n( nIn )";


      //
      // The constructor initialization.
      // Assign the argument values to the internal valarray variables.
      // Also assign the same values to equivalent (synonym) variables
      // if the variable has a synonym defined.
      //
      pLabel = labels->begin();
      for( ; pLabel != labels->end(); pLabel++ )
	{
	  oIndData_h << "," << endl;
	  oIndData_h << *pLabel << "( " << *pLabel << "In" << " )";

	  //
	  // If the label has a synonym, apply the same value to the synonym.
	  //
	  if( ( synonym = final_symbol_table.findi( *pLabel )->synonym ) != "" )
	    {
	      oIndData_h << "," << endl;
	      oIndData_h << synonym << "( " << *pLabel << "In" << " )";
	    }
	}

      //
      // The constructor body.
      // Initialize the sizes of the user defined variables that
      // appear in the model definition.
      // We don't know the values yet, so just assign the size,
      // which is the same as the number of data records for a subject.
      //
      // These arrays will be internally (ie. PRED routine) used to store 
      // intermediate values.  The intermediate values are
      // returned to the user for tabular display or plot display.
      // They need corresponding shadow placeholders so that
      // if an iteration fails, the system can return the previously
      // successfully computed values.
      //
      pRawTable = rawTable->begin();
      for( ; pRawTable != rawTable->end(); pRawTable++ )
	{
	    if( find( labels->begin(), labels->end(), pRawTable->second.name ) == labels->end() )
	    {
	      oIndData_h << "," << endl;

	      //
	      // The place holders for completely (throughout an iteration)
	      // computed values.
	      //
 	      oIndData_h << pRawTable->second.name << "( nIn )";
              oIndData_h << "," << endl;

	      //
	      // The place holders for currently (ie. in-process-iteration)
	      // computed values.
	      //
	      oIndData_h << pRawTable->second.name << "_tmp( nIn )";
	    }
	}

      oIndData_h << endl;
      oIndData_h << "{" << endl;
      oIndData_h << "}" << endl;

      oIndData_h << endl;
      oIndData_h << "template <class T>" << endl;
      oIndData_h << "IndData<T>::~IndData(){}" << endl;

      oIndData_h << "template <class T>" << endl;
      oIndData_h << "IndData<T>::IndData(){}" << endl;

      oIndData_h << "template <class T>" << endl;
      oIndData_h << "IndData<T>::IndData( const IndData<T>& ){}" << endl;

      oIndData_h << "template <class T>" << endl;
      oIndData_h << "IndData<T>& IndData<T>::operator=( const IndData<T>& ){}" << endl;

      oIndData_h << "#endif" << endl;
    }
    else
    {
      assert( false );
    }
  oIndData_h.close();
}
void NonmemTranslator::generateDataSet( int pop_size, const SymbolTable & final_symbol_table ) const
{
  const map<const string, Symbol> * t = final_symbol_table.getTable();
  const vector<string> *labels = final_symbol_table.getLabels();
  vector<string>::const_iterator pLabel;
  int nLabels = labels->size();
  const Symbol * pID = final_symbol_table.findi( "id" );

  //
  // Declare and define DataSet template class.
  // For name binding reason, the declaration and the definition
  // are both stored in a single file: DataSet.h
  // 
  // The only legal constructor is the default constructor.
  // The constructor initializes the array of IndData objects,
  // each contains the entire data set for a subject.
  //
  // The order in which the arguments to the IndData 
  // constructor appear is critical.  The order must
  // match with the IndData constructor's interface.
  // It relizes on the order of strings stored in the list 
  // returned by "SymbolTable::getLabels()".
  // Thus, in between the time when the DataSet constructor
  // is defined and the time when the IndData constructor
  // is declared/defined, the SymbolTable object
  // may NOT be modified.
  //  const Symbol* pID = final_symbol_table.findi("id");
  //
  ofstream oDataSet_h( fDataSet_h );
  if( oDataSet_h.good() )
    {
      oDataSet_h << BURNER << " <" << __FILE__ << ">" << endl;

      oDataSet_h << "#ifndef DATASET_H" << endl;
      oDataSet_h << "#define DATASET_H" << endl;

      oDataSet_h << "#include <vector>" << endl;
      oDataSet_h << "#include \"IndData.h\"" << endl;
      oDataSet_h << endl;

      //-----------------------------------------------
      // Declaration
      //-----------------------------------------------
      oDataSet_h << "template <class T>" << endl;
      oDataSet_h << "class DataSet" << endl;
      oDataSet_h << "{" << endl;
      

      oDataSet_h << "public:" << endl;
      oDataSet_h << "DataSet();" << endl;
      oDataSet_h << "~DataSet();" << endl;
      oDataSet_h << endl;

      oDataSet_h << "std::vector<IndData<T>*> data;" << endl;
      oDataSet_h << endl;

      oDataSet_h << "protected:" << endl;
      oDataSet_h << "DataSet( const DataSet& );" << endl;
      oDataSet_h << "DataSet& operator=( const DataSet& );" << endl;
      oDataSet_h << endl;

      oDataSet_h << "};" << endl;


      //-----------------------------------------------
      // Defintion
      //-----------------------------------------------
      oDataSet_h << "template <class T>" << endl;
      oDataSet_h << "DataSet<T>::DataSet()" << endl;
      oDataSet_h << ": data(" << pop_size << ")" << endl;
      oDataSet_h << "{" << endl;

      for( int who=0; who < pop_size; who++ )
	{
          char c_who[256];
          sprintf( c_who, "%d", who );
          int nRecords = pID->initial[who].size();
          const string id = pID->initial[who][0];

          //
          // The order in which the labels appear must be consistent
          // with the order in the constructor declaration.
          // By using the iterator in both places, here and up there,
          // they shall match.  However, this should be tested in
          // the corresponding unit tests.
          //
          oDataSet_h << "//------------------------------------" << endl;
          oDataSet_h << "// Subject <" << id << "> " << endl;
	  oDataSet_h << "// # of sampling points = " << nRecords << endl;
          oDataSet_h << "//------------------------------------" << endl;
	  
	  //
	  // Initialize C arrays with data values.
	  // The C arrays are passed to the valarray's constructor.
	  //
	  pLabel = labels->begin();
	  for( int i=0; pLabel != labels->end(), i<nLabels; i++, pLabel++ )
	    {
	      const Symbol * s = final_symbol_table.findi( *pLabel );
              bool isID = (*pLabel == pID->name);
              string carray_name   = s->name + "_" + c_who + "_c";
              string valarray_name = s->name + "_" + c_who;

              oDataSet_h << (isID? "char*":"T") << " " << carray_name << "[] = { ";
	      for( int j=0; j<nRecords; j++ )
		{
		  if( j > 0 )
		    oDataSet_h << ", ";
                  if( *pLabel == pID->name )
                     oDataSet_h << "\"" << s->initial[who][j] << "\"";
                  else
		     oDataSet_h << s->initial[who][j];
		}
	      oDataSet_h << " };" << endl;
	      oDataSet_h << "std::valarray<" << (isID? "char*":"T") << ">";
              oDataSet_h << valarray_name << "(" << carray_name << ", " << nRecords << ");" << endl;
	    }

	  //
	  // Create an IndData object.  The order in which the arguments
	  // are passed to the IndData constructor must be strictly
	  // compliant to the order in which the label strings are stored
	  // in the list returned by SymbolTable::getLabels().
	  //
	  oDataSet_h << "data[" << who << "] = new IndData<T>";
          oDataSet_h << "( " << nRecords << ", ";
	  pLabel = labels->begin();
	  for( int i=0; pLabel != labels->end(), i<nLabels; i++, pLabel++ )
	    {
	      if( i>0 )
		oDataSet_h << ", ";
	      const Symbol * s = final_symbol_table.findi( *pLabel );
              string valarray_name = s->name + "_" + c_who;
              oDataSet_h << valarray_name;
	    }
	  
	  oDataSet_h << " );" << endl;
          oDataSet_h << endl;
	}

      oDataSet_h << "}" << endl;

      oDataSet_h << "template <class T>" << endl;
      oDataSet_h << "DataSet<T>::~DataSet()" << endl;
      oDataSet_h << "{" << endl;
      oDataSet_h << "   const int n = data.size();" << endl;
      oDataSet_h << "   for( int i=0; i<n; i++ )" << endl;
      oDataSet_h << "   {" << endl;
      oDataSet_h << "      delete data[i];" << endl;
      oDataSet_h << "   }" << endl;
      oDataSet_h << "}" << endl;

      oDataSet_h << "template <class T>" << endl;
      oDataSet_h << "DataSet<T>::DataSet( const DataSet<T>& ){}" << endl;

      oDataSet_h << "template <class T>" << endl;
      oDataSet_h << "DataSet<T>& DataSet<T>::operator=( const DataSet<T>& ){}" << endl;

      oDataSet_h << "#endif" << endl;
    }
  else
    {
      assert( false );
    }
  oDataSet_h.close();
}
void NonmemTranslator::generatePred( const SymbolTable& final_symbol_table, ifstream& iPredEqn ) const
{
  //
  // iPredEqn is a (read-only) file handler to the file containing
  // the user defined model (ie. equations only).
  //
  assert( iPredEqn.good() );
  char ch;

  const vector<string> * labels = final_symbol_table.getLabels();
  const int nLabels = labels->size();
  vector<string>::const_iterator pLabel;

  const map<const string, Symbol> * rawTable = final_symbol_table.getTable();
  map<const string, Symbol>::const_iterator pRawTable;

  const string sTHETA = ( table.findi("theta")->name );
  const string sETA   = ( table.findi("eta")->name );
  const string sEPS   = ( table.findi("eps")->name );

  //
  // Declare and define Pred template class.
  // For name binding reason, the declaration and the definition
  // are both stored in a single file: Pred.h
  // 
  ofstream oPred_h( fPred_h );
  if( oPred_h.good() )
    {
      // headers
      oPred_h << BURNER << endl;
      oPred_h << "#ifndef PRED_H" << endl;
      oPred_h << "#define PRED_H" << endl;
      oPred_h << endl;

      oPred_h << "#include <string>" << endl;
 
      //----------------------------------------------
      // Declaration
      //----------------------------------------------
      oPred_h << "template <class T>" << endl;
      oPred_h << "class Pred" << endl;
      oPred_h << "{" << endl;
      
      oPred_h << "public:" << endl;
      oPred_h << "Pred( const DataSet<T>* dataIn );" << endl;
      oPred_h << "~Pred();" << endl;
      oPred_h << "bool eval( T theta[], " << endl;
      oPred_h << "           int nTheta, " << endl;
      oPred_h << "           T eta[], " << endl;
      oPred_h << "           int nEta, " << endl;
      oPred_h << "           T eps[], " << endl;
      oPred_h << "           int nEps," << endl;
      oPred_h << "           int spk_i, " << endl;
      oPred_h << "           int spk_j, " << endl;
      oPred_h << "           T & f, " << endl;
      oPred_h << "           T & y );" << endl;
      oPred_h << endl;

      oPred_h << "protected:" << endl;
      oPred_h << "Pred();" << endl;
      oPred_h << "Pred( const Pred& );" << endl;
      oPred_h << "Pred & operator=( const Pred& );" << endl;

      oPred_h << "private:" << endl;
      oPred_h << "const DataSet<T> *data;" << endl;
      oPred_h << "mutable int prev_i;" << endl;
      oPred_h << "mutable int prev_j;" << endl;

      // The data items
      const Symbol * pID = table.findi( "id" );
      pLabel = labels->begin();
      for( int i=0; i<nLabels, pLabel != labels->end(); i++, pLabel++ )
	{
          bool isID = (*pLabel == pID->name);

	  const Symbol* s = final_symbol_table.findi( *pLabel );
	  oPred_h << "mutable " << ( isID? "std::string" : "T" );
          oPred_h << " " << lower( s->name ) << ";" << endl;
          if( !s->synonym.empty() )
	    {
	      oPred_h << "mutable " << ( isID? "std::string" : "T" );
	      oPred_h << " " << lower( s->synonym ) << ";" << endl;
	    }
	}
      // The user defined scalar variables
      for( pRawTable = rawTable->begin(); pRawTable != rawTable->end(); pRawTable++ )
	{
	  if( pRawTable->second.name != sTHETA && pRawTable->second.name != sETA 
		  && pRawTable->second.name != sEPS )
	    {
	      if( find( labels->begin(), labels->end(), pRawTable->second.name ) == labels->end() )
		{
		  oPred_h << "mutable T " << lower( pRawTable->second.name ) << ";" << endl;
		}
	    }
	}

      // footer
      oPred_h << "};" << endl;

      //----------------------------------------------
      // Definition
      //----------------------------------------------
      oPred_h << "template <class T>" << endl;
      oPred_h << "Pred<T>::Pred( const DataSet<T>* dataIn )" << endl;
      oPred_h << ": data(dataIn)" << endl;
      oPred_h << "{" << endl;
      oPred_h << "}" << endl;

      oPred_h << "template <class T>" << endl;
      oPred_h << "Pred<T>::~Pred()" << endl;
      oPred_h << "{" << endl;
      oPred_h << "}" << endl;

      oPred_h << "template <class T>" << endl;
      oPred_h << "bool Pred<T>::eval( T theta[], " << endl;
      oPred_h << "           int nTheta, " << endl;
      oPred_h << "           T eta[], " << endl;
      oPred_h << "           int nEta, " << endl;
      oPred_h << "           T eps[], " << endl;
      oPred_h << "           int nEps," << endl;
      oPred_h << "           int spk_i, " << endl;
      oPred_h << "           int spk_j, " << endl;
      oPred_h << "           T & f, " << endl;
      oPred_h << "           T & y )" << endl;
      oPred_h << "{" << endl;

      // Assign the current values (i,j) of data to appropriate scalar variables
      for( pLabel = labels->begin(); pLabel != labels->end(); pLabel++ )
      {
         const Symbol *s = table.findi( *pLabel );
         // label
         oPred_h << lower( s->name ) << " = data->data[spk_i]->" << s->name << "[spk_j];" << endl;
         // synonym
         if( !s->synonym.empty() )
         {
            oPred_h << lower( s->synonym ) << " = data->data[spk_i]->" << s->synonym << "[spk_j];" << endl;
         }
      }
      
      oPred_h << "//=========================================" << endl;
      oPred_h << "// Begin User Code                         " << endl;
      oPred_h << "//-----------------------------------------" << endl;
      while( iPredEqn.get(ch) )
	oPred_h.put(ch);
      oPred_h << "//-----------------------------------------" << endl;
      oPred_h << "// End User Code                           " << endl;
      oPred_h << "//=========================================" << endl;
      
      oPred_h << "}" << endl;

      oPred_h << "template <class T>" << endl;
      oPred_h << "Pred<T>::Pred()" << endl;
      oPred_h << "{" << endl;
      oPred_h << "}" << endl;

      oPred_h << "template <class T>" << endl;
      oPred_h << "Pred<T>::Pred( const Pred<T>& )" << endl;
      oPred_h << "{" << endl;
      oPred_h << "}" << endl;

      oPred_h << "template <class T>" << endl;
      oPred_h << "Pred<T> & Pred<T>::operator=( const Pred<T>& )" << endl;
      oPred_h << "{" << endl;
      oPred_h << "}" << endl;

      oPred_h << "#endif" << endl;
    }
  else
    {
      assert( false );
    }
  iPredEqn.close();
  oPred_h.close();

}
