#include <fstream>

#include "NonmemTranslator.h"
#include "SpkCompilerException.h"

using namespace std;
using namespace xercesc;

void NonmemTranslator::generatePopDriver() const
{
  //==================================================================
  // Generate the driver
  //==================================================================
  ofstream oPopDriver ( fFitDriver_cpp );
  if( !oPopDriver.good() )
    {
      char mess[ SpkCompilerError::maxMessageLen() ];
      snprintf( mess, SpkCompilerError::maxMessageLen(),
		"Failed to create %s file.",
	       fFitDriver_cpp );
      SpkCompilerException e( SpkCompilerError::ASPK_STD_ERR, mess, __LINE__, __FILE__ );
      throw e;
    }

  const Symbol* pTheta = table->findi(KeyStr.THETA);
  const Symbol* pOmega = table->findi(KeyStr.OMEGA);
  const Symbol* pSigma = table->findi(KeyStr.SIGMA);
  const Symbol* pEta   = table->findi(KeyStr.ETA);
  
  oPopDriver << "// " << myDescription << endl;

  oPopDriver << "#include <iostream>"                   << endl;
  oPopDriver << "#include <fstream>"                    << endl;
  oPopDriver << "#include <sys/time.h>"                 << endl;
  oPopDriver << endl;

  oPopDriver << "#include <spk/SpkValarray.h>"          << endl;
  oPopDriver << "#include <spk/SpkException.h>"         << endl;
  oPopDriver << "#include <spk/WarningsManager.h>"      << endl;
  oPopDriver << "#include <CppAD/CppAD.h>"              << endl;
  oPopDriver << endl;
 
  oPopDriver << "// For parameter estimate " << endl;
  oPopDriver << "#include <spk/fitPopulation.h>"    << endl;
  oPopDriver << "#include <spk/Optimizer.h>"        << endl;
  oPopDriver << endl;

  oPopDriver << "// For statistics" << endl;
  oPopDriver << "#include <spk/derParStatistics.h>" << endl;
  oPopDriver << "#include <spk/popStatistics.h>"    << endl;
  oPopDriver << "#include <spk/inverse.h>"          << endl;
  oPopDriver << "#include <spk/lTilde.h>"           << endl;
  oPopDriver << "#include <spk/NaiveFoModel.h>"     << endl;
  oPopDriver << "#include <spk/multiply.h>"         << endl;
  oPopDriver << "#include <spk/cholesky.h>"         << endl;
  oPopDriver << "#include <spk/indResiduals.h>"     << endl;
  oPopDriver << "#include <spk/popResiduals.h>"     << endl;
  oPopDriver << "#include <spk/symmetrize.h>"       << endl;
  oPopDriver << endl;

  oPopDriver << "// For data simulation" << endl;
  oPopDriver << "#include <spk/simulate.h>" << endl;
  oPopDriver << endl;

  oPopDriver << "// SPK Compiler generated headers/classes" << endl;
  oPopDriver << "#include \"IndData.h\""      << endl;
  oPopDriver << "#include \"DataSet.h\""      << endl;
  oPopDriver << endl;

  oPopDriver << "//   NONMEM specific"   << endl;
  if( myModelSpec == PRED )
    oPopDriver << "#include \"Pred.h\"" << endl;
  else
    oPopDriver << "#include \"OdePred.h\"" << endl;

  oPopDriver << "#include <spkpred/PopPredModel.h>" << endl;
  oPopDriver << "#include \"NonmemPars.h\""   << endl;
  oPopDriver << endl;

  oPopDriver << "using SPK_VA::valarray;" << endl;
  oPopDriver << "using namespace std;" << endl;
  oPopDriver << endl;
  oPopDriver << "enum RETURN_CODE { SUCCESS              = 0,"   << endl;
  oPopDriver << "                   UNKNOWN_ERROR        = 1,"   << endl;
  oPopDriver << "                   UNKNOWN_FAILURE      = 2,"   << endl;
  oPopDriver << "                   FILE_ACCESS_ERROR    = 10,"  << endl;
  oPopDriver << "                   OPTIMIZATION_ERROR   = 12,"  << endl;
  oPopDriver << "                   STATISTICS_ERROR     = 13,"  << endl;
  oPopDriver << "                   USER_INPUT_ERROR     = 14,"  << endl;
  oPopDriver << "                   PROGRAMMER_ERROR     = 15,"  << endl;
  oPopDriver << "                   SIMULATION_ERROR     = 16,"  << endl;
  oPopDriver << "                   FILE_ACCESS_FAILURE  = 100," << endl;
  oPopDriver << "                   RESERVED_DO_NOT_USE  = 101," << endl;
  oPopDriver << "                   OPTIMIZATION_FAILURE = 102," << endl;
  oPopDriver << "                   STATISTICS_FAILURE   = 103," << endl;
  oPopDriver << "                   PROGRAMMER_FAILURE   = 105," << endl;
  oPopDriver << "                   SIMULATION_FAILURE   = 106"  << endl;
  oPopDriver << "                 };"       << endl;
  oPopDriver << endl;

  oPopDriver << "int main( int argc, const char argv[] )" << endl;
  oPopDriver << "{" << endl;
  oPopDriver << "   /*******************************************************************/" << endl;
  oPopDriver << "   /*                                                                 */" << endl;
  oPopDriver << "   /*   Variable declarations and definitions                         */" << endl;
  oPopDriver << "   /*                                                                 */" << endl;
  oPopDriver << "   /*******************************************************************/" << endl;
  oPopDriver << "   enum RETURN_CODE ret = SUCCESS;" << endl;
  oPopDriver << endl;

  oPopDriver << "   SpkException errors;" << endl;
  oPopDriver << "   try{" << endl;
  oPopDriver << "      ofstream oLongError;" << endl;
  oPopDriver << endl;

  oPopDriver << "      const bool isSimRequested     = " << (myIsSimulate? "true":"false") << ";" << endl;
  oPopDriver << "      bool haveCompleteData         = !isSimRequested;" << endl;
  oPopDriver << endl;

  oPopDriver << "      const bool isOptRequested     = " << (myIsEstimate? "true":"false") << ";" << endl;
  oPopDriver << "      bool isOptSuccess             = !isOptRequested;" << endl;
  oPopDriver << "      Objective objective           = ";
  if( getApproximation() == FO )
    oPopDriver << "FIRST_ORDER;" << endl;
  else if( getApproximation() == FOCE )
    oPopDriver << "EXPECTED_HESSIAN;" << endl;
  else
    oPopDriver << "MODIFIED_LAPLACE;" << endl;
  oPopDriver << endl;

  oPopDriver << "      const bool isStatRequested    = " << (myIsStat? "true":"false") << ";" << endl;
  oPopDriver << "      enum PopCovForm covForm       = " << myCovForm << ";" << endl;
  oPopDriver << "      bool isStatSuccess            = !isStatRequested;" << endl;
  oPopDriver << endl;

  oPopDriver << "      const bool isRestartRequested = " << (myIsRestart? "true":"false") << ";" << endl;
  oPopDriver << endl;

  oPopDriver << "      const int nRepeats            = " << mySubproblemsN << ";" << endl;
  oPopDriver << endl;

  oPopDriver << "      const bool isPostHoc          = " << (myIsPosthoc? "true" : "false") << ";" << endl;
  oPopDriver << endl;

  oPopDriver << "      DataSet< CppAD::AD<double> > set;" << endl;
  oPopDriver << "      const int           nPop      = set.getPopSize();" << endl;
  oPopDriver << "      const valarray<int> NObservs  = set.getNObservs();" << endl;
  oPopDriver << "      const valarray<int> NRecords  = set.getNRecords();" << endl;
  oPopDriver << "      const int           nY        = NObservs.sum();" << endl;
  oPopDriver << "      valarray<double>    y( nY );" << endl;
  oPopDriver << endl;

  oPopDriver << "      valarray<double> thetaIn  ( NonmemPars::thetaIn );" << endl;
  oPopDriver << "      valarray<double> omegaIn  ( NonmemPars::omegaIn );" << endl;
  oPopDriver << "      valarray<double> sigmaIn  ( NonmemPars::sigmaIn );" << endl;
  oPopDriver << "      valarray<double> thetaOut ( NonmemPars::nTheta );" << endl;
  oPopDriver << "      valarray<double> omegaOut ( NonmemPars::omegaOrder );" << endl;
  oPopDriver << "      valarray<double> sigmaOut ( NonmemPars::sigmaOrder );" << endl;
  oPopDriver << endl;

  oPopDriver << "      ///////////////////////////////////////////////////////////////////" << endl;
  oPopDriver << "      //   Model initialization" << endl;
  if( myModelSpec == PRED )
    {
      oPopDriver << "      Pred< CppAD::AD<double> > mPred(&set);" << endl;
    }
  else // ADVAN
    {
      oPopDriver << "      OdePred<CppAD::AD<double> > mPred( &set, " << endl;
      oPopDriver << "                                         nPop, " << endl;
      oPopDriver << "                                         NonmemPars::isPkFunctionOfT," << endl;
      oPopDriver << "                                         NonmemPars::nCompartments," << endl;
      oPopDriver << "                                         NonmemPars::nParameters," << endl;
      oPopDriver << "                                         NonmemPars::defaultDoseComp," << endl;
      oPopDriver << "                                         NonmemPars::defaultObservationComp," << endl;
      oPopDriver << "                                         NonmemPars::initialOff," << endl;
      oPopDriver << "                                         NonmemPars::noOff," << endl;
      oPopDriver << "                                         NonmemPars::noDose," << endl;
      oPopDriver << "                                         NonmemPars::relTol" << endl;
      oPopDriver << "                                       );" << endl;
    }
  oPopDriver << "      PopPredModel model( mPred,"                   << endl;
  oPopDriver << "                          NonmemPars::nTheta,"      << endl;
  oPopDriver << "                          NonmemPars::thetaLow,"    << endl;
  oPopDriver << "                          NonmemPars::thetaUp,"     << endl;
  oPopDriver << "                          NonmemPars::thetaIn,"     << endl;
  oPopDriver << "                          NonmemPars::nEta,"        << endl;
  oPopDriver << "                          NonmemPars::etaIn,"       << endl;
  oPopDriver << "                          NonmemPars::nEps,"        << endl;
  oPopDriver << "                          NonmemPars::omegaStruct," << endl;
  oPopDriver << "                          NonmemPars::omegaIn,"     << endl;
  oPopDriver << "                          NonmemPars::sigmaStruct," << endl;
  oPopDriver << "                          NonmemPars::sigmaIn );"   << endl;
  oPopDriver << "      //" << endl;
  oPopDriver << "      ///////////////////////////////////////////////////////////////////" << endl;
  oPopDriver << endl;
  oPopDriver << "      ///////////////////////////////////////////////////////////////////" << endl;
  oPopDriver << "      //   DataSet and Model for disposal; this DataSet instance is used " << endl;
  oPopDriver << "      //   for computations other than parameter estimation, in order to" << endl;
  oPopDriver << "      //   save the values at the end of estimation." << endl;
  oPopDriver << "      DataSet< CppAD::AD<double> > dataForDisposal;" << endl;
  if( myModelSpec == PRED )
    {
      oPopDriver << "      Pred< CppAD::AD<double> > predForDisposal(&dataForDisposal);" << endl;
    }
  else
    {
      oPopDriver << "      OdePred< CppAD::AD<double> > predForDisposal( &dataForDisposal, " << endl;
      oPopDriver << "                                         nPop, " << endl;
      oPopDriver << "                                         NonmemPars::isPkFunctionOfT," << endl;
      oPopDriver << "                                         NonmemPars::nCompartments," << endl;
      oPopDriver << "                                         NonmemPars::nParameters," << endl;
      oPopDriver << "                                         NonmemPars::defaultDoseComp," << endl;
      oPopDriver << "                                         NonmemPars::defaultObservationComp," << endl;
      oPopDriver << "                                         NonmemPars::initialOff," << endl;
      oPopDriver << "                                         NonmemPars::noOff," << endl;
      oPopDriver << "                                         NonmemPars::noDose," << endl;
      oPopDriver << "                                         NonmemPars::relTol" << endl;
      oPopDriver << "                                       );" << endl;
    }
  oPopDriver << "      PopPredModel modelForDisposal( predForDisposal,"                   << endl;
  oPopDriver << "                          NonmemPars::nTheta,"      << endl;
  oPopDriver << "                          NonmemPars::thetaLow,"    << endl;
  oPopDriver << "                          NonmemPars::thetaUp,"     << endl;
  oPopDriver << "                          NonmemPars::thetaIn,"     << endl;
  oPopDriver << "                          NonmemPars::nEta,"        << endl;
  oPopDriver << "                          NonmemPars::etaIn,"       << endl;
  oPopDriver << "                          NonmemPars::nEps,"        << endl;
  oPopDriver << "                          NonmemPars::omegaStruct," << endl;
  oPopDriver << "                          NonmemPars::omegaIn,"     << endl;
  oPopDriver << "                          NonmemPars::sigmaStruct," << endl;
  oPopDriver << "                          NonmemPars::sigmaIn );"   << endl;
  oPopDriver << "      //" << endl;
  oPopDriver << "      ///////////////////////////////////////////////////////////////////" << endl;
  oPopDriver << endl;

  oPopDriver << "      const int nAlp = model.getNPopPar();" << endl;
  oPopDriver << "      const int nB   = model.getNIndPar();" << endl;
  oPopDriver << endl;
   
  oPopDriver << "      valarray<double> alpIn  ( nAlp );" << endl;
  oPopDriver << "      valarray<double> alpUp  ( nAlp );" << endl;
  oPopDriver << "      valarray<double> alpLow ( nAlp );" << endl;
  oPopDriver << "      valarray<double> alpStep( nAlp );" << endl;
  oPopDriver << "      valarray<double> alpOut ( nAlp );" << endl;
  oPopDriver << "      valarray<bool>   alpMask( nAlp );" << endl;
  oPopDriver << endl;
  
  oPopDriver << "      double           alpObjOut;" << endl;
  oPopDriver << "      valarray<double> alpObj_alpOut    ( nAlp );" << endl;
  oPopDriver << "      valarray<double> alpObj_alp_alpOut( nAlp * nAlp );" << endl;
  oPopDriver << endl;

  oPopDriver << "      model.getPopPar         ( alpIn );" << endl;
  oPopDriver << "      model.getPopParLimits   ( alpLow, alpUp );" << endl;
  oPopDriver << "      model.getPopParStep     ( alpStep );" << endl;

  oPopDriver << endl;

  oPopDriver << "      valarray<double> bIn  ( nB * nPop );" << endl;
  oPopDriver << "      valarray<double> biIn ( nB );" << endl;
  oPopDriver << "      valarray<double> bUp  ( nB );" << endl;
  oPopDriver << "      valarray<double> bLow ( nB );" << endl;
  oPopDriver << "      valarray<double> bStep( nB );" << endl;
  oPopDriver << "      valarray<double> bOut ( nB * nPop );" << endl;
  oPopDriver << "      for( int i=0; i<nPop; i++ )" << endl;
  oPopDriver << "      {" << endl;
  oPopDriver << "         model.selectIndividual( i ); " << endl;
  oPopDriver << "         model.getIndPar( biIn );" << endl;
  oPopDriver << "         bIn[ slice(i*nB, nB, 1) ] = biIn;" << endl;
  oPopDriver << "      }" << endl;
  oPopDriver << "      model.getIndParLimits ( bLow, bUp );" << endl;
  oPopDriver << "      model.getIndParStep   ( bStep );" << endl;
  oPopDriver << endl;

  oPopDriver << "      timeval optBegin, optEnd;" << endl;
  oPopDriver << "      double  optTimeSec = 0.0;" << endl;
  oPopDriver << "      const   double popEps             = "   << myPopEpsilon    << ";" << endl;
  oPopDriver << "      const   int    popMitr            = "   << myPopMitr       << ";" << endl;
  oPopDriver << "      const   int    popTrace           = "   << myPopTraceLevel << ";" << endl;
  oPopDriver << "      const   string popCheckpointFile  = \"" << fCheckpoint_xml << "\";" << endl;
  oPopDriver << "      bool           popWriteCheckpoint = "   << (myPopWriteCheckpoint? "true":"false") << ";" << endl;
  oPopDriver << "      ifstream       iCheckpoint( popCheckpointFile.c_str() );"  << endl;
  oPopDriver << "      // Error if the user asked to continue but no checkpoint.xml is found " << endl;
  oPopDriver << "      // in the current directory." << endl;
  oPopDriver << "      if( isRestartRequested && !iCheckpoint.good() )" << endl;
  oPopDriver << "      {" << endl;
  oPopDriver << "         char m[ SpkError::maxMessageLen()];" << endl;
  oPopDriver << "         snprintf( m, " << endl;
  oPopDriver << "                   SpkError::maxMessageLen()," << endl;
  oPopDriver << "                   \"Warm start is request but no checkpoint file found.\" );" << endl;
  oPopDriver << "         SpkError e( SpkError::SPK_STD_ERR, m, __LINE__, __FILE__);" << endl;
  oPopDriver << "         errors.push( e );" << endl;
  oPopDriver << "         ret = FILE_ACCESS_FAILURE;" << endl;
  oPopDriver << "      }" << endl;
  oPopDriver << "      // Flag to read the checkpoint file if that exists even " << endl;
  oPopDriver << "      // if the user didn't ask a continuation." << endl;
  oPopDriver << "      bool           popReadCheckpoint  = iCheckpoint.good();"   << endl;
  oPopDriver << "      iCheckpoint.close();"                                    << endl;
  oPopDriver << "      Optimizer      popOpt( popEps, "                           << endl;
  oPopDriver << "                             popMitr, "                          << endl;
  oPopDriver << "                             popTrace, "                         << endl;
  oPopDriver << "                             popCheckpointFile, "                << endl;
  oPopDriver << "                             popReadCheckpoint,"                 << endl;
  oPopDriver << "                             popWriteCheckpoint );"              << endl;
  oPopDriver << endl;
  oPopDriver << "      const double   indEps   = " << myIndEpsilon    << ";" << endl;
  oPopDriver << "      const int      indMitr  = " << myIndMitr       << ";" << endl;
  oPopDriver << "      const int      indTrace = " << myIndTraceLevel << ";" << endl;
  oPopDriver << "      Optimizer      indOpt( indEps, indMitr, indTrace );"  << endl;
  oPopDriver << endl;
 
  oPopDriver << "      timeval statBegin, statEnd;"                               << endl;
  oPopDriver << "      double statTimeSec = 0.0;"                                 << endl;
  oPopDriver << "      valarray<double> alpCov( nAlp * nAlp );"                   << endl;
  oPopDriver << "      valarray<double> stdPar( nAlp );"                          << endl;
  oPopDriver << "      valarray<double> stdPar_alp( nAlp * nAlp );"               << endl;
  oPopDriver << "      const int nDegOfFreedom = nY - nAlp;"                      << endl;
  oPopDriver << "      bool isCovOut         = " << ( myIsCov?    "true" : "false" ) << ";"      << endl;
  oPopDriver << "      bool isInvCovOut      = " << ( myIsInvCov? "true" : "false" ) << ";"      << endl;
  oPopDriver << "      bool isStdErrOut      = " << ( myIsStderr? "true" : "false" ) << ";"      << endl;
  oPopDriver << "      bool isCorrelationOut = " << ( myIsCorrelation? "true" : "false" ) << ";" << endl;
  oPopDriver << "      bool isCoefficientOut = " << ( myIsCoefficient? "true" : "false" ) << ";" << endl;
  oPopDriver << "      bool isConfidenceOut  = " << ( myIsConfidence?  "true" : "false" ) << ";" << endl;
  oPopDriver << "      valarray<double> stdParCovOut        ( nAlp * nAlp );"     << endl;
  oPopDriver << "      valarray<double> stdParSEOut         ( nAlp );"            << endl;
  oPopDriver << "      valarray<double> stdParCorrelationOut( nAlp * nAlp );"     << endl;
  oPopDriver << "      valarray<double> stdParCoefficientOut( nAlp );"            << endl;
  oPopDriver << "      valarray<double> stdParConfidenceOut ( 2 * nAlp );"        << endl;
  oPopDriver << "      valarray<double> stdParInvCovOut     ( nAlp * nAlp );"     << endl;
  oPopDriver << endl;

  oPopDriver << "      int nTotalRecords = 0;" << endl;
  oPopDriver << "      for( int i=0; i<nPop; i++ )" << endl;
  oPopDriver << "         nTotalRecords += set.getNRecords(i);" << endl;
  oPopDriver << "      valarray<double> iPredOut              ( nTotalRecords );"      << endl;
  oPopDriver << "      valarray<double> iResOut               ( nTotalRecords );"      << endl;
  oPopDriver << "      valarray<double> iResWtdOut            ( nTotalRecords );"      << endl;
  oPopDriver << "      valarray<double> iParResOut            ( nB*nPop );" << endl;
  oPopDriver << "      valarray<double> iParResWtdOut         ( nB*nPop );" << endl;
  oPopDriver << "      valarray<double> iPredTrancatedOut     ( nY );"      << endl;
  oPopDriver << "      valarray<double> iResTrancatedOut      ( nY );"      << endl;
  oPopDriver << "      valarray<double> iResWtdTrancatedOut   ( nY );"      << endl;
  oPopDriver << endl;
  oPopDriver << "      valarray<double> pPredOut              ( nTotalRecords );"      << endl;
  oPopDriver << "      valarray<double> pResOut               ( nTotalRecords );"      << endl;
  oPopDriver << "      valarray<double> pResWtdOut            ( nTotalRecords );"      << endl;
  oPopDriver << "      valarray<double> pParResOut            ( nB*nPop );" << endl;
  oPopDriver << "      valarray<double> pParResWtdOut         ( nB*nPop );" << endl;
  oPopDriver << "      valarray<double> pPredTrancatedOut     ( nY );"      << endl;
  oPopDriver << "      valarray<double> pResTrancatedOut      ( nY );"      << endl;
  oPopDriver << "      valarray<double> pResWtdTrancatedOut   ( nY );"      << endl;
  oPopDriver << endl;
  oPopDriver << "      valarray<double> cPredOut              ( nTotalRecords );"      << endl;
  oPopDriver << "      valarray<double> cResOut               ( nTotalRecords );"      << endl;
  oPopDriver << "      valarray<double> cResWtdOut            ( nTotalRecords );"      << endl;
  oPopDriver << "      valarray<double> cParResOut            ( nB*nPop );" << endl;
  oPopDriver << "      valarray<double> cParResWtdOut         ( nB*nPop );" << endl;
  oPopDriver << "      valarray<double> cPredTrancatedOut     ( nY );"      << endl;
  oPopDriver << "      valarray<double> cResTrancatedOut      ( nY );"      << endl;
  oPopDriver << "      valarray<double> cResWtdTrancatedOut   ( nY );"      << endl;
  oPopDriver << endl;

  oPopDriver << "      ofstream oResults;" << endl;
  oPopDriver << "      string warningsOut;" << endl;
  oPopDriver << "      int seed = NonmemPars::seed; " << endl;
  oPopDriver << "      srand( seed );" << endl;
  oPopDriver << "      int iSub = 0;" << endl;
  oPopDriver << endl;

  // do data simulation first to replace DV data in IndData objects
  oPopDriver << "      if( ret != SUCCESS )" << endl;
  oPopDriver << "        goto REPORT_GEN;" << endl;
  oPopDriver << endl;
  oPopDriver << "      remove( \"result.xml\" );" << endl;
  oPopDriver << "      for( iSub=0; iSub<nRepeats; iSub++ )" << endl;
  oPopDriver << "      {" << endl;
  oPopDriver << "         /*******************************************************************/" << endl;
  oPopDriver << "         /*                                                                 */" << endl;
  oPopDriver << "         /*   Data Initialization                                           */" << endl;
  oPopDriver << "         /*                                                                 */" << endl;
  oPopDriver << "         /*******************************************************************/" << endl;
  oPopDriver << "         if( isSimRequested )" << endl;
  oPopDriver << "         {" << endl;
  oPopDriver << "            valarray<double> yOut( nY );" << endl;
  oPopDriver << "            try" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               simulate( model, alpIn, NObservs, bLow, bUp, yOut, bOut );" << endl;
  oPopDriver << "               bIn = bOut;" << endl;
  oPopDriver << "               set.replaceAllMeasurements( yOut );" << endl;
  oPopDriver << "               y   = yOut;" << endl;
  oPopDriver << "               haveCompleteData = true;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            catch( const SpkException& e )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               errors.cat( e );" << endl;
  oPopDriver << "               haveCompleteData = false;" << endl;
  oPopDriver << "               ret = SIMULATION_ERROR;" << endl;
  oPopDriver << "               goto REPORT_GEN;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            catch( ... )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               char message[] =\"Unknown exception: failed in data simulation!!!\";" << endl;
  oPopDriver << "               SpkError e( SpkError::SPK_UNKNOWN_ERR, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "               errors.push( e );" << endl;
  oPopDriver << "               haveCompleteData = false;" << endl;
  oPopDriver << "               ret = SIMULATION_FAILURE;" << endl;
  oPopDriver << "               goto REPORT_GEN;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "         }" << endl;
  oPopDriver << "         else" << endl;
  oPopDriver << "         {" << endl;
  oPopDriver << "            y = set.getAllMeasurements();" << endl;
  oPopDriver << "            haveCompleteData = true;" << endl;
  oPopDriver << endl;
  oPopDriver << "         }" << endl;
  oPopDriver << endl;
 
  oPopDriver << "OPTIMIZATION:" << endl;
  oPopDriver << "         /*******************************************************************/" << endl;
  oPopDriver << "         /*                                                                 */" << endl;
  oPopDriver << "         /*   Parameter Estimation                                          */" << endl;
  oPopDriver << "         /*                                                                 */" << endl;
  oPopDriver << "         /*******************************************************************/" << endl;
  oPopDriver << "         if( isOptRequested && haveCompleteData )" << endl;
  oPopDriver << "         {" << endl;
  oPopDriver << "            gettimeofday( &optBegin, NULL );" << endl;
  oPopDriver << "            try" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               fitPopulation( model,"         << endl;
  oPopDriver << "                              objective, "    << endl;
  oPopDriver << "                              NObservs,"             << endl;
  oPopDriver << "                              y,"             << endl;
  oPopDriver << "                              popOpt,"        << endl;
  oPopDriver << "                              alpLow,"        << endl;
  oPopDriver << "                              alpUp,"         << endl;
  oPopDriver << "                              alpIn,"         << endl;
  oPopDriver << "                              alpStep,"       << endl;
  oPopDriver << "                             &alpOut,"        << endl;
  oPopDriver << "                              indOpt,"        << endl;
  oPopDriver << "                              bLow,"          << endl;
  oPopDriver << "                              bUp,"           << endl;
  oPopDriver << "                              bIn,"           << endl;
  oPopDriver << "                              bStep,"         << endl;
  oPopDriver << "                             &bOut,"          << endl;
  oPopDriver << "                             &alpObjOut,"     << endl;
  oPopDriver << "                             &alpObj_alpOut," << endl;
  oPopDriver << "                             &alpObj_alp_alpOut );" << endl;
  oPopDriver << "               isOptSuccess = true;"          << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            catch( SpkException& e )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               if( e.find( SpkError::SPK_TOO_MANY_ITER ) )" << endl;
  oPopDriver << "                  ret = OPTIMIZATION_ERROR;" << endl;
  oPopDriver << "               else" << endl;
  oPopDriver << "                  ret = USER_INPUT_ERROR;" << endl;
  oPopDriver << "               errors.cat( e );" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            catch( ... )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               char message[] = \"Unknown exception: failed in parameter estimation!!!\";" << endl;
  oPopDriver << "               SpkError e( SpkError::SPK_UNKNOWN_ERR, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "               errors.push( e );" << endl;
  oPopDriver << "               isOptSuccess = false;" << endl;
  oPopDriver << "               ret = OPTIMIZATION_FAILURE;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            gettimeofday( &optEnd, NULL );" << endl;
  oPopDriver << "            optTimeSec = difftime( optEnd.tv_sec, optBegin.tv_sec );" << endl;
  oPopDriver << endl;
  oPopDriver << "            // Get the latest values of theta, Omega and Sigma." << endl;
  oPopDriver << "            // These values may be garbage if optimization had failed." << endl;
  oPopDriver << "            model.getTheta( thetaOut );" << endl;
  oPopDriver << "            model.getOmega( omegaOut );" << endl;
  oPopDriver << "            model.getSigma( sigmaOut );" << endl;
  oPopDriver << "            set.replaceEta( bOut );" << endl;
  oPopDriver << endl;
  oPopDriver << "            if( !isOptSuccess )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               string optErrHeader;" << endl;
  oPopDriver << "               string optErrMessage;" << endl;
  oPopDriver << "               oLongError.open( \"" << fSpkRuntimeLongError_tmp << "\" );" << endl;
  oPopDriver << "               if( !oLongError.good() )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  char m[ SpkError::maxMessageLen() ];" << endl;
  oPopDriver << "                  snprintf( m, " << endl;
  oPopDriver << "                            SpkError::maxMessageLen()," << endl;
  oPopDriver << "                            \"Failed to create a temporary file, %s, for writing.\", " << endl;
  oPopDriver << "                           \"" << fSpkRuntimeLongError_tmp << "\" );" << endl;
  oPopDriver << "                  SpkError e( SpkError::SPK_STD_ERR, m, __LINE__, __FILE__ );" << endl;
  oPopDriver << "                  errors.push( e );" << endl;
  oPopDriver << "                  ret = FILE_ACCESS_FAILURE;" << endl;
  oPopDriver << "                  goto REPORT_GEN;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               // If individual level estimation failed, then get any details as to why." << endl;
  oPopDriver << "               if( indOpt.isThereErrorInfo() )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  optErrHeader  = \"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \\n\";" << endl;
  oPopDriver << "                  optErrHeader += \"Individual level optimization failure details. \\n\";" << endl;
  oPopDriver << "                  optErrHeader += \"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \\n\";" << endl;
  oPopDriver << "                  optErrHeader += \"\\n\";" << endl;
  oPopDriver << "                  indOpt.getErrorInfo(" << endl;
  oPopDriver << "                                       optErrHeader," << endl;
  oPopDriver << "                                       optErrMessage," << endl;
  oPopDriver << "                                       __LINE__," << endl;
  oPopDriver << "                                       __FILE__ );" << endl;
  oPopDriver << "                  oLongError << optErrMessage << endl;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               // If population level estimation failed, then get any details as to why." << endl;
  oPopDriver << "               if( popOpt.isThereErrorInfo() )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  optErrHeader  = \"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \\n\";" << endl;
  oPopDriver << "                  optErrHeader += \"Population level optimization failure details. \\n\";" << endl;
  oPopDriver << "                  optErrHeader += \"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \\n\";" << endl;
  oPopDriver << "                  optErrHeader += \"\\n\";" << endl;
  oPopDriver << "                  popOpt.getErrorInfo(" << endl;
  oPopDriver << "                                       optErrHeader," << endl;
  oPopDriver << "                                       optErrMessage," << endl;
  oPopDriver << "                                       __LINE__," << endl;
  oPopDriver << "                                       __FILE__ );" << endl;
  oPopDriver << "                  oLongError << optErrMessage << endl;" << endl;
  oPopDriver << "                  oLongError.close();" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "         }" << endl;
  oPopDriver << endl;

  oPopDriver << "         if( isOptRequested && isOptSuccess )" << endl;
  oPopDriver << "         {" << endl;
  oPopDriver << "            assert( haveCompleteData );" << endl;
  oPopDriver << "            Objective objForDisposal = FIRST_ORDER;"    << endl;
  oPopDriver << "            valarray<double> yi;"                       << endl;
  oPopDriver << "            valarray<double> bi( nB );"                 << endl;
  oPopDriver << "            valarray<double> iiPredOut;"                << endl;
  oPopDriver << "            valarray<double> iiResOut; "                << endl;
  oPopDriver << "            valarray<double> iiResWtdOut;"              << endl;
  oPopDriver << "            valarray<double> iiParResOut( nB );"        << endl;
  oPopDriver << "            valarray<double> iiParResWtdOut( nB );"     << endl;
  oPopDriver << "            valarray<double> iiPredTrancatedOut;"       << endl;
  oPopDriver << "            valarray<double> iiResTrancatedOut; "       << endl;
  oPopDriver << "            valarray<double> iiResWtdTrancatedOut;"     << endl;
  oPopDriver << "            modelForDisposal.setPopPar( alpOut );"      << endl;
  oPopDriver << "            for( int i=0, k=0; i<nPop; k+=NRecords[i++] )"     << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               yi.resize         ( NObservs[i] );"             << endl;
  oPopDriver << "               iiPredOut.resize  ( dataForDisposal.getNRecords(i) );" << endl;
  oPopDriver << "               iiResOut.resize   ( dataForDisposal.getNRecords(i) );" << endl;
  oPopDriver << "               iiResWtdOut.resize( dataForDisposal.getNRecords(i) );" << endl;
  oPopDriver << "               iiPredTrancatedOut.resize  ( NObservs[i] );"    << endl;
  oPopDriver << "               iiResTrancatedOut.resize   ( NObservs[i] );"    << endl;
  oPopDriver << "               iiResWtdTrancatedOut.resize( NObservs[i] );"    << endl;
  oPopDriver << "               yi = y[ slice( k, NObservs[i], 1 ) ]; "         << endl;
  oPopDriver << "               bi = bOut[ slice( i*nB, nB, 1 ) ];"      << endl;
  oPopDriver << "               modelForDisposal.selectIndividual( i );" << endl;
  oPopDriver << "               modelForDisposal.setIndPar( bi );"       << endl;
  oPopDriver << "               try{" << endl;
  oPopDriver << "                  indResiduals( modelForDisposal,"      << endl;
  oPopDriver << "                                yi, "                   << endl;
  oPopDriver << "                                bi,"                    << endl;
  oPopDriver << "                               &iiPredTrancatedOut,"    << endl;
  oPopDriver << "                               &iiResTrancatedOut,"     << endl;
  oPopDriver << "                               &iiResWtdTrancatedOut, " << endl;
  oPopDriver << "                               &iiParResOut, "          << endl;
  oPopDriver << "                               &iiParResWtdOut );"      << endl;
  oPopDriver << "                  dataForDisposal.expand( iiPredTrancatedOut,   iiPredOut );"   << endl;
  oPopDriver << "                  dataForDisposal.expand( iiResTrancatedOut,    iiResOut );"    << endl;
  oPopDriver << "                  dataForDisposal.expand( iiResWtdTrancatedOut, iiResWtdOut );" << endl;
   oPopDriver << "               }" << endl;
  oPopDriver << "               catch( SpkException& e )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  char message[SpkError::maxMessageLen()];" << endl;
  oPopDriver << "                  snprintf( message, " << endl;
  oPopDriver << "                            SpkError::maxMessageLen()," << endl;
  oPopDriver <<"                            \"Failed during the calculation of %i-th individual's residuals!\", i );" << endl;
  oPopDriver << "                  SpkError ee( SpkError::SPK_STATISTICS_ERR, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "                  e.push( ee );" << endl;
  oPopDriver << "                  errors.cat( e );" << endl;
  oPopDriver << "                  isStatSuccess &= false;" << endl;
  oPopDriver << "                  ret = PROGRAMMER_FAILURE;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               catch( ... )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  char message[SpkError::maxMessageLen()];" << endl;
  oPopDriver << "                  snprintf( message, " << endl;
  oPopDriver << "                            SpkError::maxMessageLen()," << endl;
  oPopDriver << "                           \"Unknown exception: failed during the calculation of %i-th individual's residuals!!!\", i );" << endl;
  oPopDriver << "                  SpkError e( SpkError::SPK_UNKNOWN_ERR, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "                  errors.push( e );" << endl;
  oPopDriver << "                  isStatSuccess &= false;" << endl;
  oPopDriver << "                  ret = STATISTICS_FAILURE;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               iPredOut     [ slice( k, set.getNRecords(i), 1 ) ]  = iiPredOut;"      << endl;
  oPopDriver << "               iResOut      [ slice( k, set.getNRecords(i), 1 ) ]  = iiResOut;"       << endl;
  oPopDriver << "               iResWtdOut   [ slice( k, set.getNRecords(i), 1 ) ]  = iiResWtdOut;"    << endl;
  oPopDriver << "               iParResOut   [ slice( nB*i, nB, 1 ) ] = iiParResOut;"    << endl;
  oPopDriver << "               iParResWtdOut[ slice( nB*i, nB, 1 ) ] = iiParResWtdOut;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            set.replaceIPred   ( iPredOut );"           << endl;
  oPopDriver << "            set.replaceIRes    ( iResOut );"            << endl;
  oPopDriver << "            set.replaceIWRes   ( iResWtdOut );"         << endl;
  oPopDriver << "            set.replaceIEtaRes ( iParResOut );"         << endl;
  oPopDriver << "            set.replaceIWEtaRes( iParResWtdOut );"      << endl;
  oPopDriver << endl;
  oPopDriver << "            try{" << endl;
  oPopDriver << "               objForDisposal = FIRST_ORDER;"           << endl;
  oPopDriver << "               popResiduals( modelForDisposal, "        << endl;
  oPopDriver << "                             objForDisposal, "          << endl;
  oPopDriver << "                             NObservs,"                 << endl;
  oPopDriver << "                             y,"                        << endl;
  oPopDriver << "                             alpOut,"                   << endl;
  oPopDriver << "                             bOut,"                     << endl;
  oPopDriver << "                            &pPredTrancatedOut, "       << endl;
  oPopDriver << "                            &pResTrancatedOut, "        << endl;
  oPopDriver << "                            &pResWtdTrancatedOut, "     << endl;
  oPopDriver << "                            &pParResOut, "              << endl;
  oPopDriver << "                            &pParResWtdOut );"          << endl;
  oPopDriver << "               dataForDisposal.expand( pPredTrancatedOut,   pPredOut );"   << endl;
  oPopDriver << "               dataForDisposal.expand( pResTrancatedOut,    pResOut );"    << endl;
  oPopDriver << "               dataForDisposal.expand( pResWtdTrancatedOut, pResWtdOut );" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "            catch( SpkException& e )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               char message[] = \"Failed during the calculation of population (non-conditional) residuals!!!\";" << endl;
  oPopDriver << "               SpkError ee( SpkError::SPK_STATISTICS_ERR, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "               e.push( ee );" << endl;
  oPopDriver << "               errors.cat( e );" << endl;
  oPopDriver << "               ret = PROGRAMMER_FAILURE;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            catch( ... )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               char message[] = \"Unknown exception: failed during the calculation of population (non-conditional) residuals!!!\";" << endl;
  oPopDriver << "               SpkError e( SpkError::SPK_UNKNOWN_ERR, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "               errors.push( e );" << endl;
  oPopDriver << "               ret = PROGRAMMER_FAILURE;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            set.replacePPred   ( pPredOut );"           << endl;
  oPopDriver << "            set.replacePRes    ( pResOut );"            << endl;
  oPopDriver << "            set.replacePWRes   ( pResWtdOut );"         << endl;
  oPopDriver << "            set.replacePEtaRes ( pParResOut );"         << endl;
  oPopDriver << "            set.replacePWEtaRes( pParResWtdOut );"      << endl;
  oPopDriver << endl;
  oPopDriver << "            objForDisposal = EXPECTED_HESSIAN;"         << endl;
  oPopDriver << "            try{" << endl;
  oPopDriver << "               popResiduals( modelForDisposal, "        << endl;
  oPopDriver << "                             objForDisposal, "          << endl;
  oPopDriver << "                             NObservs,"                 << endl;
  oPopDriver << "                             y,"                        << endl;
  oPopDriver << "                             alpOut,"                   << endl;
  oPopDriver << "                             bOut,"                     << endl;
  oPopDriver << "                            &cPredTrancatedOut, "       << endl;
  oPopDriver << "                            &cResTrancatedOut, "        << endl;
  oPopDriver << "                            &cResWtdTrancatedOut, "     << endl;
  oPopDriver << "                            &cParResOut, "              << endl;
  oPopDriver << "                            &cParResWtdOut );"          << endl;
  oPopDriver << "               dataForDisposal.expand( cPredTrancatedOut,   cPredOut );"   << endl;
  oPopDriver << "               dataForDisposal.expand( cResTrancatedOut,    cResOut );"    << endl;
  oPopDriver << "               dataForDisposal.expand( cResWtdTrancatedOut, cResWtdOut );" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "            catch( SpkException& e )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               char message[] = \"Failed during the calculation of conditional residuals!!!\";" << endl;
  oPopDriver << "               SpkError ee( SpkError::SPK_STATISTICS_ERR, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "               e.push( ee );" << endl;
  oPopDriver << "               errors.cat( e );" << endl;
  oPopDriver << "               isStatSuccess &= false;" << endl;
  oPopDriver << "               ret = PROGRAMMER_FAILURE;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            catch( ... )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               char message[] = \"Unknown exception: failed during the calculation of conditional residuals!!!\";" << endl;
  oPopDriver << "               SpkError e( SpkError::SPK_UNKNOWN_ERR, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "               errors.push( e );" << endl;
  oPopDriver << "               isStatSuccess &= false;" << endl;
  oPopDriver << "               ret = PROGRAMMER_FAILURE;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            set.replaceCPred   ( cPredOut );"        << endl;
  oPopDriver << "            set.replaceCRes    ( cResOut );"         << endl;
  oPopDriver << "            set.replaceCWRes   ( cResWtdOut );"      << endl;
  oPopDriver << "            set.replaceCEtaRes ( cParResOut );"      << endl;
  oPopDriver << "            set.replaceCWEtaRes( cParResWtdOut );"   << endl;
  oPopDriver << endl;
  oPopDriver << "            if( isPostHoc )" << endl;
  oPopDriver << "            {" << endl;
  //  oPopDriver << "               set.replacePred    ( iPredOut );"        << endl;
  //  oPopDriver << "               set.replaceRes     ( iResOut );"         << endl;
  oPopDriver << "               set.replaceWRes    ( iResWtdOut );"      << endl;
  oPopDriver << "               set.replaceEtaRes  ( iParResOut );"      << endl;
  oPopDriver << "               set.replaceWEtaRes ( iParResWtdOut );"   << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            else" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               if( objective == FIRST_ORDER )" << endl;
  oPopDriver << "               {" << endl;
  //  oPopDriver << "                  set.replacePred    ( pPredOut );"        << endl;
  //  oPopDriver << "                  set.replaceRes     ( pResOut );"         << endl;
  oPopDriver << "                  set.replaceWRes    ( pResWtdOut );"      << endl;
  oPopDriver << "                  set.replaceEtaRes  ( pParResOut );"      << endl;
  oPopDriver << "                  set.replaceWEtaRes ( pParResWtdOut );"   << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               else // conditional" << endl;
  oPopDriver << "               {" << endl;
  //  oPopDriver << "                  set.replacePred    ( cPredOut );"        << endl;
  //  oPopDriver << "                  set.replaceRes     ( cResOut );"         << endl;
  oPopDriver << "                  set.replaceWRes    ( cResWtdOut );"      << endl;
  oPopDriver << "                  set.replaceEtaRes  ( cParResOut );"      << endl;
  oPopDriver << "                  set.replaceWEtaRes ( cParResWtdOut );"   << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "         }" << endl;

  oPopDriver << endl;
 
  // Statistics can be only computed when the parameter estimation has been done.
  oPopDriver << "STATISTICS:" << endl;
  oPopDriver << "         /*******************************************************************/" << endl;
  oPopDriver << "         /*                                                                 */" << endl;
  oPopDriver << "         /*   Statistics                                                    */" << endl;
  oPopDriver << "         /*                                                                 */" << endl;
  oPopDriver << "         /*******************************************************************/" << endl;
  oPopDriver << "         if( isStatRequested && isOptRequested && isOptSuccess )" << endl;
  oPopDriver << "         {" << endl;
  oPopDriver << "            gettimeofday( &statBegin, NULL );" << endl;
  oPopDriver << "            try" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               for( int i=0; i<nAlp; i++ )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  alpMask[i] = !( alpLow[i]==alpUp[i] || alpOut[i]==alpLow[i] || alpOut[i]==alpUp[i] );" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               model.getStandardPar( stdPar );" << endl;
  oPopDriver << "               model.getStandardPar_popPar( stdPar_alp );" << endl;
  oPopDriver << "               popStatistics(    modelForDisposal, "                  << endl;
  oPopDriver << "                                 objective,"               << endl;
  oPopDriver << "                                 NObservs,"                << endl;
  oPopDriver << "                                 y,"                       << endl;
  oPopDriver << "                                 alpOut, "                 << endl;
  oPopDriver << "                                 alpMask,"                 << endl;
  oPopDriver << "                                 alpObj_alp_alpOut, "      << endl;
  oPopDriver << "                                 bOut,"                    << endl;
  oPopDriver << "                                 bLow,"                    << endl;
  oPopDriver << "                                 bUp,"                     << endl;
  oPopDriver << "                                 bStep,"                   << endl;
  oPopDriver << "                                 covForm,"                 << endl;
  oPopDriver << "                                &alpCov, "                 << endl;
  oPopDriver << "                                 NULL, "                   << endl;
  oPopDriver << "                                 NULL, "                   << endl;
  oPopDriver << "                                 NULL, "                   << endl;
  oPopDriver << "                                 NULL );"                  << endl;
  oPopDriver << endl;
  oPopDriver << "               derParStatistics( alpMask,"                 << endl;
  oPopDriver << "                                 alpCov,"                  << endl;
  oPopDriver << "                                 stdPar,"                  << endl;
  oPopDriver << "                                 stdPar_alp,"              << endl;
  oPopDriver << "                                 nDegOfFreedom,"           << endl;
  oPopDriver << "                                (isCovOut || isInvCovOut? &stdParCovOut        : NULL)," << endl;
  oPopDriver << "                                (isCovOut || isInvCovOut? &stdParInvCovOut     : NULL)," << endl;
  oPopDriver << "                                (isStdErrOut?             &stdParSEOut         : NULL)," << endl;
  oPopDriver << "                                (isCorrelationOut?        &stdParCorrelationOut: NULL)," << endl;
  oPopDriver << "                                (isCoefficientOut?        &stdParCoefficientOut: NULL)," << endl;
  oPopDriver << "                                (isConfidenceOut?         &stdParConfidenceOut : NULL) " << endl;
  oPopDriver << "                               );" << endl;
  oPopDriver << "               isStatSuccess &= true;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            catch( SpkException& e )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               char mess[ SpkError::maxMessageLen() ];" << endl;
  oPopDriver << "               snprintf( mess, " << endl;
  oPopDriver << "                         SpkError::maxMessageLen()," << endl;
  oPopDriver << "                        \"Failed to compute statistics value(s).\\n\" );" << endl;
  oPopDriver << "               e.push( SpkError::SPK_STATISTICS_ERR, mess, __LINE__, __FILE__ );" << endl;
  oPopDriver << "               errors.cat( e );" << endl;
  oPopDriver << "               isStatSuccess &= false;" << endl;
  oPopDriver << "               ret = STATISTICS_ERROR;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            catch( ... )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               char message[] = \"Unknown exception: failed in statistics calculation!!!\";" << endl;
  oPopDriver << "               SpkError e( SpkError::SPK_UNKNOWN_ERR, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "               errors.push( e );" << endl;
  oPopDriver << "               isStatSuccess &= false;" << endl;
  oPopDriver << "               ret = STATISTICS_FAILURE;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            gettimeofday( &statEnd, NULL );" << endl;
  oPopDriver << "            statTimeSec = difftime( statEnd.tv_sec, statBegin.tv_sec );" << endl;
  oPopDriver << "         }" << endl;
  oPopDriver << endl;

  oPopDriver << "REPORT_GEN:" << endl;
  oPopDriver << "         /*******************************************************************/" << endl;
  oPopDriver << "         /*                                                                 */" << endl;
  oPopDriver << "         /*   ReportML Document                                             */" << endl;
  oPopDriver << "         /*                                                                 */" << endl;
  oPopDriver << "         /*******************************************************************/" << endl;
  oPopDriver << "         oResults.open( \"" << fResult_xml << "\", ios_base::app );" << endl;
  oPopDriver << "         if( !oResults.good() )" << endl;
  oPopDriver << "         {" << endl;
  oPopDriver << "            fprintf( stderr, \"Failed to open a file, %s, for writing output!!!\", \"";
  oPopDriver << fResult_xml << "\" );" << endl;
  oPopDriver << "            ret = FILE_ACCESS_FAILURE;" << endl;
  oPopDriver << "            oResults << \"</spkreport>\" << endl;" << endl;
  oPopDriver << "            oResults.close();" << endl;
  oPopDriver << "            goto END;" << endl;
  oPopDriver << "         }" << endl;

  oPopDriver << "         {" << endl;
  oPopDriver << "            oResults << \"<?xml version=\\\"1.0\\\"?>\" << endl;" << endl;
  oPopDriver << "            oResults << \"<spkreport>\" << endl;" << endl;
  oPopDriver << "         }" << endl;
  oPopDriver << endl;

  oPopDriver << "         oResults << \"<error_list length=\\\"\" << errors.size() << \"\\\">\" << endl;" << endl;
  oPopDriver << "         if( !(haveCompleteData && isOptSuccess && isStatSuccess) )" << endl;
  oPopDriver << "         {" << endl;
  oPopDriver << "            // Print out ordinary-length error messages" << endl;
  oPopDriver << "            oResults << errors << endl;" << endl;
  oPopDriver << endl;
  oPopDriver << "            // Print out a long error message if exists." << endl;
  oPopDriver << "            char ch;" << endl;
  oPopDriver << "            ifstream iLongError( \"" << fSpkRuntimeLongError_tmp << "\" );" << endl;
  oPopDriver << "            while( iLongError.get(ch) )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               oResults << ch;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            iLongError.close();" << endl;
  oPopDriver << "         }" << endl;
  oPopDriver << "         oResults << \"</error_list>\" << endl;" << endl;
  oPopDriver << "         remove( \"" << fSpkRuntimeLongError_tmp << "\" );" << endl;
  oPopDriver << endl;

  // Print out <warning_list> even when it is empty.
  oPopDriver << "         WarningsManager::getAllWarnings( warningsOut );" << endl;
  oPopDriver << "         oResults << warningsOut;" << endl;
  oPopDriver << endl;

  oPopDriver << "         if( isSimRequested )" << endl;
  oPopDriver << "         {" << endl;
  oPopDriver << "            oResults << \"<simulation \";" << endl;
  oPopDriver << "            if( iSub == 0 )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               oResults << \"seed=\\\"\" << seed << \"\\\" \";" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            oResults << \"subproblem=\\\"\" << iSub+1 << \"\\\"/>\" << endl;" << endl;
  oPopDriver << "         }" << endl;
  oPopDriver << endl;

  oPopDriver << "         if( isOptRequested )" << endl;
  oPopDriver << "         {" << endl;
  oPopDriver << "            oResults << \"<pop_analysis_result>\" << endl;" << endl;
  oPopDriver << endl;

  oPopDriver << "            oResults << \"<pop_opt_result elapsedtime=\\\"\" << optTimeSec << \"\\\">\" << endl;" << endl;
  oPopDriver << "            oResults << \"<pop_obj_out>\" << endl;" << endl;
  oPopDriver << "            oResults << \"<value>\" << alpObjOut << \"</value>\" << endl;" << endl;
  oPopDriver << "            oResults << \"</pop_obj_out>\" << endl;" << endl;
  oPopDriver << endl;
  
  oPopDriver << "            ///////////////////////////////////////////////////////////////////" << endl;
  oPopDriver << "            //   NONMEM Specific" << endl;
  // theta in
  oPopDriver << "            oResults << \"<theta_in length=\\\"\" << NonmemPars::nTheta << \"\\\">\" << endl;" << endl;
  oPopDriver << "            for( int i=0; i<NonmemPars::nTheta; i++ )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               oResults << \"<value>\" << thetaIn[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            oResults << \"</theta_in>\" << endl;" << endl;
  // theta out
  oPopDriver << "            oResults << \"<theta_out length=\\\"\" << NonmemPars::nTheta << \"\\\">\" << endl;" << endl;
  oPopDriver << "            for( int i=0; i<NonmemPars::nTheta; i++ )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               oResults << \"<value>\" << thetaOut[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            oResults << \"</theta_out>\" << endl;" << endl;

  // sigam in
  oPopDriver << "            oResults << \"<sigma_in dimension=\" << \"\\\"\" << NonmemPars::sigmaDim << \"\\\"\";" << endl;
  oPopDriver << "            oResults << \" struct=\" << \"\\\"\";" << endl;
  oPopDriver << "            if( NonmemPars::sigmaStruct==PopPredModel::DIAGONAL )" << endl;
  oPopDriver << "               oResults << \"diagonal\";" << endl;
  oPopDriver << "            else" << endl;
  oPopDriver << "               oResults << \"block\";" << endl;
  oPopDriver << "            oResults << \"\\\"\" << \">\" << endl;" << endl;
  /*
  oPopDriver << "            for( int i=0; i<NonmemPars::sigmaOrder; i++ )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               oResults << \"<value>\" << sigmaIn[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "            }" << endl;
  */
  oPopDriver << "            if( NonmemPars::omegaStruct==PopPredModel::DIAGONAL )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               for( int i=0; i<NonmemPars::sigmaDim; i++ )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  oResults << \"<value>\" << sigmaIn[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            else // full" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               int n = NonmemPars::sigmaDim;" << endl;
  oPopDriver << "               int m = (n*(n+1))/2;" << endl;
  oPopDriver << "               valarray<double> full( n * n );" << endl;
  oPopDriver << "               valarray<double> row_minimal( m );" << endl;
  oPopDriver << endl;
  oPopDriver << "               // First make a full matrix out of the minimal representation" << endl;
  oPopDriver << "               for( int j=0, k=0; j<n; j++ )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  for( int i=0; i<n-j; i++, k++ ) // lower only" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     full[ (j*n)+(j+i) ] = sigmaIn[k];" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << endl;
  oPopDriver << "               // Copy the lower triangle to the upper and complete fullification" << endl;
  oPopDriver << "               symmetrize( full, n, full );" << endl;
  oPopDriver << endl;
  oPopDriver << "               // Read the lower triangle in the row-major order" << endl;
  oPopDriver << "               for( int i=0, k=0; i<n; i++ )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  for( int j=0; j<i+1; j++, k++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     row_minimal[k] = full[(i*n)+j];" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << endl;
  oPopDriver << "               for( int i=0; i<m; i++ )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  oResults << \"<value>\" << row_minimal[ i ];" << endl;
  oPopDriver << "                  oResults << \"</value>\" << endl;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            oResults << \"</sigma_in>\" << endl;" << endl;
  // sigma out
  oPopDriver << "            oResults << \"<sigma_out dimension=\" << \"\\\"\" << NonmemPars::sigmaDim << \"\\\"\";" << endl;
  oPopDriver << "            oResults << \" struct=\" << \"\\\"\";" << endl;
  oPopDriver << "            if( NonmemPars::sigmaStruct==PopPredModel::DIAGONAL )" << endl;
  oPopDriver << "               oResults << \"diagonal\";" << endl;
  oPopDriver << "            else" << endl;
  oPopDriver << "               oResults << \"block\";" << endl;
  oPopDriver << "            oResults << \"\\\"\" << \">\" << endl;" << endl;
  /*
  oPopDriver << "            for( int i=0; i<NonmemPars::sigmaOrder; i++ )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               oResults << \"<value>\" << sigmaOut[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            oResults << \"</sigma_out>\" << endl;" << endl;
  */
  oPopDriver << "            if( NonmemPars::sigmaStruct==PopPredModel::DIAGONAL )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               for( int i=0; i<NonmemPars::sigmaDim; i++ )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  oResults << \"<value>\" << sigmaOut[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            else // full" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               int n = NonmemPars::sigmaDim;" << endl;
  oPopDriver << "               int m = (n*(n+1))/2;" << endl;
  oPopDriver << "               valarray<double> full( n * n );" << endl;
  oPopDriver << "               valarray<double> row_minimal( m );" << endl;
  oPopDriver << endl;
  oPopDriver << "               // First make a full matrix out of the minimal representation" << endl;
  oPopDriver << "               for( int j=0, k=0; j<n; j++ )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  for( int i=0; i<n-j; i++, k++ ) // lower only" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     full[ (j*n)+(j+i) ] = sigmaOut[k];" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << endl;
  oPopDriver << "               // Copy the lower triangle to the upper and complete fullification" << endl;
  oPopDriver << "               symmetrize( full, n, full );" << endl;
  oPopDriver << endl;
  oPopDriver << "               // Read the lower triangle in the row-major order" << endl;
  oPopDriver << "               for( int i=0, k=0; i<n; i++ )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  for( int j=0; j<i+1; j++, k++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     row_minimal[k] = full[(i*n)+j];" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << endl;
  oPopDriver << "               for( int i=0; i<m; i++ )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  oResults << \"<value>\" << row_minimal[ i ];" << endl;
  oPopDriver << "                  oResults << \"</value>\" << endl;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            oResults << \"</sigma_out>\" << endl;" << endl;

  // omega in
  oPopDriver << "            oResults << \"<omega_in dimension=\" << \"\\\"\" << NonmemPars::omegaDim << \"\\\"\";" << endl;
  oPopDriver << "            oResults << \" struct=\" << \"\\\"\";" << endl;
  oPopDriver << "            if( NonmemPars::omegaStruct==PopPredModel::DIAGONAL )" << endl;
  oPopDriver << "               oResults << \"diagonal\";" << endl;
  oPopDriver << "            else" << endl;
  oPopDriver << "               oResults << \"block\";" << endl;
  oPopDriver << "            oResults << \"\\\"\" << \">\" << endl;" << endl;

  /*
  oPopDriver << "            for( int i=0; i<NonmemPars::omegaOrder; i++ )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               oResults << \"<value>\" << omegaIn[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "            }" << endl;
  */

  oPopDriver << "            if( NonmemPars::omegaStruct==PopPredModel::DIAGONAL )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               for( int i=0; i<NonmemPars::omegaDim; i++ )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  oResults << \"<value>\" << omegaIn[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            else // full" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               int n = NonmemPars::omegaDim;" << endl;
  oPopDriver << "               int m = (n*(n+1))/2;" << endl;
  oPopDriver << "               valarray<double> full( n * n );" << endl;
  oPopDriver << "               valarray<double> row_minimal( m );" << endl;
  oPopDriver << endl;
  oPopDriver << "               // First make a full matrix out of the minimal representation" << endl;
  oPopDriver << "               for( int j=0, k=0; j<n; j++ )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  for( int i=0; i<n-j; i++, k++ ) // lower only" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     full[ (j*n)+(j+i) ] = omegaIn[k];" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << endl;
  oPopDriver << "               // Copy the lower triangle to the upper and complete fullification" << endl;
  oPopDriver << "               symmetrize( full, n, full );" << endl;
  oPopDriver << endl;
  oPopDriver << "               for( int i=0, k=0; i<n; i++ )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  for( int j=0; j<i+1; j++, k++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     row_minimal[k] = full[i*n+j];" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << endl;
  oPopDriver << "               for( int i=0; i<m; i++ )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  oResults << \"<value>\" << row_minimal[ i ];" << endl;
  oPopDriver << "                  oResults << \"</value>\" << endl;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "            }" << endl;

  oPopDriver << "            oResults << \"</omega_in>\" << endl;" << endl;
  // omega out
  oPopDriver << "            oResults << \"<omega_out dimension=\" << \"\\\"\" << NonmemPars::omegaDim << \"\\\"\";" << endl;
  oPopDriver << "            oResults << \" struct=\" << \"\\\"\";" << endl;
  oPopDriver << "            if( NonmemPars::omegaStruct==PopPredModel::DIAGONAL )" << endl;
  oPopDriver << "               oResults << \"diagonal\";" << endl;
  oPopDriver << "            else" << endl;
  oPopDriver << "               oResults << \"block\";" << endl;
  oPopDriver << "            oResults << \"\\\"\" << \">\" << endl;" << endl;
  
  /*
  oPopDriver << "            for( int i=0; i<NonmemPars::omegaOrder; i++ )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               oResults << \"<value>\" << omegaOut[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "            }" << endl;
  */

  oPopDriver << "            if( NonmemPars::omegaStruct==PopPredModel::DIAGONAL )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               for( int i=0; i<NonmemPars::omegaDim; i++ )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  oResults << \"<value>\" << omegaOut[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            else // full" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               int n = NonmemPars::omegaDim;" << endl;
  oPopDriver << "               int m = (n*(n+1))/2;" << endl;
  oPopDriver << "               valarray<double> full( n * n );" << endl;
  oPopDriver << "               valarray<double> row_minimal( m );" << endl;
  oPopDriver << endl;
  oPopDriver << "               for( int j=0, k=0; j<n; j++ )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  for( int i=0; i<n-j; i++, k++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     full[j*n+(j+i)] = omegaOut[k];  " << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               symmetrize( full, n, full );" << endl;
  oPopDriver << endl;
  oPopDriver << "               for( int i=0, k=0; i<n; i++ )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  for( int j=0; j<i+1; j++, k++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     row_minimal[k] = full[i*n+j];" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               for( int i=0; i<m; i++ )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  oResults << \"<value>\" << row_minimal[ i ];" << endl;
  oPopDriver << "                  oResults << \"</value>\" << endl;" << endl;
  oPopDriver << "               }" << endl;

  oPopDriver << "            }" << endl;

  oPopDriver << "            oResults << \"</omega_out>\" << endl;" << endl;
  oPopDriver << "            //" << endl;

  oPopDriver << "            ///////////////////////////////////////////////////////////////////" << endl;
  oPopDriver << "            oResults << \"</pop_opt_result>\" << endl;" << endl;
  oPopDriver << endl;
  
  oPopDriver << "            if( isStatRequested )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               oResults << \"<pop_stat_result elapsedtime=\\\"\" << statTimeSec << \"\\\">\" << endl;" << endl;
  oPopDriver << "               if( isCovOut )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  oResults << \"<pop_covariance_out struct=\\\"block\\\" dimension=\\\"\" << nAlp << \"\\\">\" << endl;" << endl;
  oPopDriver << "                  for( int i=0; i<nAlp; i++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     for( int j=0; j<=i; j++ )" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        oResults << \"   <value>\" << stdParCovOut[i+j*nAlp] << \"</value>\" << endl;" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "                  oResults << \"</pop_covariance_out>\" << endl;" << endl;
  oPopDriver << "               }" << endl;
  
  oPopDriver << "               if( isInvCovOut )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  oResults << \"<pop_inverse_covariance_out struct=\\\"block\\\" dimension=\\\"\" << nAlp << \"\\\">\" << endl;" << endl;
  oPopDriver << "                  for( int i=0; i<nAlp; i++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     for( int j=0; j<=i; j++ )" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        oResults << \"   <value>\" << stdParInvCovOut[i+j*nAlp] << \"</value>\" << endl;" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "                  oResults << \"</pop_inverse_covariance_out>\" << endl;" << endl;
  oPopDriver << "               }" << endl;
  
  oPopDriver << "               if( isStdErrOut )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  oResults << \"<pop_stderror_out length=\\\"\" << nAlp << \"\\\">\" << endl;" << endl;
  oPopDriver << "                  for( int i=0; i<nAlp; i++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     oResults << \"   <value>\" << stdParSEOut[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "                  }" << endl;	      
  oPopDriver << "                  oResults << \"</pop_stderror_out>\" << endl;" << endl;
  oPopDriver << "               }" << endl;
  
  oPopDriver << "               if( isCorrelationOut )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  oResults << \"<pop_correlation_out struct=\\\"block\\\" dimension=\\\"\" << nAlp << \"\\\">\" << endl;" << endl;
  oPopDriver << "                  for( int i=0; i<nAlp; i++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     for( int j=0; j<=i; j++ )" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        oResults << \"   <value>\" << stdParCorrelationOut[i+j*nAlp] << \"</value>\" << endl;" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << "                  }" << endl;   
  oPopDriver << "                  oResults << \"</pop_correlation_out>\" << endl;" << endl;
  oPopDriver << "               }" << endl;
  
  oPopDriver << "               if( isCoefficientOut )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  oResults << \"<pop_coefficient_out length=\\\"\" << nAlp << \"\\\">\" << endl;" << endl;
  oPopDriver << "                  for( int i=0; i<nAlp; i++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     oResults << \"   <value>\" << stdParCoefficientOut[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "                  }" << endl;	      
  oPopDriver << "                  oResults << \"</pop_coefficient_out>\" << endl;" << endl;
  oPopDriver << "               }" << endl;
  
  oPopDriver << "               if( isConfidenceOut )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  oResults << \"<pop_confidence_out length=\\\"\" << nAlp*2 << \"\\\">\" << endl;" << endl;
  oPopDriver << "                  for( int i=0; i<nAlp*2; i++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     oResults << \"   <value>\" << stdParConfidenceOut[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "                  }" << endl;    
  oPopDriver << "                  oResults << \"</pop_confidence_out>\" << endl;" << endl;
  oPopDriver << "               }" << endl;
  
  oPopDriver << "               oResults << \"</pop_stat_result>\" << endl;" << endl;
  oPopDriver << endl;
  oPopDriver << "            }" << endl;
  
  oPopDriver << "            oResults << \"</pop_analysis_result>\" << endl;" << endl;
  oPopDriver << "         }" << endl;
  oPopDriver << endl;
  // Print out <presentation_data> if this is the last subproblem.
  oPopDriver << "         if( iSub == nRepeats-1 )" << endl;
  oPopDriver << "            oResults << set << endl;" << endl;
  oPopDriver << "         oResults << \"</spkreport>\" << endl;" << endl;
  oPopDriver << "         oResults.close();" << endl;
  oPopDriver << "      }" << endl;
  oPopDriver << endl;
  oPopDriver << "END:" << endl;
  oPopDriver << "      // The following statement is to trick g++ compiler, which" << endl;
  oPopDriver << "      // complains that a label must be followed by a statement." << endl;
  oPopDriver << "      int dummy = 0;" << endl;
  oPopDriver << "   }" << endl;
  oPopDriver << "   catch( const SpkException & e )" << endl;
  oPopDriver << "   {" << endl;
  oPopDriver << "      ofstream oResults;" << endl;
  oPopDriver << "      oResults.open( \"" << fResult_xml << "\", ios_base::app );" << endl;
  oPopDriver << "      if( !oResults.good() )" << endl;
  oPopDriver << "      {" << endl;
  oPopDriver << "         fprintf( stderr, \"Failed to open a file, %s, for writing output!!!\"," << endl;
  oPopDriver << "\"" << fResult_xml << "\" );" << endl;
  oPopDriver << "         ret = FILE_ACCESS_FAILURE;" << endl;
  oPopDriver << "         cout << \"exit code = \" << ret << endl;" << endl;
  oPopDriver << "         return ret;" << endl;
  oPopDriver << "      }" << endl;
  oPopDriver << "      oResults << \"<?xml version=\\\"1.0\\\"?>\" << endl;" << endl;
  oPopDriver << "      oResults << \"<spkreport>\" << endl;" << endl;
  oPopDriver << "      oResults << \"<error_list length=\\\"\" << e.size() << \"\\\">\" << endl;" << endl;
  oPopDriver << "      oResults << e << endl;" << endl;
  oPopDriver << "      oResults << \"</spkreport>\" << endl;" << endl;
  oPopDriver << "      oResults.close();" << endl;
  oPopDriver << "      ret = UNKNOWN_ERROR;" << endl;
  oPopDriver << "   }" << endl;
  oPopDriver << "   catch( ... )" << endl;
  oPopDriver << "   {" << endl;
  oPopDriver << "      ofstream oResults;" << endl;
  oPopDriver << "      oResults.open( \"" << fResult_xml << "\", ios_base::app );" << endl;
  oPopDriver << "      if( !oResults.good() )" << endl;
  oPopDriver << "      {" << endl;
  oPopDriver << "         fprintf( stderr, \"Failed to open a file, %s, for writing output!!!\"," << endl;
  oPopDriver << "\"" << fResult_xml << "\" );" << endl;
  oPopDriver << "         ret = FILE_ACCESS_FAILURE;" << endl;
  oPopDriver << "         cout << \"exit code = \" << ret << endl;" << endl;
  oPopDriver << "         return ret;" << endl;
  oPopDriver << "      }" << endl;
  oPopDriver << "      oResults << \"<?xml version=\\\"1.0\\\"?>\" << endl;" << endl;
  oPopDriver << "      oResults << \"<spkreport>\" << endl;" << endl;
  oPopDriver << "      oResults << \"<error_list length=\\\"\" << 2 << \"\\\">\" << endl;" << endl;
  oPopDriver << "      oResults << \"Unexpected exceptions are caught.\" << endl;" << endl;
  oPopDriver << "      oResults << \"</spkreport>\" << endl;" << endl;
  oPopDriver << "      oResults.close();" << endl;
  oPopDriver << "      ret = UNKNOWN_FAILURE;" << endl;
  oPopDriver << "   }" << endl;
  oPopDriver << endl;
  oPopDriver << "   cout << \"exit code: \" << ret << endl;" << endl;
  oPopDriver << "   return ret;" << endl;
  oPopDriver << "}" << endl;
  oPopDriver.close();
}
