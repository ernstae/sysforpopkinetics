#ifndef SPKCOMPILER_H
#define SPKCOMPILER_H

#include <xercesc/dom/DOM.hpp>
#include <xercesc/parsers/XercesDOMParser.hpp>

#include "client.h"
#include "SymbolTable.h"
#include "ExpTreeGenerator.h"
#include "SpkCompilerUtil.h"
#include <set>

/**
 * Abstract class that provides interfaces for parsing a SpkInML document and build a DOM
 * tree, interpreting the semantics and emit C++ source code files for specific
 * clients.
 *
 * A SpkInML document contains definitions of physiological model, statisitical models,
 * measurement data, and values for various parameters necessary for SPK to initiate
 * either population or individual parameter analysis.
 * These information are scattered across the document and it is the SPK Compiler's
 * responsibility to assemble them and produce C++ source code files for
 * a target architecture.
 *
 * Here're features this object shall provide:
 * - parse a SpkML document
 * - build a DOM tree
 * - generate C++ source code files [driver, model]
 * - compile & link the generated C++ files and build a SPK driver for a target architecture.
 *
 * The following sequence of events must at minimum occur (caller is responsible to make calls in the order):
 * - construct a complete SpkCompiler object
 * - call parse() to parse the document and build a DOM tree
 * - call interpret() to interpret the semantics of the DOM tree
 * - call emit() to emit C++ source code files
 * - call compile() to compile the generated C++ source code
 */
class SpkCompiler{
 public:

 /**
  * Initialize the state of SpkCompiler.
  *
  * It also attempts to initialize DOMPlatformUtils. If failure occurs during the attempt,
  * an exception of XMLException type or unknown (std::bad_exception) will be thrown.
  *
  * @param c specifies the kind of client.
  * @param inputSpkML is the name of the SpkInML document file.
  */ 
  SpkCompiler( client::type c, const std::string inputSpkML ) throw( xercesc::XMLException, std::bad_exception );

  /**
   * Release resourcs allocated for this SpkCompiler.
   */
  ~SpkCompiler() throw();

 /**
  * Parse the SpkInML document and build a DOM tree.
  *
  * Upon the successful completion of this method,
  * the pointer, returned by getDOMDoc(), shall point to a legal DOMDocument tree.
  *
  * When an error is encountered during the parsing phase, an exception of 
  * XMLException, DOMException or unknown type will be thrown.
  */
  void parse() throw( xercesc::XMLException, xercesc::DOMException, std::bad_exception );

  /**
   * Interpret the DOM tree and gather information into a SymbolTable object.
   *
   * Upon the successful completion of this method, the SymbolTable object
   * returned by getTable() shall contain symbols found in the input
   * SpkInML document and their associated values if appricable, sufficient
   * enough so that emit() can generate legal C++ source code files
   * for a fitPopulation() driver and definitions of SpkModel subclass.
   *
   * To be specific, the placeholders in FitParameters data structure
   * must be filled with appropriate values/definitions:
   *
   * If any of the above entities have aliases, the mapping must be entered into
   * the SymbolTable::spkSymbols::aliases map.
   */
  virtual void interpret() = 0;

 /**
  * Emit C++ source code files, corresponding to a driver and model definitions.
  *
  * Upon the successful completion of this method,
  * the set of filenames, returned by getFileNames(), shall contain
  * names of all C++ files generated.
  *
  * This method has a default implementation that is supposed to be able to 
  * deal with arbitrary clients' specifications.  However, 
  * for known clients such as NONMEM, there are specific ways/syntax used
  * to describe mapping between the (SPK) population parameters
  * and the (NONMEM) components such as THETA, OMEGA and SIGMA:
  * a subset of the population paremters are described as THETA,
  * another subset as OMEGA and so on.
  * For this reason, the user may desire to re-implement the method for efficiency.
  *
  * @return a list of file names corresponding to the driver and model definitions.
  *
  * @todo Provide a default implementation.
  */
  virtual const std::set<std::string> emit() = 0;

 /**
  * Compile the generated C++ source code for a target architecture.
  *
  * @note The compiler of choice
  * must be executable from the directory in which the driver of this module resides.
  *
  * Upon the successful completion of this method,
  * the set object, returned by getFileNames(), shall contain names of
  * all object files being generated.
  *
  * @return a list of file names corresponding to the generated object files. 
  * This list is empty when compilation fails.
  */
  const std::set<std::string> compile() const;

 /**
  * Link the object files generated by compile() and builds an executable driver
  * for a target architecture.
  *
  * Upon the successfull completion of this method,
  * the string object, returned by getDriverFileName(), shall hold a filename that
  * corresponds to the generated driver.
  *
  * @note The compiler of choice
  * must be executable from the directory in which the driver of this module resides.
  *
  * @return the name of executable file.  NULL when fails.
  */
  const std::string link() const;

 /**
  * Print out the SpkInML parsed tree from top without filtering to the strandard output.
  */
  void printTree( ) const throw( xercesc::XMLException, std::bad_exception );

 /**
  * Print out a substree of SpkInML document from the point specified by root on
  * without filtering to the strandard output (by default) or a file.
  *
  * @param root the root of the subtree to be printed out
  * @param gOutputFile the name of file to which the output is redirected to.
  */
  void printTree( xercesc::DOMNode * root, const char * gOutputFile=0 ) 
    const throw( xercesc::XMLException, std::bad_exception );

  /**
   * Get the type of client.
   *
   * @return an enum of type client::type indicating the kind of client for which this document
   * represents.
   */
  enum client::type getClient() const;

  /**
   * Get the names of C++ source code files begin generated.
   *
   * @return a list of generated C++ source code files.
   */
  virtual const std::set<std::string> getFileNames() const = 0;

  /**
   * Get the name of generated driver file.
   *
   * @return the name of generated driver file.
   */
  virtual const std::string getDriverFileName() const = 0;

  /**
   * Get a pointer to the symbol table.
   *
   * @return a pointer to the SymbolTable.
   *
   * @note This method should be conceptually private but
   * for debugging purpose, it's currently accessible from external users.
   */
  SymbolTable * getTable() const;

 protected:
  /**
   * Get a pointer to the DOMDocument object generated from the input SpkInML document.
   *
   * @return a pointer to a DOMDocument that represents the SpkInML document.
   */
  xercesc::DOMDocument * getDOMDoc() const;

  /**
   * Get a pointer to a DOMParser object.
   *
   * @return a pointer to a DOMParser.
   */
  xercesc::XercesDOMParser * getDOMParser() const;

  /**
   * Get a pointer to a DOMTreeWalker object.
   *
   * @return a pointer to a DOMTreeWalker/
   */
  xercesc::DOMTreeWalker * getDOMTreeWalker() const;

  /**
   * Determine whether the XML/DOM document, tree and walker are ready to use.
   *
   * @return true if the initialization of XMLPlatformUtil has been successfully completed.
   */
  bool isInitialized() const;

  /**
   * Determine whether parsing of the SpkInML document has been successfully completed.
   *
   * @return true if parsing the SpkInML has been successfully completed.
   */
  bool isParsed() const;

 protected:
  SpkCompiler();
  SpkCompiler( const SpkCompiler& );
  SpkCompiler& operator=( const SpkCompiler& );

 private:

 /**
  * DOM representation of the SpkInML document.
  */
  xercesc::DOMDocument * doc;

 /**
  * DOM parser
  */
  mutable xercesc::XercesDOMParser * parser;

 /**
  * Symbol table for all symbols discovered in the SpkInML document.
  *
  * This structure is composed of two parts: one is to keep track of user-defined 
  * symbols and another for keywords.
  * The latter part is a structure bundling all these values required to fun fitPopulation().
  * It also maps the symbols used within SPK to describe these values to the symbols
  * used within the client space.
  * The other symbols, user-defined symbols, are maintained in a different table (structure),
  * SymbolTable.
  */
  SymbolTable *table;

  /**
  * Flag indicating the status of XMLPlatformUtils initialization process.
  * If initialization has been completed successfully, this flag is set to true.
  * false indicates either the attempt has not yet been made or has been failed.
  */
  bool initialized;

 /**
  * Flag indicating the status of parsing process.
  * If parsing has been completed successfully, this flag is set to true.
  * false indicates either the attempt has not yet been made or has been failed.
  */
  bool parsed;

 /**
  * Readonly character array keeping the name of input SpkInML document file.
  */
  const std::string input;

 /**
  * Enumulator indicating the kind of client (see details in client.h).
  */
  enum client::type who;

  /**
   * Release rsources allocated within the object.
   */
  void cleanup();
};


#endif
