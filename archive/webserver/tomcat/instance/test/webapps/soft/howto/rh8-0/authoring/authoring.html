<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML
><HEAD
><TITLE
>Authoring RFPK Software Documents</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.76b+
"></HEAD
><BODY
CLASS="article"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="ARTICLE"
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="title"
><A
NAME="AEN1"
></A
>Authoring RFPK Software Documents</H1
><DIV
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="80%"
CELLSPACING="10"
CELLPADDING="0"
ALIGN="CENTER"
><TR
><TD
VALIGN="TOP"
><B
>Abstract</B
></TD
></TR
><TR
><TD
VALIGN="TOP"
><P
>&#13;	Docbook XML is the preferred format for RFPK Software
	documents, for reasons of efficiency, standardization,
	maintainability and ease of publishing.  This tutorial
	explains how to get set up to use Docbook, how to 
	to create new documents, how to edit documents
	with Emacs, how to make diagrams with Dia, how to check
	spelling, how to publish 
	completed documents to the Software Team web page, how to
	archive document versions in CVS, and how to interface with
	Microsoft Word.
      </P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="revhistory"
><TABLE
WIDTH="100%"
BORDER="0"
><TR
><TH
ALIGN="LEFT"
VALIGN="TOP"
COLSPAN="3"
><B
>Revision History</B
></TH
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.0</TD
><TD
ALIGN="LEFT"
>May 16, 2003</TD
><TD
ALIGN="LEFT"
>Revised by: afw</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Initial version.</TD
></TR
></TABLE
></DIV
><HR
WIDTH="75%"
ALIGN="CENTER"
COLOR="#000000"
SIZE="1"></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#AEN12"
>Introduction</A
></DT
><DT
><A
HREF="#AEN51"
>Configuring Your Workstation</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN54"
>Prerequisites</A
></DT
><DT
><A
HREF="#AEN66"
>Emacs Configuration</A
></DT
><DT
><A
HREF="#AEN75"
>XHMTL Configuration</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN80"
>Starting a New Document</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN84"
>The CVS Workspace</A
></DT
><DT
><A
HREF="#AEN113"
>Creating an Empty Document</A
></DT
><DT
><A
HREF="#AEN126"
>First Modifications</A
></DT
><DT
><A
HREF="#AEN145"
>Viewing Your First Steps</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN167"
>Building Your Document</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN170"
>Sources of Information about Docbook</A
></DT
><DT
><A
HREF="#AEN175"
>Using Emacs</A
></DT
><DT
><A
HREF="#AEN180"
>Checking Spelling, with Emacs and Ispell</A
></DT
><DT
><A
HREF="#AEN217"
>XML General Entities</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN274"
>Adding Diagrams to Your Document</A
></DT
><DT
><A
HREF="#AEN320"
>Publishing Your Document</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN328"
>Installing to the Web Server</A
></DT
><DT
><A
HREF="#AEN339"
>Adding Links to the Web Page</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN344"
>Adding Your Document to the CVS Repository</A
></DT
><DT
><A
HREF="#AEN354"
>Compatibility with Microsoft Office</A
></DT
></DL
></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
NAME="AEN12"
></A
>Introduction</H2
><P
>&#13;      RFPK software documents fall into two categories:
      <P
></P
><UL
><LI
><P
>&#13;	    <I
CLASS="emphasis"
>Documents generated by development tools.</I
>
	    Prime examples are the documents created by 
	    Doxygen and JavaDoc.
	  </P
></LI
><LI
><P
>&#13;	    <I
CLASS="emphasis"
>Documents authored by Software Team members.</I
>
	    Such documents may include material prepared with the help of
	    tools, such as Dia, the diagramming tool,
	    but they are not generated automatically.
	  </P
></LI
></UL
>
      This <I
CLASS="emphasis"
>howto</I
> is concerned exclusively with the
      latter case.
    </P
><P
>&#13;      As a rule, all authored software documents should be written in one
      or another of the following XML markup languages:
      <P
></P
><UL
><LI
><P
>&#13;	    Docbook
	  </P
></LI
><LI
><P
>&#13;	    Xhtml
	  </P
></LI
></UL
>
    </P
><P
>&#13;      Docbook is designed for technical
      articles and books.  The language contains a
      large collection of elements useful in technical documents.
      Elements are defined in a Document Type Definition (DTD), which 
      itself is an XML document.  The DTD makes it possible to validate
      a document, insuring that only valid elements are used and that the
      correct hierarchy of elements is observed.  From a valid Docbook
      document, output in a number of formats can be automatically generated,
      include <I
CLASS="emphasis"
>html</I
>, <I
CLASS="emphasis"
>pdf</I
>
      and <I
CLASS="emphasis"
>rtf</I
>.
    </P
><P
>&#13;      Xhtml is used to create Web documents that are neither books
      nor articles. Xhtml is very similar to Html,
      for which it is a replacement.  Over the years, the definition of
      Html has become murky, as various browser vendors have added their
      own proprietary features.  Xhtml, by contrast, is defined by a 
      DTD.  Unlike a Docbook document,
      an Xhtml document does not have to be processed before it
      is placed on the web.
    </P
><P
>&#13;      The existence of DTDs for both Docbook and Xhtml make it possible to
      configure Emacs as a powerful language-specific
      XML editor.  A Docbook or Xhtml document contains in its preamble
      a reference to its DTD file.  When Emacs opens a document, it
      first reads and parses the DTD.  From that point onward, Emacs
      knows which elements are valid at each point in the document. It can
      provide you with a list of valid elements, automatically insert
      markup tags, nicely indent elements and content, and perform
      many other XML-specific and DTD-specific services.
    </P
><P
>&#13;      Authored RFPK software documents fall into several categories:
      <P
></P
><UL
><LI
><P
>&#13;	    <I
CLASS="emphasis"
>Howto.</I
> 
	    The current document is a typical
	    example. A howto is a tutorial which
	    explains some practical method or process.  
	  </P
></LI
><LI
><P
>&#13;	    <I
CLASS="emphasis"
>White Paper.</I
>
	    A white paper is typically more general and high-level than
	    a howto.  A white paper can explain the theory behind a
	    process or group of processes.  It can present the rationale
	    for an important decision.  It can suggest or define a course
	    of action.
	  </P
></LI
><LI
><P
>&#13;	    <I
CLASS="emphasis"
>Decision Research.</I
>
	    Developing software involves making many decisions where
	    one alternative is chosen from among several possibilities.
	    A decision research document summarizes supporting evidence
	    for a development decision, including prototyping, benchmarking,
	    and summarizing best practices or opinions of respected
	    experts.
	  </P
></LI
></UL
>
    </P
><P
>&#13;      To improve the efficiency of creating and publishing authored 
      software documents and to foster standardization, a set of 
      processes have been developed for each of the document types
      listed above.  Specific details of these processes will be
      described in this howto.
    </P
><P
>&#13;      RPFK software documents are primarily published to the 
      Software Team web page.  The page of links to these documents
      is written in Xhtml.  Each time a document is published
      for the first time, it is necessary to edit the Xhtml
      file.  The process for doing this is also described, below.
    </P
><P
>&#13;      Sometimes, the whole or parts of an RFPK software document
      must be included in a Microsoft Office document. Grant
      proposals are a good example.  This howto also describes
      the process for making a software document accessible
      to Microsoft Office.
    </P
><P
>&#13;      All RFPK software documents are under CVS version control.
      The process for maintaining this control is also described
      in this document.
    </P
><P
>&#13;      In the sections that follow, we will demonstrate the process of
      authoring a document, from initial creation, to publishing on
      the Software Team web site.  A hypothetical example is used,
      which is a howto about the way the Software Team uses the
      Perl language for processing XML.  Our example could have been
      a white paper or a decision research paper just as well.  The 
      process would be the same in each case.
    </P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="AEN51"
></A
>Configuring Your Workstation</H2
><P
>&#13;      Your workstation will need a bit of configuration in order
      to use the tools and framework described in this paper. 
    </P
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="AEN54"
></A
>Prerequisites</H3
><P
>&#13;	It is assumed that the operating system for your workstation
	is Redhat Linux, version 8.0.  You must have the following
	packages installed to process Docbook texts:
	<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>&#13;	    docbook-style-dsssl
	  </TD
></TR
><TR
><TD
>&#13;	    docbook-dtds
	  </TD
></TR
><TR
><TD
>&#13;	    docbook-utils-pdf
	  </TD
></TR
><TR
><TD
>&#13;	    docbook-style-xsl
	  </TD
></TR
><TR
><TD
>&#13;	    docbook-utils
	  </TD
></TR
></TBODY
></TABLE
><P
></P
>
      </P
><P
>&#13;	These packages should already be installed in your workstation.
	To determine whether or not they are, use the command
	<B
CLASS="command"
>rpm -qa | grep -i docbook</B
>, in order to get
	a list of all installed packages that have docbook in their
	names.  If any are missing, you should download them from the
	<A
HREF="http://www.redhat.com/software/rhn/"
TARGET="_top"
>&#13;	  RedHat Network
	</A
> 
	web site. 
      </P
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="AEN66"
></A
>Emacs Configuration</H3
><P
>&#13;	When Emacs starts up, it reads configuration information from
	a file, named <TT
CLASS="filename"
>.emacs</TT
> or 
	<TT
CLASS="filename"
>_emacs</TT
>, that it finds in the user's
	home directory.  If you have not already done so, you can
	download the configuration information that you need from 
	<SPAN
CLASS="systemitem"
>whitechuck</SPAN
>, and concatenate it to your current 
	<TT
CLASS="filename"
>.emacs</TT
> file.
      </P
><P
>&#13;	As an ordinary user:
	<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="screen"
>&#13;cd
scp whitechuck:/opt/download/dot.emacs .
cat dot.emacs &#62;&#62; .emacs
rm dot.emacs
	</PRE
></TD
></TR
></TABLE
>
      </P
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="AEN75"
></A
>XHMTL Configuration</H3
><P
>&#13;	In order to use Emacs to edit Xhtml files, you will need to 
	install a package and one additional file.
      </P
><P
>&#13;	Starting as an ordinary user and then switching to the
	super user:
	<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="screen"
>&#13;cd
scp 'whitechuck:/opt/download/xhtml1*.rpm' .
scp whitechuck:/opt/download/xhtml1.soc .
su 
rpm -Uhv xhtml1*.rpm
rm xhtml1*.rpm
mv xhtml1.soc /usr/share/sgml/xhtml1/xhtml1-20020801/DTD
	</PRE
></TD
></TR
></TABLE
>
      </P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="AEN80"
></A
>Starting a New Document</H2
><P
>&#13;      All work on RFPK software documents should be performed in 
      the CVS workspace on your workstation.  If you do not have a CVS
      workspace, consult the RFPK
      <A
HREF="http://whitechuck.rfpk.washington.edu/soft/howto/cvs/cvs.html"
TARGET="_top"
>&#13;	CVS Howto
      </A
>
      for details.
    </P
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="AEN84"
></A
>The CVS Workspace</H3
><P
>&#13;	Within your CVS workspace, the directory hierarchy which we are 
	interested in looks like this:
	<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="screen"
>&#13;r2
    doc
	  CVS
	  decision
	  research
	  howto
	  stylesheet
	  whitepaper
	  web
	</PRE
></TD
></TR
></TABLE
>
      </P
><P
>&#13;	Various directories are dedicated to the following:
	<DIV
CLASS="glosslist"
><DL
><DT
><B
>doc/decision/research</B
></DT
><DD
><P
>&#13;		Decision research papers.
	      </P
></DD
><DT
><B
>doc/howto</B
></DT
><DD
><P
>&#13;		Howto tutorials.
	      </P
></DD
><DT
><B
>doc/stylesheet</B
></DT
><DD
><P
>&#13;		The locally modifiable stylesheet. Changes to the
		<TT
CLASS="filename"
>local.dsl</TT
> file will affect the appearance
		of all RFPK software documents.
	      </P
><P
>&#13;		Do not modify <TT
CLASS="filename"
>local.dsl</TT
> 
	      </P
></DD
><DT
><B
>doc/whitepaper</B
></DT
><DD
><P
>&#13;		White papers.
	      </P
></DD
><DT
><B
>web</B
></DT
><DD
><P
>&#13;		Contains files for the Software Team web page.
	      </P
></DD
></DL
></DIV
>
      </P
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="AEN113"
></A
>Creating an Empty Document</H3
><P
>&#13;	First you need to come up with a title for your new document,
	and then distill that into an identifier that expresses the
	subject of the paper.  In our example, the title will be
	<I
CLASS="emphasis"
>Perl Processing of XML</I
> and the subject
	will be <I
CLASS="emphasis"
>perl-xml</I
>.
      </P
><P
>&#13;	Go to the directory designated for the type of document that you
	are about to produce and execute the 
	<B
CLASS="command"
>newdoc.sh</B
> shell script to create the
	directory and directory contents that you need:
	<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="screen"
>&#13;cd howto
sh newdoc.sh perl-xml
cd perl-xml	  
	</PRE
></TD
></TR
></TABLE
>
      </P
><P
>&#13;	You will find that the new directory contains two files:
	<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="screen"
>&#13;doc
    howto
	  perl-xml
	      perl-xml.xml
	      Makefile
	</PRE
></TD
></TR
></TABLE
>
      </P
><P
>&#13;	The file <TT
CLASS="filename"
>perl-xml.xml</TT
> is the skeleton of
	your new document.  It looks like this:
	<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="screen"
>&#13;&#60;?xml version="1.0"?&#62;
&#60;!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
 "/usr/share/sgml/docbook/xml-dtd-4.2-1.0-14/docbookx.dtd" [
  &#60;!ENTITY uw "University of Washington"&#62;
  &#60;!ENTITY dept "Department of Bioengineering"&#62;
]&#62;
&#60;article&#62;&#60;title&#62;perl-xml&#60;/title&#62;
 &#60;articleinfo&#62;
    &#60;revhistory&#62;
      &#60;revision&#62;
	&#60;revnumber&#62;1.0&#60;/revnumber&#62;
	&#60;date&#62;July 4, 1776&#60;/date&#62;
	&#60;authorinitials&#62;???&#60;/authorinitials&#62;
	&#60;revremark&#62;Initial version.&#60;/revremark&#62;
      &#60;/revision&#62;
    &#60;/revhistory&#62;
  &#60;abstract&#62;
      &#60;para&#62;
      &#60;/para&#62;
  &#60;/abstract&#62;
 &#60;/articleinfo&#62;
  &#60;sect1&#62;
    &#60;title&#62;&#60;/title&#62;
    &#60;para&#62;
    &#60;/para&#62;
  &#60;/sect1&#62;
&#60;/article&#62;
	</PRE
></TD
></TR
></TABLE
>
      </P
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="AEN126"
></A
>First Modifications</H3
><P
>&#13;	When you open this file with Emacs, a status message should appear
	in the mini-buffer at the bottom of the frame, telling you that 
	Emacs is parsing the DTD.  You should then see the following menus added
	to the menu bar at the top of the frame:
	<B
CLASS="guimenu"
>SGML</B
>,
	<B
CLASS="guimenu"
>Modify</B
>,
	<B
CLASS="guimenu"
>Move</B
>,
	<B
CLASS="guimenu"
>Markup</B
>,
	<B
CLASS="guimenu"
>View</B
> and
	<B
CLASS="guimenu"
>DTD</B
>.
      </P
><P
>	
	The first thing you will want to do is edit a few lines which
	have been given default values in the starting template.
      </P
><P
>&#13;	Replace
	<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="screen"
>&#13;&#60;article&#62;&#60;title&#62;perl-xml&#60;/title&#62;
	</PRE
></TD
></TR
></TABLE
>
	with the full title
	<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="screen"
>&#13;&#60;article&#62;&#60;title&#62;Perl Processing of XML&#60;/title&#62;
	</PRE
></TD
></TR
></TABLE
>
      </P
><P
>&#13;	Modify
	<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="screen"
>&#13;&#60;date&#62;July 4, 1776&#60;/date&#62;
	</PRE
></TD
></TR
></TABLE
>
	to show your expected date of publication.
      </P
><P
>&#13;	Modify
	<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="screen"
>&#13;&#60;authorinitials&#62;???&#60;/authorinitials&#62;
	</PRE
></TD
></TR
></TABLE
>
	to show your own initials.
      </P
><P
>&#13;	Provide the section-one title
	<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="screen"
>&#13;&#60;title&#62;&#60;/title&#62;
	</PRE
></TD
></TR
></TABLE
>
	with a non-empty title.
      </P
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="AEN145"
></A
>Viewing Your First Steps</H3
><P
>&#13;	Now you should verify that everything is configured properly,
	and that your initial changes were successful.
	<P
></P
><OL
TYPE="1"
><LI
><P
>&#13;	      Process the file
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="screen"
>&#13;<B
CLASS="guimenu"
>Tools</B
> =&#62; <B
CLASS="guimenuitem"
>Compile</B
>
	      </PRE
></TD
></TR
></TABLE
>
	      You will see in the mini-buffer the message
	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="screen"
>&#13;Compile command: make -k
	      </PRE
></TD
></TR
></TABLE
>
	      Press the <B
CLASS="keycap"
>Enter</B
> key and the Docbook infrastructure
	      will produce three output files:
	      <TT
CLASS="filename"
>perl-xml.html</TT
>,
	      <TT
CLASS="filename"
>perl-xml.pdf</TT
>,
	      <TT
CLASS="filename"
>perl-xml.rtf</TT
>.
	    </P
></LI
><LI
><P
>&#13;	      Open the newly created <TT
CLASS="filename"
>perl-xml.html</TT
> file
	      with your browser.  (You will need to enter the absolute path name
	      in the URL window at the top of your browser window.)
	    </P
><P
>&#13;	      While writing in Docbook, it is very convenient to leave the
	      browser pointed to your document.  You should reprocess your
	      file often, to make sure that you have not made changes that
	      violate the Docbook structure.  If you alter the command in
	      the minibuffer to be <B
CLASS="command"
>make html</B
>, you will
	      only produce a .html file, which will save time.  Then you
	      can click the <B
CLASS="guibutton"
>Reload</B
> button in the
	      browser to view your modified output.
	    </P
></LI
><LI
><P
>&#13;	      You can also view your .pdf output with Acroread and your
	      .rtf output with Open Office. It will slow down your 
	      document development if you check all formats every time
	      you make a few additions.  Checking .html with a browser
	      is the most efficient way to work.
	    </P
></LI
></OL
>
      </P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="AEN167"
></A
>Building Your Document</H2
><P
>&#13;      Now that you have the skeleton of a document, the real fun begins. The
      best way to proceed is iteratively.  Add a few paragraphs or other 
      elements to your paper, process it, and view it with the browser.  Repeat,
      until done.
    </P
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="AEN170"
></A
>Sources of Information about Docbook</H3
><P
>&#13;	A Docbook article or book is constructed as a hierarchy of
	elements.  The best source of information about these elements
	is the book
	<A
HREF="http://whitechuck.rfpk.washington.edu/soft/books/html/tdg/en/html/docbook.html"
TARGET="_top"
>&#13;	  Docbook the Definitive Guide
	</A
>, by Norman Walsh and Leonard Muellner. 
      </P
><P
>&#13;	Docbook contains a lot of elements.  It is unlikely that you will need more than
	a few dozen of these.  A good way to learn what you actually do need is to look
	at the XML source of existing RFPK software documents. 
	You will find copies of all of them in your CVS workspace.
      </P
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="AEN175"
></A
>Using Emacs</H3
><P
>&#13;	You will find Emacs to be a very powerful tool for building 
	XML documents.
	Use the 
	<B
CLASS="guimenu"
>Markup</B
> menu to insert elements.  Emacs will only
	let you insert elements that are valid at the point that you are
	editing. That way your document will stay valid as it grows. Having
	Emacs generate tag pairs really speeds things up.  If you already have
	a good idea of what element you want, you can use the (C-c C-e) 
	keystroke sequence for even greater efficiency.  Just type a few 
	leading characters, hit <B
CLASS="keycap"
>Enter</B
>, and Emacs will 
	automatically complete the tag name and insert the tag pair.
      </P
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="AEN180"
></A
>Checking Spelling, with Emacs and Ispell</H3
><P
>&#13;	Emacs is interfaced to the Unix Ispell utility to
	provide spell checking for your document.  The following
	menu sequence will initiate spell checking of your entire
	document.
	<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="screen"
>&#13;	  <B
CLASS="guimenu"
>Tools</B
> =&#62; <B
CLASS="guimenu"
>Spell Checking</B
> =&#62; <B
CLASS="guimenuitem"
>Spell Check Buffer</B
>
	</PRE
></TD
></TR
></TABLE
>
      </P
><P
>&#13;	Emacs will high-light the first word-like token in your text
	that Ispell is not sure of.  A window presenting choices will
	open at the top of the screen, and the mini-buffer at the 
	bottom of the screen will contain help information.
      </P
><P
>&#13;	Often the high-lighted token is not mis-spelled.  It is simply not 
	in Ispell's dictionary.  Here are some of your choices, when this
	occurs:
	<DIV
CLASS="glosslist"
><DL
><DT
><B
>Digit</B
></DT
><DD
><P
>&#13;		Enter the digit, digits, or other symbol which corresponds to 
		one of the choices at the top of the frame.  The corresponding
		word will replace the high-lighted word.
	      </P
></DD
><DT
><B
><B
CLASS="keycap"
>Space</B
></B
></DT
><DD
><P
>&#13;		Accept the word this time.  Each time the word appears
		in the remainder of your paper, it will be high-lighted
		again.
	      </P
></DD
><DT
><B
>a</B
></DT
><DD
><P
>&#13;		Accept the word for this entire editing session.
	      </P
></DD
><DT
><B
>A</B
></DT
><DD
><P
>&#13;		Accept this word, and add it to a special dictionary
		concatenated to the end of the document. It 
		will be considered correct for the life of the
		document.
	      </P
></DD
><DT
><B
>i</B
></DT
><DD
><P
>&#13;		Accept this word, and add it to your personal 
		dictionary.
	      </P
></DD
><DT
><B
>x</B
></DT
><DD
><P
>&#13;		Exit from the spell checker.  Return to the 
		originally editing point in your document.
	      </P
></DD
></DL
></DIV
>
      </P
><P
>	
	There are a lot of additional commands.  Check them out in 
	the <B
CLASS="guimenu"
>Spell Checking</B
> menu. 
      </P
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="AEN217"
></A
>XML General Entities</H3
><P
>&#13;	General entities are both a necessary and a useful part of XML.  
	They can be thought of as a kind of simple replacement macro.
	You place the markup for the entity in your document and
	it is replaced with other text and markup.  
      </P
><DIV
CLASS="sect3"
><HR><H4
CLASS="sect3"
><A
NAME="AEN220"
></A
>Predefined Entities</H4
><P
>&#13;	  The following five symbols have special meaning in XML, because
	  they are part of the markup syntax:
	  <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>&#38;</TD
><TD
>'</TD
><TD
>&#62;</TD
><TD
>&#60;</TD
><TD
>"</TD
></TR
></TBODY
></TABLE
><P
></P
>
	  There are five predefined entities, corresponding to these symbols.
	  When you place the markup for one of these symbols in your 
	  document, you avoid confusing the XML parser, and the symbol
	  itself appears in your output.
	  <DIV
CLASS="glosslist"
><DL
><DT
><B
>&#38;amp;</B
></DT
><DD
><P
>&#13;		  Ampersand (&#38;)
		</P
></DD
><DT
><B
>&#38;apos;</B
></DT
><DD
><P
>&#13;		  Single quotation mark; apostrophe (')
		</P
></DD
><DT
><B
>&#38;gt;</B
></DT
><DD
><P
>&#13;		  Greater-than sign (&#62;)
		</P
></DD
><DT
><B
>&#38;lt;</B
></DT
><DD
><P
>&#13;		  Less-than sign (&#38;)
		</P
></DD
><DT
><B
>&#38;quot;</B
></DT
><DD
><P
>&#13;		  Double quotation mark (")
		</P
></DD
></DL
></DIV
>
	</P
><P
>&#13;	  You must always use &#38;lt; and the &#38;amp;.  The others are optional
	  in most contexts.  Just keep in mind, that if a parser complains
	  about one of these symbols, you will have to replace it with
	  its entity markup.
	</P
></DIV
><DIV
CLASS="sect3"
><HR><H4
CLASS="sect3"
><A
NAME="AEN251"
></A
>User Defined Entities</H4
><P
>&#13;	  You can define your own entities.  Consider the preamble to 
	  the template that you used to start your document:
	  <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="screen"
>&#13;&#60;?xml version="1.0"?&#62;
&#60;!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
 "/usr/share/sgml/docbook/xml-dtd-4.2-1.0-14/docbookx.dtd" [
  &#60;!ENTITY uw "University of Washington"&#62;
  &#60;!ENTITY dept "Department of Bioengineering"&#62;
]&#62;
	  </PRE
></TD
></TR
></TABLE
>
	</P
><P
>&#13;	  The space between the two square brackets, [ and ], 
	  is reserved for user additions to the DTD.  Inside of
	  those brackets, two general entities are defined:
	  <I
CLASS="emphasis"
>uw</I
> and <I
CLASS="emphasis"
>dept</I
>.
	  Here is an example of markup using them,
	  <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="screen"
>&#13;RFPK, a project in the &#38;dept; of the &#38;uw;.
	  </PRE
></TD
></TR
></TABLE
>
	  and here is the output generated:
	  <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="screen"
>&#13;RFPK, a project in the Department of Bioengineering of the University of Washington.
	  </PRE
></TD
></TR
></TABLE
>
	</P
><P
>&#13;	  Using these two entities could save time and effort, if 
	  the two phrases appeared often within your document. 
	  User defined entities can be more than a convenience,
	  however. Consider for example, the server named
	  <SPAN
CLASS="systemitem"
>whitechuck</SPAN
>.  The name comes from that of a river
	  in Western Washington.  If you simply place that name in your
	  documents and they are published to the Web, your site
	  might draw traffic from people interested in hiking
	  or white water kayaking.  This was not your intention,
	  and it is a waste of both resources and other other
	  people's time.  It would be better to 
	  <I
CLASS="emphasis"
>semantically mark</I
> the name
	  <SPAN
CLASS="systemitem"
>whitechuck</SPAN
> to indicate that it refers to a computer
	  rather than anything else.  
	</P
><P
>&#13;	  The semantic markup to designate <SPAN
CLASS="systemitem"
>whitechuck</SPAN
> as a
	  computer system looks like this:
	  <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="screen"
>&#13;&#60;systemitem class="systemname"&#62;whitechuck&#60;/systemitem&#62;
	  </PRE
></TD
></TR
></TABLE
>
	</P
><P
>&#13;	  Not only is this a lot to write, but you want to be
	  sure that you refer to <SPAN
CLASS="systemitem"
>whitechuck</SPAN
> the same way
	  every time.  Here is where a user defined entity 
	  can provide standardization in addition to
	  convenience.  The entity would look like this (shown
	  in the context of the document type declaration):
	  <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="screen"
>&#13;&#60;!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
 "/usr/share/sgml/docbook/xml-dtd-4.2-1.0-14/docbookx.dtd"
[
    &#60;!ENTITY whitechuck '&#60;systemitem class="systemname"&#62;whitechuck&#60;/systemitem&#62;'&#62;
]&#62;
	  </PRE
></TD
></TR
></TABLE
>
	  <I
CLASS="emphasis"
>&#13;	    Note the single quotes around the replacement text, 
	    which allow double quotes to be used for the
	    class attribute value.
	  </I
>
	</P
><P
>&#13;	  Once the <SPAN
CLASS="systemitem"
>whitechuck</SPAN
> entity has been defined, it is easy
	  to include it in the document.  For example, you might
	  write the following:
	  <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="screen"
>&#13;Copy the file to &#38;whitechuck;.  Every time a Web user references
the home page on &#38;whitechuck;, the file will be executed. If
&#38;whitechuck; is down, blah, blah, blah.
	  </PRE
></TD
></TR
></TABLE
>
	</P
></DIV
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="AEN274"
></A
>Adding Diagrams to Your Document</H2
><P
>&#13;      In principal, any sort of graphics image can be added to a 
      Docbook document.  This includes diagrams, photographs,
      and any sort of bitmap.  It is easy for the author to do
      this.  The hard work falls upon the infrastructure to
      scale the image appropriately for both the Web formats
      (html) and printed page formats (pdf, rtf).  At present
      this does not always work. 
    </P
><P
>&#13;      With the infrastructure currently used by the
      Software Team, one reliable way to include diagrams in
      documents is to create them with Dia, an Open 
      Source diagramming tool that bears some resemblance
      to Visio.
      Dia is available on your desktop through the menu
      sequence
      <B
CLASS="guimenu"
>Main</B
> =&#62;
      <B
CLASS="guimenu"
>Office</B
> =&#62;
      <B
CLASS="guimenuitem"
>Diagrams</B
>.
      You can also launch it from a shell window in your document
      directory with the command <B
CLASS="command"
>dia &#38;</B
>.
    </P
><P
>&#13;      Dia is a mostly self-explanatory Gui application. A 
      description of the interface is beyond the scope of this
      document.  We do need to discuss the saving of files,
      however.  
      <P
></P
><UL
><LI
><P
>&#13;	    <I
CLASS="emphasis"
>&#13;	      Saving the diagram for addition to the CVS repository.
	    </I
>
	    <P
></P
><OL
TYPE="1"
><LI
><P
>&#13;		  Locate the mouse pointer anywhere within your diagram,
		  then use the following mouse and menu
		  sequence to save the diagram:
		  <B
CLASS="guimenu"
>right-click</B
> =&#62;
		  <B
CLASS="guimenu"
>File</B
>
		  <B
CLASS="guimenuitem"
>Save As</B
>
		</P
></LI
><LI
><P
>&#13;		  In the window that pops up, un-check the
		  <TT
CLASS="guilabel"
><B
>Compress diagram files</B
></TT
> check
		  box.
		</P
></LI
><LI
><P
>&#13;		  In the <TT
CLASS="guilabel"
><B
>Selection</B
></TT
> box, type
		  in a name for this figure, and then click
		  <B
CLASS="guibutton"
>OK</B
>.
		</P
></LI
></OL
>
	    The file will be saved as XML.  Because XML is a
	    text format, it can be readily maintained in CVS.
	  </P
></LI
><LI
><P
>&#13;	    <I
CLASS="emphasis"
>Saving output for inclusion in your document.</I
>
	    <P
></P
><OL
TYPE="1"
><LI
><P
>&#13;		  Locate the mouse pointer anywhere within your diagram,
		  then use the following mouse and menu sequence to 
		  produce output for inclusion in your document:
		  <B
CLASS="guimenu"
>right-click</B
> =&#62;
		  <B
CLASS="guimenu"
>File</B
>
		  <B
CLASS="guimenuitem"
>Export</B
>
		</P
></LI
><LI
><P
>&#13;		  In the <TT
CLASS="guilabel"
><B
>Determine File Type</B
></TT
> selection
		  list of the window that pops up, choose
		  <B
CLASS="guimenuitem"
>Portable Network Graphics (*.png)</B
>.
		</P
></LI
><LI
><P
>&#13;		  In the <TT
CLASS="guilabel"
><B
>Selection</B
></TT
> box, the file name
		  should be the same one under which you saved the
		  diagram.  If not, change it so that the two names match,
		  then click <B
CLASS="guibutton"
>OK</B
>.
		</P
></LI
></OL
>
	  </P
></LI
></UL
>
    </P
><P
>&#13;      A good way to add a diagram to your document is to use the
      <I
CLASS="emphasis"
>figure</I
> Docbook element.  Here is an
      example:
      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="screen"
>&#13;&#60;figure&#62;
  &#60;title&#62;Three Tiered Architecture&#60;/title&#62;
  &#60;graphic scale="60" fileref="arch.png"/&#62;
&#60;/figure&#62;
      </PRE
></TD
></TR
></TABLE
>
      The "scale" attribute requests the formatter to include the 
      diagram at 60% of its original size.  With your diagrams,
      you will need to experiment with this number, until things
      look right.
    </P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="AEN320"
></A
>Publishing Your Document</H2
><P
>&#13;      To publish your document to the Software Team web site,
      you need to do two things:
      <P
></P
><OL
TYPE="1"
><LI
><P
>&#13;	    Install the output files on the web server.
	  </P
></LI
><LI
><P
>&#13;	    Add links to the web page.
	  </P
></LI
></OL
>
    </P
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="AEN328"
></A
>Installing to the Web Server</H3
><P
>&#13;	Before installing to the Web Server, you should be
	sure that your document is complete.  When you are
	satisfied with it, generate the output one last 
	time, then install.  In the document directory:
	<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="screen"
>&#13;make clean
make
make install
	</PRE
></TD
></TR
></TABLE
>
      </P
><P
>&#13;	You can invoke the <B
CLASS="command"
>make</B
> commands
	listed above either from the command line 
	from inside Emacs, via the
	<B
CLASS="guimenu"
>Tools</B
> =&#62; <B
CLASS="guimenuitem"
>Compile</B
>
	menu selection.  
      </P
><P
>&#13;	The .html file, the .pdf file and all .png files 
	will be copied to the appropriate directory on
	<SPAN
CLASS="systemitem"
>whitechuck</SPAN
> by <B
CLASS="command"
>make install</B
>.
      </P
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="AEN339"
></A
>Adding Links to the Web Page</H3
><P
>&#13;	In the directory <TT
CLASS="filename"
>r2/web</TT
>
	of your CVS workspace, edit the file
	<TT
CLASS="filename"
>index.html</TT
> with emacs.
	Find the links to other documents of the same
	type as your document, clone one of them,
	then change the references to designate your
	document name.
      </P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="AEN344"
></A
>Adding Your Document to the CVS Repository</H2
><P
>&#13;      The final step in creating a new document should be the
      placing of it in the CVS repository.  In this example,
      once again, we assume that your document name is
      <TT
CLASS="filename"
>perl-xml</TT
>.  
    </P
><P
>&#13;      Starting in the your document directory
      (<TT
CLASS="filename"
>perl-xml</TT
>):
      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="screen"
>&#13;	cd ..
	cvs add perl-xml
	cd perl-xml
	cvs add perl-xml.xml
	cvs add Makefile
	cvs add *.png         # if you have an .png image files
      </PRE
></TD
></TR
></TABLE
>
    </P
><P
>&#13;      At this point, everything has been added to your local
      workspace, but the changes have not yet been made to
      the repository on <SPAN
CLASS="systemitem"
>whitechuck</SPAN
>.  To accomplish that:
      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="screen"
>&#13;	cd ..
	cvs commit
      </PRE
></TD
></TR
></TABLE
>
    </P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="AEN354"
></A
>Compatibility with Microsoft Office</H2
><P
>&#13;      In the directory for your document, <B
CLASS="command"
>make install</B
>
      copies the .html and .pdf output files to the Software Team
      web page.  It does not, however, do anything with the .rtf output
      file.  The purpose of that file is to facilitate the inclusion
      of your document, either whole or in part, in a Microsoft Office
      document.
    </P
><P
>&#13;      You do not need to do anything with the .rtf file until it 
      is needed for a Microsoft Office document.  At that time
      you will need to transfer the .rtf output, along with any associated
      image files, to a workstation running Microsoft Office.  You
      can do this in a number of ways: attaching the files to email, 
      transferring them on a floppy disk, sending them via the
      <B
CLASS="command"
>ssh</B
>,
      etc.
      In Microsoft Office, just open the .rtf file. Office should
      be able to integrate your image files.  You may, however,
      need to use Office to manipulate the scaling of the images.
      Finally, save the file as a Microsoft-standard .doc file.
    </P
></DIV
></DIV
></BODY
></HTML
>