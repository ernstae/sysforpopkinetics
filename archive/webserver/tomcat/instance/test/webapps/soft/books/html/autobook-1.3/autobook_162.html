<HTML>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created on May, 24  2001 by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>Autoconf, Automake, and Libtool: A Simple GNU/Linux Module Loader</TITLE>

<META NAME="description" CONTENT="Autoconf, Automake, and Libtool: A Simple GNU/Linux Module Loader">
<META NAME="keywords" CONTENT="Autoconf, Automake, and Libtool: A Simple GNU/Linux Module Loader">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">
<script language="Javascript">
<!--    
// Check the browser version.

    function checkVersion() {
      if (navigator.appVersion.charAt(0)>=3) return true;
      if (navigator.appVersion.charAt(0)>=4) return true;
      else return false;
    }

      if (checkVersion()) {
             homeon = new Image();
             homeon.src = "homeon.png";

             homeoff = new Image();
             homeoff.src = "home.png";

             tocon = new Image();
             tocon.src = "tocon.png";

             tocoff = new Image();
             tocoff.src = "toc.png";

             indexon = new Image();
             indexon.src = "indexon.png";

             indexoff = new Image();
             indexoff.src = "index.png";

             helpon = new Image();
             helpon.src = "helpon.png";

             helpoff = new Image();
             helpoff.src = "help.png";

             backon = new Image();
             backon.src = "backon.png";

             backoff = new Image();
             backoff.src = "back.png";

             forwardon = new Image();
             forwardon.src = "forwardon.png";

             forwardoff = new Image();
             forwardoff.src = "forward.png";

             prevon = new Image();
             prevon.src = "prevon.png";

             prevoff = new Image();
             prevoff.src = "prev.png";

             nexton = new Image();
             nexton.src = "nexton.png";

             nextoff = new Image();
             nextoff.src = "next.png";

             upon = new Image();
             upon.src = "upon.png";

             upoff = new Image();
             upoff.src = "up.png";
         }

     function img_act(imgName) {
             if (checkVersion()) {
             imgOn = eval(imgName + "on.src");
             document [imgName].src = imgOn;
             }
     }

     function img_inact(imgName) {
             if (checkVersion()) {
             imgOff = eval(imgName + "off.src");
             document [imgName].src = imgOff;
             }
     }
// -->
</SCRIPT>

</HEAD>

<BODY LANG="EN" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#6688AA" VLINK="#336688" ALINK="#808080">

<A NAME="SEC162"></A>
<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=10>
<TR VALIGN="TOP">
<TD ALIGN="MIDDLE" WIDTH=50 BGCOLOR="#e6e6e6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR VALIGN="TOP" ALIGN="LEFT">
<TD VALIGN="MIDDLE" ALIGN="LEFT"><A HREF="autobook_161.html#SEC161" onMouseover="img_act('prev')" onMouseout="img_inact('prev')"><IMG SRC="prev.png" BORDER="0" ALT="Back: Finding a Module" ALIGN="MIDDLE" NAME="prev"></A></TD>
</TR>
<TR VALIGN="TOP" ALIGN="LEFT">
<TD VALIGN="MIDDLE" ALIGN="LEFT"><A HREF="autobook_163.html#SEC163" onMouseover="img_act('next')" onMouseout="img_inact('next')"><IMG SRC="next.png" BORDER="0" ALT="Forward: A Simple GNU/Linux Dynamic Module" ALIGN="MIDDLE" NAME="next"></A></TD>
</TR>
<TR VALIGN="TOP" ALIGN="LEFT">
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TR VALIGN="TOP" ALIGN="LEFT">
<TD VALIGN="MIDDLE" ALIGN="LEFT"><A HREF="autobook_163.html#SEC163" onMouseover="img_act('back')" onMouseout="img_inact('back')"><IMG SRC="back.png" BORDER="0" ALT="FastBack: A Simple GNU/Linux Dynamic Module" ALIGN="MIDDLE" NAME="back"></A></TD>
</TR>
<TR VALIGN="TOP" ALIGN="LEFT">
<TD VALIGN="MIDDLE" ALIGN="LEFT"><A HREF="autobook_158.html#SEC158" onMouseover="img_act('up')" onMouseout="img_inact('up')"><IMG SRC="up.png" BORDER="0" ALT="Up: Dynamic Loading" ALIGN="MIDDLE" NAME="up"></A></TD>
</TR>
<TR VALIGN="TOP" ALIGN="LEFT">
<TD VALIGN="MIDDLE" ALIGN="LEFT"><A HREF="autobook_164.html#SEC164" onMouseover="img_act('forward')" onMouseout="img_inact('forward')"><IMG SRC="forward.png" BORDER="0" ALT="FastForward: Using GNU libltdl" ALIGN="MIDDLE" NAME="forward"></A></TD>
</TR>
<TR VALIGN="TOP" ALIGN="LEFT">
<TD VALIGN="MIDDLE" ALIGN="LEFT"><A HREF="autobook.html#SEC_Top" onMouseover="img_act('home')" onMouseout="img_inact('home')"><IMG SRC="home.png" BORDER="0" ALT="Top: Autoconf, Automake, and Libtool" ALIGN="MIDDLE" NAME="home"></A></TD>
</TR>
<TR VALIGN="TOP" ALIGN="LEFT">
<TD VALIGN="MIDDLE" ALIGN="LEFT"><A HREF="autobook_toc.html#SEC_Contents" onMouseover="img_act('toc')" onMouseout="img_inact('toc')"><IMG SRC="toc.png" BORDER="0" ALT="Contents: Table of Contents" ALIGN="MIDDLE" NAME="toc"></A></TD>
</TR>
<TR VALIGN="TOP" ALIGN="LEFT">
<TD VALIGN="MIDDLE" ALIGN="LEFT"><A HREF="autobook_285.html#SEC285" onMouseover="img_act('index')" onMouseout="img_inact('index')"><IMG SRC="index.png" BORDER="0" ALT="Index: Index" ALIGN="MIDDLE" NAME="index"></A></TD>
</TR>
<TR VALIGN="TOP" ALIGN="LEFT">
<TD VALIGN="MIDDLE" ALIGN="LEFT"><A HREF="autobook_abt.html#SEC_About" onMouseover="img_act('help')" onMouseout="img_inact('help')"><IMG SRC="help.png" BORDER="0" ALT="About: About this document" ALIGN="MIDDLE" NAME="help"></A></TD>
</TR>
</TABLE>
</TD>
<TD ALIGN="LEFT">
<H2> 17.4 A Simple GNU/Linux Module Loader </H2>
<!--docid::SEC162::-->
<P>

Something to be aware of, is that when your users write dynamic modules
for your application, they are subject to the interface you design.  It
is very important to design a dynamic module interface that is clean and
functional before other people start to write modules for your code.  If
you ever need to change the interface, your users will need to rewrite
their modules.  Of course you can carefully change the interface  to
retain backwards compatibility to save your users the trouble of
rewriting their modules, but that is no substitute for designing a
good interface from the outset.  If you do get it wrong, and
subsequently discover that the design you implemented is misconceived
(this is the voice of experience speaking!), you will be left with a
difficult choice: try to tweak the broken API so that it does work
while retaining backwards compatibility,  and the maintenance and
performace penalty that brings? Or start again with a fresh design born
of the experience gained last time, and rewrite all of the modules you
have so far?
</P><P>

If there are other applications which have similar module requirements
to you, it is worth writing a loader that uses the same interface and
semantics.  That way, you will (hopefully) be building from a known good
API design, and you will have access to all the modules for that
other application too, and vice versa. 
</P><P>

For the sake of clarity, I have sidestepped any issues of API
design for the following example, by choosing this minimal interface:
</P><P>

<A NAME="IDX26"></A>
<DL>
<DT><U>Function:</U> int <B>run</B> <I>(const char *<VAR>argument</VAR>)</I>
<DD>When the module is successfully loaded a function with the following
prototype is called with the argument given on the command line.  If
this entry point is found and called, but returns <SAMP>`-1'</SAMP>, an error
message is displayed by the calling program.
</DL>
</P><P>

Here's a simplistic but complete dynamic module loading application you
can build for this interface with the  GNU/Linux dynamic loading
API:
</P><P>

<TABLE width=100%><tr><td>&nbsp;</td><td class=example bgcolor=#6688aa><br><pre>#include &#60;stdio.h&#62;
#include &#60;stdlib.h&#62;
#ifndef EXIT_FAILURE
#  define EXIT_FAILURE        1
#  define EXIT_SUCCESS        0
#endif

#include &#60;limits.h&#62;
#ifndef PATH_MAX
#  define PATH_MAX 255
#endif

#include &#60;dlfcn.h&#62;
/* This is missing from very old Linux libc. */
#ifndef RTLD_NOW
#  define RTLD_NOW 2
#endif

typedef int entrypoint (const char *argument);

/* Save and return a copy of the dlerror() error  message,
   since the next API call may overwrite the original. */
static char *dlerrordup (char *errormsg);

int
main (int argc, const char *argv[])
{
  const char modulepath[1+ PATH_MAX];
  const char *errormsg = NULL;
  void *module = NULL;
  entrypoint *run = NULL;
  int errors = 0;

  if (argc != 3)
    {
      fprintf (stderr, "USAGE: main MODULENAME ARGUMENT\n");
      exit (EXIT_FAILURE);
    }

  /* Set the module search path. */
  getcwd (modulepath, PATH_MAX);
  strcat (modulepath, "/");
  strcat (modulepath, argv[1]);
  
  /* Load the module. */
  module = dlopen (modulepath, RTLD_NOW);
  if (!module)
    {
      strcat (modulepath, ".so");
      module = dlopen (modulepath, RTLD_NOW);
    }
  if (!module)
    errors = 1;

  /* Find the entry point. */
  if (!errors)
    {
      run = dlsym (module, "run");
      /* In principle, run might legitimately be NULL, so
         I don't use run == NULL as an error indicator. */
      errormsg = dlerrordup (errormsg);

      if (errormsg != NULL)
        errors = dlclose (module);
    }

  /* Call the entry point function. */
  if (!errors)
    {
      int result = (*run) (argv[2]);
      if (result &#60; 0)
        errormsg = strdup ("module entry point execution failed");
      else
        printf ("\t=> %d\n", result);
    }

  /* Unload the module, now that we are done with it. */
  if (!errors)
    errors = dlclose (module);

  if (errors)
    {
      /* Diagnose the encountered error. */
      errormsg = dlerrordup (errormsg);

      if (!errormsg)
        {
          fprintf (stderr, "%s: dlerror() failed.\n", argv[0]);
          return EXIT_FAILURE;
        }
    }
  
  if (errormsg)
    {
      fprintf (stderr, "%s: %s.\n", argv[0], errormsg);
      free (errormsg);
      return EXIT_FAILURE;
    }
  
  return EXIT_SUCCESS;
}

/* Be careful to save a copy of the error message,
   since the next API call may overwrite the original. */
static char *
dlerrordup (char *errormsg)
{
  char *error = (char *) dlerror ();
  if (error &#38;&#38; !errormsg)
    errormsg = strdup (error);
  return errormsg;
}

</pre></td></tr></table></P><P>

You would compile this on a GNU/Linux machine like so:
</P><P>

<TABLE width=100%><tr><td>&nbsp;</td><td class=example bgcolor=#6688aa><br><pre>$ gcc -o simple-loader simple-loader.c -ldl
</pre></td></tr></table></P><P>

However, despite making reasonable effort with this loader, and ignoring
features which could easily be added, it still has some seemingly
insoluble problems:
</P><P>

<OL>
<LI>
It will fail if the user's platform doesn't have the <CODE>dlopen</CODE>
API.  This also includes platforms which have no shared libraries.
<P>

<LI>
It relies on the implementation to provide a working self-opening
mechanism.  <SAMP>`dlopen (NULL, RTLD_NOW)'</SAMP> is very often unimplemented,
or buggy, and without that, it is impossible to access the symbols of
the main program through the <SAMP>`dlsym'</SAMP> mechanism.
<P>

<LI>
It is quite difficult to figure out at compile time whether the target
host needs <TT>`libdl.so'</TT> to be linked.
</OL>
<P>

I will use GNU Autotools to tackle these problems in the next chapter.
</P><P>

<A NAME="A Simple GNU/Linux Dynamic Module"></A>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated
by <I>Gary V. Vaughan</I> on <I>May, 24  2001</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
