<HTML>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created on April 2, 2002 by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>GNU Emacs Manual: Mark</TITLE>

<META NAME="description" CONTENT="GNU Emacs Manual: Mark">
<META NAME="keywords" CONTENT="GNU Emacs Manual: Mark">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="EN" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC52"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_10.html#SEC51"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC53"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_10.html#SEC42"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC59"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> H. The Mark and the Region </H1>
<!--docid::SEC52::-->
<P>

  Many Emacs commands operate on an arbitrary contiguous part of the
current buffer.  To specify the text for such a command to operate on,
you set <EM>the mark</EM> at one end of it, and move point to the other
end.  The text between point and the mark is called <EM>the region</EM>.
Emacs highlights the region whenever there is one, if you enable
Transient Mark mode (see section <A HREF="emacs_11.html#SEC54">H.2 Transient Mark Mode</A>).
</P><P>

  Certain Emacs commands set the mark; other editing commands do not
affect it, so the mark remains where you set it last.  Each Emacs
buffer has its own mark, and setting the mark in one buffer has no
effect on other buffers' marks.  When you return to a buffer that was
current earlier, its mark is at the same place as before.
</P><P>

  The ends of the region are always point and the mark.  It doesn't
matter which of them was put in its current place first, or which one
comes earlier in the text--the region starts from point or the mark
(whichever comes first), and ends at point or the mark (whichever
comes last).  Every time you move point, or set the mark in a new
place, the region changes.
</P><P>

  Many commands that insert text, such as <KBD>C-y</KBD> (<CODE>yank</CODE>) and
<KBD>M-x insert-buffer</KBD>, position point and the mark at opposite ends
of the inserted text, so that the region consists of the text just
inserted.
</P><P>

  Aside from delimiting the region, the mark is also useful for
remembering a spot that you may want to go back to.  To make this
feature more useful, each buffer remembers 16 previous locations of the
mark in the <EM>mark ring</EM>.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="emacs_11.html#SEC53">H.1 Setting the Mark</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Commands to set the mark.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="emacs_11.html#SEC54">H.2 Transient Mark Mode</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">How to make Emacs highlight the region--
			  when there is one.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="emacs_11.html#SEC55">H.3 Operating on the Region</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Summary of ways to operate on contents of the region.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="emacs_11.html#SEC56">H.4 Commands to Mark Textual Objects</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Commands to put region around textual units.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="emacs_11.html#SEC57">H.5 The Mark Ring</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Previous mark positions saved so you can go back there.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="emacs_11.html#SEC58">H.6 The Global Mark Ring</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Previous mark positions in various buffers.</TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Setting Mark"></A>
<HR SIZE="6">
<A NAME="SEC53"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC52"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC54"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC52"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC52"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC59"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> H.1 Setting the Mark </H2>
<!--docid::SEC53::-->
<P>

  Here are some commands for setting the mark:
</P><P>

<DL COMPACT>
<DT><KBD>C-<KBD>SPC</KBD></KBD>
<DD>Set the mark where point is (<CODE>set-mark-command</CODE>).
<DT><KBD>C-@</KBD>
<DD>The same.
<DT><KBD>C-x C-x</KBD>
<DD>Interchange mark and point (<CODE>exchange-point-and-mark</CODE>).
<DT><KBD>Drag-Mouse-1</KBD>
<DD>Set point and the mark around the text you drag across.
<DT><KBD>Mouse-3</KBD>
<DD>Set the mark where point is, then move point to where you click
(<CODE>mouse-save-then-kill</CODE>).
</DL>
<P>

  For example, suppose you wish to convert part of the buffer to
upper case, using the <KBD>C-x C-u</KBD> (<CODE>upcase-region</CODE>) command,
which operates on the text in the region.  You can first go to the
beginning of the text to be capitalized, type <KBD>C-<KBD>SPC</KBD></KBD> to put
the mark there, move to the end, and then type <KBD>C-x C-u</KBD>.  Or, you
can set the mark at the end of the text, move to the beginning, and then
type <KBD>C-x C-u</KBD>.
</P><P>

<A NAME="IDX224"></A>
<A NAME="IDX225"></A>
  The most common way to set the mark is with the <KBD>C-<KBD>SPC</KBD></KBD> command
(<CODE>set-mark-command</CODE>).  This sets the mark where point is.  Then you
can move point away, leaving the mark behind.
</P><P>

  There are two ways to set the mark with the mouse.  You can drag mouse
button one across a range of text; that puts point where you release the
mouse button, and sets the mark at the other end of that range.  Or you
can click mouse button three, which sets the mark at point (like
<KBD>C-<KBD>SPC</KBD></KBD>) and then moves point (like <KBD>Mouse-1</KBD>).  Both of
these methods copy the region into the kill ring in addition to setting
the mark; that gives behavior consistent with other window-driven
applications, but if you don't want to modify the kill ring, you must
use keyboard commands to set the mark.  See section <A HREF="emacs_19.html#SEC192">P.1 Mouse Commands for Editing</A>.
</P><P>

<A NAME="IDX226"></A>
<A NAME="IDX227"></A>
  Ordinary terminals have only one cursor, so there is no way for Emacs
to show you where the mark is located.  You have to remember.  The usual
solution to this problem is to set the mark and then use it soon, before
you forget where it is.  Alternatively, you can see where the mark is
with the command <KBD>C-x C-x</KBD> (<CODE>exchange-point-and-mark</CODE>) which
puts the mark where point was and point where the mark was.  The extent
of the region is unchanged, but the cursor and point are now at the
previous position of the mark.  In Transient Mark mode, this command
reactivates the mark.
</P><P>

  <KBD>C-x C-x</KBD> is also useful when you are satisfied with the position
of point but want to move the other end of the region (where the mark
is); do <KBD>C-x C-x</KBD> to put point at that end of the region, and then
move it.  Using <KBD>C-x C-x</KBD> a second time, if necessary, puts the mark at
the new position with point back at its original position.
</P><P>

  For more facilities that allow you to go to previously set marks, see
<A HREF="emacs_11.html#SEC57">H.5 The Mark Ring</A>.
</P><P>

<A NAME="IDX228"></A>
  There is no such character as <KBD>C-<KBD>SPC</KBD></KBD> in ASCII; when you
type <KBD>SPC</KBD> while holding down <KBD>CTRL</KBD>, what you get on most
ordinary terminals is the character <KBD>C-@</KBD>.  This key is actually
bound to <CODE>set-mark-command</CODE>.  But unless you are unlucky enough to
have a terminal where typing <KBD>C-<KBD>SPC</KBD></KBD> does not produce
<KBD>C-@</KBD>, you might as well think of this character as
<KBD>C-<KBD>SPC</KBD></KBD>.  Under X, <KBD>C-<KBD>SPC</KBD></KBD> is actually a distinct
character, but its binding is still <CODE>set-mark-command</CODE>.
</P><P>

<A NAME="Transient Mark"></A>
<HR SIZE="6">
<A NAME="SEC54"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC53"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC55"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC55"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC52"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC59"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> H.2 Transient Mark Mode </H2>
<!--docid::SEC54::-->
<P>

  On a terminal that supports colors, Emacs can highlight the current
region.  But normally it does not.  Why not?
</P><P>

  Highlighting the region whenever it exists would not be desirable in
Emacs, because once you have set a mark, there is <EM>always</EM> a
region (in that buffer).  And highlighting the region all the time
would be a nuisance.  So normally Emacs highlights the region only
immediately after you have selected one with the mouse.
</P><P>

  You can turn on region highlighting by enabling Transient Mark mode.
This is a more rigid mode of operation in which the region "lasts"
only temporarily, so you must set up a region for each command that uses
one.  In Transient Mark mode, most of the time there is no region;
therefore, highlighting the region when it exists is useful and
not annoying.
</P><P>

<A NAME="IDX229"></A>
  To enable Transient Mark mode, type <KBD>M-x transient-mark-mode</KBD>.
This command toggles the mode, so you can repeat the command to turn off
the mode.
</P><P>

  Here are the details of Transient Mark mode:
</P><P>

<UL>
<LI>
To set the mark, type <KBD>C-<KBD>SPC</KBD></KBD> (<CODE>set-mark-command</CODE>).
This makes the mark active and thus begins highlighting of the region.
As you move point, you will see the highlighted region grow and
shrink.
<P>

<LI>
The mouse commands for specifying the mark also make it active.  So do
keyboard commands whose purpose is to specify a region, including
<KBD>M-@</KBD>, <KBD>C-M-@</KBD>, <KBD>M-h</KBD>, <KBD>C-M-h</KBD>, <KBD>C-x C-p</KBD>, and
<KBD>C-x h</KBD>.
<P>

<LI>
When the mark is active, you can execute commands that operate on the
region, such as killing, indenting, or writing to a file.
<P>

<LI>
Any change to the buffer, such as inserting or deleting a character,
deactivates the mark.  This means any subsequent command that operates
on a region will get an error and refuse to operate.  You can make the
region active again by typing <KBD>C-x C-x</KBD>.
<P>

<LI>
Commands like <KBD>M-&#62;</KBD> and <KBD>C-s</KBD>, that "leave the mark behind" in
addition to some other primary purpose, do not activate the new mark.
You can activate the new region by executing <KBD>C-x C-x</KBD>
(<CODE>exchange-point-and-mark</CODE>).
<P>

<LI>
<KBD>C-s</KBD> when the mark is active does not alter the mark.
<P>

<LI>
Quitting with <KBD>C-g</KBD> deactivates the mark.
<P>

<LI>
Some commands operate on the region whenever it is active.  For
instance, <KBD>C-x u</KBD> in Transient Mark mode operates on the region
when there is a region.  Outside Transient Mark mode, you must type
<KBD>C-u C-x u</KBD> if you want it to operate on the region.
See section <A HREF="emacs_7.html#SEC23">D.4 Undoing Changes</A>.   Other commands that act this way are identified
in their own documentation.
</UL>
<P>

  The highlighting of the region uses the <CODE>region</CODE> face; you can
customize the appearance of the highlighted region by changing this
face.  See section <A HREF="emacs_33.html#SEC482">AD.2.2.3 Customizing Faces</A>.
</P><P>

<A NAME="IDX230"></A>
  When multiple windows show the same buffer, they can have different
regions, because they can have different values of point (though they
all share one common mark position).  Ordinarily, only the selected
window highlights its region (see section <A HREF="emacs_18.html#SEC183">O. Multiple Windows</A>).  However, if the
variable <CODE>highlight-nonselected-windows</CODE> is non-<CODE>nil</CODE>, then
each window highlights its own region (provided that Transient Mark mode
is enabled and the mark in the window's buffer is active).
</P><P>

  When Transient Mark mode is not enabled, every command that sets the
mark also activates it, and nothing ever deactivates it.
</P><P>

<A NAME="IDX231"></A>
  If the variable <CODE>mark-even-if-inactive</CODE> is non-<CODE>nil</CODE> in
Transient Mark mode, then commands can use the mark and the region
even when it is inactive.  Region highlighting appears and disappears 
just as it normally does in Transient Mark mode, but the mark doesn't
really go away when the highlighting disappears.
</P><P>

<A NAME="IDX232"></A>
  Transient Mark mode is also sometimes known as "Zmacs mode"
because the Zmacs editor on the MIT Lisp Machine handled the mark in a
similar way.
</P><P>

<A NAME="Using Region"></A>
<HR SIZE="6">
<A NAME="SEC55"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC54"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC56"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC56"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC52"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC59"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> H.3 Operating on the Region </H2>
<!--docid::SEC55::-->
<P>

<A NAME="IDX233"></A>
  Once you have a region and the mark is active, here are some of the
ways you can operate on the region:
</P><P>

<UL>
<LI>
Kill it with <KBD>C-w</KBD> (see section <A HREF="emacs_11.html#SEC59">H.7 Deletion and Killing</A>).
<LI>
Save it in a register with <KBD>C-x r s</KBD> (see section <A HREF="emacs_12.html#SEC69">I. Registers</A>).
<LI>
Save it in a buffer or a file (see section <A HREF="emacs_11.html#SEC67">H.9 Accumulating Text</A>).
<LI>
Convert case with <KBD>C-x C-l</KBD> or <KBD>C-x C-u</KBD> (see section <A HREF="emacs_23.html#SEC244">T.6 Case Conversion Commands</A>).
<LI>
Indent it with <KBD>C-x <KBD>TAB</KBD></KBD> or <KBD>C-M-\</KBD> (see section <A HREF="emacs_22.html#SEC229">S. Indentation</A>).
<LI>
Fill it as text with <KBD>M-x fill-region</KBD> (see section <A HREF="emacs_23.html#SEC238">T.5 Filling Text</A>).
<LI>
Print hardcopy with <KBD>M-x print-region</KBD> (see section <A HREF="emacs_32.html#SEC458">AC.18 Hardcopy Output</A>).
<LI>
Evaluate it as Lisp code with <KBD>M-x eval-region</KBD> (see section <A HREF="emacs_25.html#SEC329">V.8 Evaluating Emacs-Lisp Expressions</A>).
</UL>
<P>

  Most commands that operate on the text in the region have the word
<CODE>region</CODE> in their names.
</P><P>

<A NAME="Marking Objects"></A>
<HR SIZE="6">
<A NAME="SEC56"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC55"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC57"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC57"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC52"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC59"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> H.4 Commands to Mark Textual Objects </H2>
<!--docid::SEC56::-->
<P>

<A NAME="IDX234"></A>
  Here are the commands for placing point and the mark around a textual
object such as a word, list, paragraph or page.
</P><P>

<DL COMPACT>
<DT><KBD>M-@</KBD>
<DD>Set mark after end of next word (<CODE>mark-word</CODE>).  This command and
the following one do not move point.
<DT><KBD>C-M-@</KBD>
<DD>Set mark after end of following balanced expression (<CODE>mark-sexp</CODE>).
<DT><KBD>M-h</KBD>
<DD>Put region around current paragraph (<CODE>mark-paragraph</CODE>).
<DT><KBD>C-M-h</KBD>
<DD>Put region around current defun (<CODE>mark-defun</CODE>).
<DT><KBD>C-x h</KBD>
<DD>Put region around the entire buffer (<CODE>mark-whole-buffer</CODE>).
<DT><KBD>C-x C-p</KBD>
<DD>Put region around current page (<CODE>mark-page</CODE>).
</DL>
<P>

<KBD>M-@</KBD> (<CODE>mark-word</CODE>) puts the mark at the end of the next
word, while <KBD>C-M-@</KBD> (<CODE>mark-sexp</CODE>) puts it at the end of the
next balanced expression (see section <A HREF="emacs_24.html#SEC282">U.4.1 Expressions with Balanced Parentheses</A>).  These commands handle
arguments just like <KBD>M-f</KBD> and <KBD>C-M-f</KBD>.
</P><P>

<A NAME="IDX235"></A>
<A NAME="IDX236"></A>
   Other commands set both point and mark, to delimit an object in the
buffer.  For example, <KBD>M-h</KBD> (<CODE>mark-paragraph</CODE>) moves point to
the beginning of the paragraph that surrounds or follows point, and puts
the mark at the end of that paragraph (see section <A HREF="emacs_23.html#SEC236">T.3 Paragraphs</A>).  It prepares
the region so you can indent, case-convert, or kill a whole paragraph.
</P><P>

  <KBD>C-M-h</KBD> (<CODE>mark-defun</CODE>) similarly puts point before, and the
mark after, the current (or following) major top-level definition, or
defun (see section <A HREF="emacs_24.html#SEC272">U.2.2 Moving by Defuns</A>).  <KBD>C-x C-p</KBD> (<CODE>mark-page</CODE>)
puts point before the current page, and mark at the end
(see section <A HREF="emacs_23.html#SEC237">T.4 Pages</A>).  The mark goes after the terminating page delimiter
(to include it in the region), while point goes after the preceding
page delimiter (to exclude it).  A numeric argument specifies a later
page (if positive) or an earlier page (if negative) instead of the
current page.
</P><P>

  Finally, <KBD>C-x h</KBD> (<CODE>mark-whole-buffer</CODE>) sets up the entire
buffer as the region, by putting point at the beginning and the mark at
the end.
</P><P>

  In Transient Mark mode, all of these commands activate the mark.
</P><P>

<A NAME="Mark Ring"></A>
<HR SIZE="6">
<A NAME="SEC57"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC56"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC58"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC58"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC52"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC59"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> H.5 The Mark Ring </H2>
<!--docid::SEC57::-->
<P>

<A NAME="IDX237"></A>
<A NAME="IDX238"></A>
<A NAME="IDX239"></A>
  Aside from delimiting the region, the mark is also useful for
remembering a spot that you may want to go back to.  To make this
feature more useful, each buffer remembers 16 previous locations of the
mark, in the <EM>mark ring</EM>.  Commands that set the mark also push the
old mark onto this ring.  To return to a marked location, use <KBD>C-u
C-<KBD>SPC</KBD></KBD> (or <KBD>C-u C-@</KBD>); this is the command
<CODE>set-mark-command</CODE> given a numeric argument.  It moves point to
where the mark was, and restores the mark from the ring of former
marks.  Thus, repeated use of this command moves point to all of the old
marks on the ring, one by one.  The mark positions you move through in
this way are not lost; they go to the end of the ring.
</P><P>

  Each buffer has its own mark ring.  All editing commands use the current
buffer's mark ring.  In particular, <KBD>C-u C-<KBD>SPC</KBD></KBD> always stays in
the same buffer.
</P><P>

  Many commands that can move long distances, such as <KBD>M-&#60;</KBD>
(<CODE>beginning-of-buffer</CODE>), start by setting the mark and saving the
old mark on the mark ring.  This is to make it easier for you to move
back later.  Searches set the mark if they move point.  You can tell
when a command sets the mark because it displays <SAMP>`Mark set'</SAMP> in the
echo area.
</P><P>

  If you want to move back to the same place over and over, the mark
ring may not be convenient enough.  If so, you can record the position
in a register for later retrieval (see section <A HREF="emacs_12.html#SEC70">Saving Positions in Registers</A>).
</P><P>

<A NAME="IDX240"></A>
  The variable <CODE>mark-ring-max</CODE> specifies the maximum number of
entries to keep in the mark ring.  If that many entries exist and
another one is pushed, the earliest one in the list is discarded.  Repeating
<KBD>C-u C-<KBD>SPC</KBD></KBD> cycles through the positions currently in the
ring.
</P><P>

<A NAME="IDX241"></A>
  The variable <CODE>mark-ring</CODE> holds the mark ring itself, as a list of
marker objects, with the most recent first.  This variable is local in
every buffer.
</P><P>

<A NAME="Global Mark Ring"></A>
<HR SIZE="6">
<A NAME="SEC58"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC57"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC59"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC59"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC52"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC59"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> H.6 The Global Mark Ring </H2>
<!--docid::SEC58::-->
<P>

  In addition to the ordinary mark ring that belongs to each buffer,
Emacs has a single <EM>global mark ring</EM>.  It records a sequence of
buffers in which you have recently set the mark, so you can go back
to those buffers.
</P><P>

  Setting the mark always makes an entry on the current buffer's mark
ring.  If you have switched buffers since the previous mark setting, the
new mark position makes an entry on the global mark ring also.  The
result is that the global mark ring records a sequence of buffers that
you have been in, and, for each buffer, a place where you set the mark.
</P><P>

<A NAME="IDX242"></A>
<A NAME="IDX243"></A>
  The command <KBD>C-x C-<KBD>SPC</KBD></KBD> (<CODE>pop-global-mark</CODE>) jumps to
the buffer and position of the latest entry in the global ring.  It also
rotates the ring, so that successive uses of <KBD>C-x C-<KBD>SPC</KBD></KBD> take
you to earlier and earlier buffers.
</P><P>

<A NAME="Killing"></A>
<HR SIZE="6">
<A NAME="SEC59"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC58"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC60"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC52"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC63"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> H.7 Deletion and Killing </H2>
<!--docid::SEC59::-->
<P>

<A NAME="IDX244"></A>
<A NAME="IDX245"></A>
<A NAME="IDX246"></A>
  Most commands which erase text from the buffer save it in the kill
ring so that you can move or copy it to other parts of the buffer.
These commands are known as <EM>kill</EM> commands.  The rest of the
commands that erase text do not save it in the kill ring; they are known
as <EM>delete</EM> commands.  (This distinction is made only for erasure of
text in the buffer.)  If you do a kill or delete command by mistake, you
can use the <KBD>C-x u</KBD> (<CODE>undo</CODE>) command to undo it
(see section <A HREF="emacs_7.html#SEC23">D.4 Undoing Changes</A>).
</P><P>

<A NAME="IDX247"></A>
<A NAME="IDX248"></A>
  You cannot kill read-only text, since such text does not allow any
kind of modification.  But some users like to use the kill commands to
copy read-only text into the kill ring, without actually changing it.
If you set the variable <CODE>kill-read-only-ok</CODE> to a non-<CODE>nil</CODE>
value, the kill commands work specially in a read-only buffer: they
move over text, and copy it to the kill ring, without actually
deleting it from the buffer.  When this happens, a message in the echo
area tells you what is happening.
</P><P>

  The delete commands include <KBD>C-d</KBD> (<CODE>delete-char</CODE>) and
<KBD>DEL</KBD> (<CODE>delete-backward-char</CODE>), which delete only one
character at a time, and those commands that delete only spaces or
newlines.  Commands that can destroy significant amounts of nontrivial
data generally do a kill operation instead.  The commands' names and
individual descriptions use the words <SAMP>`kill'</SAMP> and <SAMP>`delete'</SAMP> to
say which kind of operation they perform.
</P><P>

<A NAME="IDX249"></A>
<A NAME="IDX250"></A>
<A NAME="IDX251"></A>
  Many window systems follow the convention that insertion while text
is selected deletes the selected text.  You can make Emacs behave this
way by enabling Delete Selection mode, with <KBD>M-x
delete-selection-mode</KBD>, or using Custom.  Another effect of this mode
is that <KBD>DEL</KBD>, <KBD>C-d</KBD> and some other keys, when a selection
exists, will kill the whole selection.  It also enables Transient Mark
mode (see section <A HREF="emacs_11.html#SEC54">H.2 Transient Mark Mode</A>).
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="emacs_11.html#SEC60">H.7.1 Deletion</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Commands for deleting small amounts of text and
                          blank areas.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="emacs_11.html#SEC61">H.7.2 Killing by Lines</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">How to kill entire lines of text at one time.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="emacs_11.html#SEC62">H.7.3 Other Kill Commands</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Commands to kill large regions of text and
                          syntactic units such as words and sentences.</TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Deletion"></A>
<HR SIZE="6">
<A NAME="SEC60"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC59"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC61"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC59"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC59"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC63"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> H.7.1 Deletion </H3>
<!--docid::SEC60::-->
<P>

  Deletion means erasing text and not saving it in the kill ring.  For
the most part, the Emacs commands that delete text are those that
erase just one character or only whitespace.
</P><P>

<DL COMPACT>
<DT><KBD>C-d</KBD>
<DD><DT><KBD><KBD>Delete</KBD></KBD>
<DD>Delete next character (<CODE>delete-char</CODE>).  If your keyboard has a
<KBD>Delete</KBD> function key (usually located in the edit keypad), Emacs
binds it to <CODE>delete-char</CODE> as well.
<DT><KBD><KBD>DEL</KBD></KBD>
<DD><DT><KBD><KBD>BS</KBD></KBD>
<DD>Delete previous character (<CODE>delete-backward-char</CODE>).  Some keyboards
refer to this key as a "backspace key" and label it with a left arrow.
<DT><KBD>M-\</KBD>
<DD>Delete spaces and tabs around point (<CODE>delete-horizontal-space</CODE>).
<DT><KBD>M-<KBD>SPC</KBD></KBD>
<DD>Delete spaces and tabs around point, leaving one space
(<CODE>just-one-space</CODE>).
<DT><KBD>C-x C-o</KBD>
<DD>Delete blank lines around the current line (<CODE>delete-blank-lines</CODE>).
<DT><KBD>M-^</KBD>
<DD>Join two lines by deleting the intervening newline, along with any
indentation following it (<CODE>delete-indentation</CODE>).
</DL>
<P>

<A NAME="IDX252"></A>
<A NAME="IDX253"></A>
  The most basic delete commands are <KBD>C-d</KBD> (<CODE>delete-char</CODE>) and
<KBD>DEL</KBD> (<CODE>delete-backward-char</CODE>).  <KBD>C-d</KBD> deletes the
character after point, the one the cursor is "on top of."  This
doesn't move point.  <KBD>DEL</KBD> deletes the character before the cursor,
and moves point back.  You can delete newlines like any other characters
in the buffer; deleting a newline joins two lines.  Actually, <KBD>C-d</KBD>
and <KBD>DEL</KBD> aren't always delete commands; when given arguments, they
kill instead, since they can erase more than one character this way.
</P><P>

<A NAME="IDX254"></A>
<A NAME="IDX255"></A>
<A NAME="IDX256"></A>
  Every keyboard has a large key, labeled <KBD>DEL</KBD>, <KBD>BACKSPACE</KBD>,
<KBD>BS</KBD> or <KBD>DELETE</KBD>, which is a short distance above the
<KBD>RET</KBD> or <KBD>ENTER</KBD> key and is normally used for erasing what you
have typed.  Regardless of the actual name on the key, in Emacs it is
equivalent to <KBD>DEL</KBD>---or it should be.
</P><P>

  Many keyboards (including standard PC keyboards) have a
<KBD>BACKSPACE</KBD> key a short ways above <KBD>RET</KBD> or <KBD>ENTER</KBD>, and a
<KBD>DELETE</KBD> key elsewhere.  In that case, the <KBD>BACKSPACE</KBD> key is
<KBD>DEL</KBD>, and the <KBD>DELETE</KBD> key is equivalent to <KBD>C-d</KBD>---or it
should be.
</P><P>

  Why do we say "or it should be"?  When Emacs starts up using a
window system, it determines automatically which key or keys should be
equivalent to <KBD>DEL</KBD>.  As a result, <KBD>BACKSPACE</KBD> and/or <KBD>DELETE</KBD>
keys normally do the right things.  But in some unusual cases Emacs
gets the wrong information from the system.  If these keys don't do
what they ought to do, you need to tell Emacs which key to use for
<KBD>DEL</KBD>.  See section <A HREF="emacs_33.html#SEC512">AD.9.1 If <KBD>DEL</KBD> Fails to Delete</A>, for how to do this.
</P><P>

<A NAME="IDX257"></A>
  On most text-only terminals, Emacs cannot tell which keys the
keyboard really has, so it follows a uniform plan which may or may not
fit your keyboard.  The uniform plan is that the ASCII <KBD>DEL</KBD>
character deletes, and the ASCII <KBD>BS</KBD> (backspace) character asks
for help (it is the same as <KBD>C-h</KBD>).  If this is not right for your
keyboard, such as if you find that the key which ought to delete backwards
enters Help instead, see <A HREF="emacs_33.html#SEC512">AD.9.1 If <KBD>DEL</KBD> Fails to Delete</A>.
</P><P>

<A NAME="IDX258"></A>
<A NAME="IDX259"></A>
<A NAME="IDX260"></A>
<A NAME="IDX261"></A>
  The other delete commands are those which delete only whitespace
characters: spaces, tabs and newlines.  <KBD>M-\</KBD>
(<CODE>delete-horizontal-space</CODE>) deletes all the spaces and tab
characters before and after point.  <KBD>M-<KBD>SPC</KBD></KBD>
(<CODE>just-one-space</CODE>) does likewise but leaves a single space after
point, regardless of the number of spaces that existed previously (even
if there were none before).
</P><P>

  <KBD>C-x C-o</KBD> (<CODE>delete-blank-lines</CODE>) deletes all blank lines
after the current line.  If the current line is blank, it deletes all
blank lines preceding the current line as well (leaving one blank line,
the current line).
</P><P>

  <KBD>M-^</KBD> (<CODE>delete-indentation</CODE>) joins the current line and the
previous line, by deleting a newline and all surrounding spaces, usually
leaving a single space.  See section <A HREF="emacs_22.html#SEC229">M-^</A>.
</P><P>

<A NAME="Killing by Lines"></A>
<HR SIZE="6">
<A NAME="SEC61"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC60"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC62"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC62"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC59"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC63"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> H.7.2 Killing by Lines </H3>
<!--docid::SEC61::-->
<P>

<DL COMPACT>
<DT><KBD>C-k</KBD>
<DD>Kill rest of line or one or more lines (<CODE>kill-line</CODE>).
</DL>
<P>

<A NAME="IDX262"></A>
<A NAME="IDX263"></A>
  The simplest kill command is <KBD>C-k</KBD>.  If given at the beginning of
a line, it kills all the text on the line, leaving it blank.  When used
on a blank line, it kills the whole line including its newline.  To kill
an entire non-blank line, go to the beginning and type <KBD>C-k</KBD> twice.
</P><P>

  More generally, <KBD>C-k</KBD> kills from point up to the end of the line,
unless it is at the end of a line.  In that case it kills the newline
following point, thus merging the next line into the current one.
Spaces and tabs that you can't see at the end of the line are ignored
when deciding which case applies, so if point appears to be at the end
of the line, you can be sure <KBD>C-k</KBD> will kill the newline.
</P><P>

  When <KBD>C-k</KBD> is given a positive argument, it kills that many lines
and the newlines that follow them (however, text on the current line
before point is not killed).  With a negative argument -<VAR>n</VAR>, it
kills <VAR>n</VAR> lines preceding the current line (together with the text
on the current line before point).  Thus, <KBD>C-u - 2 C-k</KBD> at the front
of a line kills the two previous lines.
</P><P>

  <KBD>C-k</KBD> with an argument of zero kills the text before point on the
current line.
</P><P>

<A NAME="IDX264"></A>
  If the variable <CODE>kill-whole-line</CODE> is non-<CODE>nil</CODE>, <KBD>C-k</KBD> at
the very beginning of a line kills the entire line including the
following newline.  This variable is normally <CODE>nil</CODE>.
</P><P>

<A NAME="Other Kill Commands"></A>
<HR SIZE="6">
<A NAME="SEC62"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC61"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC63"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC59"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC59"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC63"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> H.7.3 Other Kill Commands </H3>
<!--docid::SEC62::-->
<P>

<DL COMPACT>
<DT><KBD>C-w</KBD>
<DD>Kill region (from point to the mark) (<CODE>kill-region</CODE>).
<DT><KBD>M-d</KBD>
<DD>Kill word (<CODE>kill-word</CODE>).  See section <A HREF="emacs_23.html#SEC234">T.1 Words</A>.
<DT><KBD>M-<KBD>DEL</KBD></KBD>
<DD>Kill word backwards (<CODE>backward-kill-word</CODE>).
<DT><KBD>C-x <KBD>DEL</KBD></KBD>
<DD>Kill back to beginning of sentence (<CODE>backward-kill-sentence</CODE>).
See section <A HREF="emacs_23.html#SEC235">T.2 Sentences</A>.
<DT><KBD>M-k</KBD>
<DD>Kill to end of sentence (<CODE>kill-sentence</CODE>).
<DT><KBD>C-M-k</KBD>
<DD>Kill the following balanced expression (<CODE>kill-sexp</CODE>).  See section <A HREF="emacs_24.html#SEC282">U.4.1 Expressions with Balanced Parentheses</A>.
<DT><KBD>M-z <VAR>char</VAR></KBD>
<DD>Kill through the next occurrence of <VAR>char</VAR> (<CODE>zap-to-char</CODE>).
</DL>
<P>

  A kill command which is very general is <KBD>C-w</KBD>
(<CODE>kill-region</CODE>), which kills everything between point and the
mark.  With this command, you can kill any contiguous sequence of
characters, if you first set the region around them.
</P><P>

<A NAME="IDX265"></A>
<A NAME="IDX266"></A>
  A convenient way of killing is combined with searching: <KBD>M-z</KBD>
(<CODE>zap-to-char</CODE>) reads a character and kills from point up to (and
including) the next occurrence of that character in the buffer.  A
numeric argument acts as a repeat count.  A negative argument means to
search backward and kill text before point.
</P><P>

  Other syntactic units can be killed: words, with <KBD>M-<KBD>DEL</KBD></KBD>
and <KBD>M-d</KBD> (see section <A HREF="emacs_23.html#SEC234">T.1 Words</A>); balanced expressions, with <KBD>C-M-k</KBD>
(see section <A HREF="emacs_24.html#SEC282">U.4.1 Expressions with Balanced Parentheses</A>); and sentences, with <KBD>C-x <KBD>DEL</KBD></KBD> and
<KBD>M-k</KBD> (see section <A HREF="emacs_23.html#SEC235">T.2 Sentences</A>).</P><P>

  You can use kill commands in read-only buffers.  They don't actually
change the buffer, and they beep to warn you of that, but they do copy
the text you tried to kill into the kill ring, so you can yank it into
other buffers.  Most of the kill commands move point across the text
they copy in this way, so that successive kill commands build up a
single kill ring entry as usual.
</P><P>

<A NAME="Yanking"></A>
<HR SIZE="6">
<A NAME="SEC63"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC62"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC64"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC59"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC67"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> H.8 Yanking </H2>
<!--docid::SEC63::-->
<P>

  <EM>Yanking</EM> means reinserting text previously killed.  This is what
some systems call "pasting."  The usual way to move or copy text is to
kill it and then yank it elsewhere one or more times.
</P><P>

<DL COMPACT>
<DT><KBD>C-y</KBD>
<DD>Yank last killed text (<CODE>yank</CODE>).
<DT><KBD>M-y</KBD>
<DD>Replace text just yanked with an earlier batch of killed text
(<CODE>yank-pop</CODE>).
<DT><KBD>M-w</KBD>
<DD>Save region as last killed text without actually killing it
(<CODE>kill-ring-save</CODE>).
<DT><KBD>C-M-w</KBD>
<DD>Append next kill to last batch of killed text (<CODE>append-next-kill</CODE>).
</DL>
<P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="emacs_11.html#SEC64">H.8.1 The Kill Ring</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Where killed text is stored.  Basic yanking.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="emacs_11.html#SEC65">H.8.2 Appending Kills</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Several kills in a row all yank together.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="emacs_11.html#SEC66">H.8.3 Yanking Earlier Kills</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Yanking something killed some time ago.</TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Kill Ring"></A>
<HR SIZE="6">
<A NAME="SEC64"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC63"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC65"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC63"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC63"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC67"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> H.8.1 The Kill Ring </H3>
<!--docid::SEC64::-->
<P>

  All killed text is recorded in the <EM>kill ring</EM>, a list of blocks of
text that have been killed.  There is only one kill ring, shared by all
buffers, so you can kill text in one buffer and yank it in another buffer.
This is the usual way to move text from one file to another.
(See section <A HREF="emacs_11.html#SEC67">H.9 Accumulating Text</A>, for some other ways.)
</P><P>

<A NAME="IDX267"></A>
<A NAME="IDX268"></A>
  The command <KBD>C-y</KBD> (<CODE>yank</CODE>) reinserts the text of the most recent
kill.  It leaves the cursor at the end of the text.  It sets the mark at
the beginning of the text.  See section <A HREF="emacs_11.html#SEC52">H. The Mark and the Region</A>.
</P><P>

  <KBD>C-u C-y</KBD> leaves the cursor in front of the text, and sets the
mark after it.  This happens only if the argument is specified with just
a <KBD>C-u</KBD>, precisely.  Any other sort of argument, including <KBD>C-u</KBD>
and digits, specifies an earlier kill to yank (see section <A HREF="emacs_11.html#SEC66">H.8.3 Yanking Earlier Kills</A>).
</P><P>

<A NAME="IDX269"></A>
<A NAME="IDX270"></A>
  To copy a block of text, you can use <KBD>M-w</KBD>
(<CODE>kill-ring-save</CODE>), which copies the region into the kill ring
without removing it from the buffer.  This is approximately equivalent
to <KBD>C-w</KBD> followed by <KBD>C-x u</KBD>, except that <KBD>M-w</KBD> does not
alter the undo history and does not temporarily change the screen.
</P><P>

<A NAME="Appending Kills"></A>
<HR SIZE="6">
<A NAME="SEC65"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC64"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC66"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC66"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC63"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC67"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> H.8.2 Appending Kills </H3>
<!--docid::SEC65::-->
<P>

<A NAME="IDX271"></A>
<A NAME="IDX272"></A>
  Normally, each kill command pushes a new entry onto the kill ring.
However, two or more kill commands in a row combine their text into a
single entry, so that a single <KBD>C-y</KBD> yanks all the text as a unit,
just as it was before it was killed.
</P><P>

  Thus, if you want to yank text as a unit, you need not kill all of it
with one command; you can keep killing line after line, or word after
word, until you have killed it all, and you can still get it all back at
once.
</P><P>

  Commands that kill forward from point add onto the end of the previous
killed text.  Commands that kill backward from point add text onto the
beginning.  This way, any sequence of mixed forward and backward kill
commands puts all the killed text into one entry without rearrangement.
Numeric arguments do not break the sequence of appending kills.  For
example, suppose the buffer contains this text:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>This is a line -!-of sample text.
</pre></td></tr></table></P><P>

with point shown by -!-.  If you type <KBD>M-d M-<KBD>DEL</KBD> M-d
M-<KBD>DEL</KBD></KBD>, killing alternately forward and backward, you end up with
<SAMP>`a line of sample'</SAMP> as one entry in the kill ring, and <SAMP>`This
is  text.'</SAMP> in the buffer.  (Note the double space between <SAMP>`is'</SAMP>
and <SAMP>`text'</SAMP>, which you can clean up with <KBD>M-<KBD>SPC</KBD></KBD> or
<KBD>M-q</KBD>.)
</P><P>

  Another way to kill the same text is to move back two words with
<KBD>M-b M-b</KBD>, then kill all four words forward with <KBD>C-u M-d</KBD>.
This produces exactly the same results in the buffer and in the kill
ring.  <KBD>M-f M-f C-u M-<KBD>DEL</KBD></KBD> kills the same text, all going
backward; once again, the result is the same.  The text in the kill ring
entry always has the same order that it had in the buffer before you
killed it.
</P><P>

<A NAME="IDX273"></A>
<A NAME="IDX274"></A>
  If a kill command is separated from the last kill command by other
commands (not just numeric arguments), it starts a new entry on the kill
ring.  But you can force it to append by first typing the command
<KBD>C-M-w</KBD> (<CODE>append-next-kill</CODE>) right before it.  The <KBD>C-M-w</KBD>
tells the following command, if it is a kill command, to append the text
it kills to the last killed text, instead of starting a new entry.  With
<KBD>C-M-w</KBD>, you can kill several separated pieces of text and
accumulate them to be yanked back in one place.</P><P>

  A kill command following <KBD>M-w</KBD> does not append to the text that
<KBD>M-w</KBD> copied into the kill ring.
</P><P>

<A NAME="Earlier Kills"></A>
<HR SIZE="6">
<A NAME="SEC66"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC65"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC67"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC63"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC63"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC67"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> H.8.3 Yanking Earlier Kills </H3>
<!--docid::SEC66::-->
<P>

<A NAME="IDX275"></A>
<A NAME="IDX276"></A>
<A NAME="IDX277"></A>
  To recover killed text that is no longer the most recent kill, use the
<KBD>M-y</KBD> command (<CODE>yank-pop</CODE>).  It takes the text previously
yanked and replaces it with the text from an earlier kill.  So, to
recover the text of the next-to-the-last kill, first use <KBD>C-y</KBD> to
yank the last kill, and then use <KBD>M-y</KBD> to replace it with the
previous kill.  <KBD>M-y</KBD> is allowed only after a <KBD>C-y</KBD> or another
<KBD>M-y</KBD>.
</P><P>

  You can understand <KBD>M-y</KBD> in terms of a "last yank" pointer which
points at an entry in the kill ring.  Each time you kill, the "last
yank" pointer moves to the newly made entry at the front of the ring.
<KBD>C-y</KBD> yanks the entry which the "last yank" pointer points to.
<KBD>M-y</KBD> moves the "last yank" pointer to a different entry, and the
text in the buffer changes to match.  Enough <KBD>M-y</KBD> commands can move
the pointer to any entry in the ring, so you can get any entry into the
buffer.  Eventually the pointer reaches the end of the ring; the next
<KBD>M-y</KBD> loops back around to the first entry again.
</P><P>

  <KBD>M-y</KBD> moves the "last yank" pointer around the ring, but it does
not change the order of the entries in the ring, which always runs from
the most recent kill at the front to the oldest one still remembered.
</P><P>

  <KBD>M-y</KBD> can take a numeric argument, which tells it how many entries
to advance the "last yank" pointer by.  A negative argument moves the
pointer toward the front of the ring; from the front of the ring, it
moves "around" to the last entry and continues forward from there.
</P><P>

  Once the text you are looking for is brought into the buffer, you can
stop doing <KBD>M-y</KBD> commands and it will stay there.  It's just a copy
of the kill ring entry, so editing it in the buffer does not change
what's in the ring.  As long as no new killing is done, the "last
yank" pointer remains at the same place in the kill ring, so repeating
<KBD>C-y</KBD> will yank another copy of the same previous kill.
</P><P>

  If you know how many <KBD>M-y</KBD> commands it would take to find the
text you want, you can yank that text in one step using <KBD>C-y</KBD> with
a numeric argument.  <KBD>C-y</KBD> with an argument restores the text from
the specified kill ring entry, counting back from the most recent as
1.  Thus, <KBD>C-u 2 C-y</KBD> gets the next-to-the-last block of killed
text--it is equivalent to <KBD>C-y M-y</KBD>.  <KBD>C-y</KBD> with a numeric
argument starts counting from the "last yank" pointer, and sets the
"last yank" pointer to the entry that it yanks.
</P><P>

<A NAME="IDX278"></A>
  The length of the kill ring is controlled by the variable
<CODE>kill-ring-max</CODE>; no more than that many blocks of killed text are
saved.
</P><P>

<A NAME="IDX279"></A>
  The actual contents of the kill ring are stored in a variable named
<CODE>kill-ring</CODE>; you can view the entire contents of the kill ring with
the command <KBD>C-h v kill-ring</KBD>.
</P><P>

<A NAME="Accumulating Text"></A>
<HR SIZE="6">
<A NAME="SEC67"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC66"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC68"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC63"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC68"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> H.9 Accumulating Text </H2>
<!--docid::SEC67::-->
<P>

<A NAME="IDX280"></A>
  Usually we copy or move text by killing it and yanking it, but there
are other methods convenient for copying one block of text in many
places, or for copying many scattered blocks of text into one place.  To
copy one block to many places, store it in a register
(see section <A HREF="emacs_12.html#SEC69">I. Registers</A>).  Here we describe the commands to accumulate
scattered pieces of text into a buffer or into a file.
</P><P>

<DL COMPACT>
<DT><KBD>M-x append-to-buffer</KBD>
<DD>Append region to the contents of a specified buffer.
<DT><KBD>M-x prepend-to-buffer</KBD>
<DD>Prepend region to the contents of a specified buffer.
<DT><KBD>M-x copy-to-buffer</KBD>
<DD>Copy region into a specified buffer, deleting that buffer's old contents.
<DT><KBD>M-x insert-buffer</KBD>
<DD>Insert the contents of a specified buffer into current buffer at point.
<DT><KBD>M-x append-to-file</KBD>
<DD>Append region to the contents of a specified file, at the end.
</DL>
<P>

  To accumulate text into a buffer, use <KBD>M-x append-to-buffer</KBD>.
This reads a buffer name, then inserts a copy of the region into the
buffer specified.  If you specify a nonexistent buffer,
<CODE>append-to-buffer</CODE> creates the buffer.  The text is inserted
wherever point is in that buffer.  If you have been using the buffer for
editing, the copied text goes into the middle of the text of the buffer,
starting from wherever point happens to be at that moment.
</P><P>

  Point in that buffer is left at the end of the copied text, so
successive uses of <CODE>append-to-buffer</CODE> accumulate the text in the
specified buffer in the same order as they were copied.  Strictly
speaking, <CODE>append-to-buffer</CODE> does not always append to the text
already in the buffer--it appends only if point in that buffer is at the end.
However, if <CODE>append-to-buffer</CODE> is the only command you use to alter
a buffer, then point is always at the end.
</P><P>

  <KBD>M-x prepend-to-buffer</KBD> is just like <CODE>append-to-buffer</CODE>
except that point in the other buffer is left before the copied text, so
successive prependings add text in reverse order.  <KBD>M-x
copy-to-buffer</KBD> is similar, except that any existing text in the other
buffer is deleted, so the buffer is left containing just the text newly
copied into it.
</P><P>

  To retrieve the accumulated text from another buffer, use the
command <KBD>M-x insert-buffer</KBD>; this too takes <VAR>buffername</VAR> as an
argument.  It inserts a copy of the whole text in buffer
<VAR>buffername</VAR> into the current buffer at point, and sets the mark
after the inserted text.  Alternatively, you can select the other
buffer for editing, then copy text from it by killing.
See section <A HREF="emacs_17.html#SEC172">N. Using Multiple Buffers</A>, for background information on buffers.
</P><P>

  Instead of accumulating text within Emacs, in a buffer, you can append
text directly into a file with <KBD>M-x append-to-file</KBD>, which takes
<VAR>filename</VAR> as an argument.  It adds the text of the region to the end
of the specified file.  The file is changed immediately on disk.
</P><P>

  You should use <CODE>append-to-file</CODE> only with files that are
<EM>not</EM> being visited in Emacs.  Using it on a file that you are
editing in Emacs would change the file behind Emacs's back, which
can lead to losing some of your editing.
</P><P>

<A NAME="Rectangles"></A>
<HR SIZE="6">
<A NAME="SEC68"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC67"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_12.html#SEC69"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC67"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_12.html#SEC69"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> H.10 Rectangles </H2>
<!--docid::SEC68::-->
<P>

  The rectangle commands operate on rectangular areas of the text: all
the characters between a certain pair of columns, in a certain range of
lines.  Commands are provided to kill rectangles, yank killed rectangles,
clear them out, fill them with blanks or text, or delete them.  Rectangle
commands are useful with text in multicolumn formats, and for changing
text into or out of such formats.
</P><P>

  When you must specify a rectangle for a command to work on, you do it
by putting the mark at one corner and point at the opposite corner.  The
rectangle thus specified is called the <EM>region-rectangle</EM> because
you control it in much the same way as the region is controlled.  But
remember that a given combination of point and mark values can be
interpreted either as a region or as a rectangle, depending on the
command that uses them.
</P><P>

  If point and the mark are in the same column, the rectangle they
delimit is empty.  If they are in the same line, the rectangle is one
line high.  This asymmetry between lines and columns comes about
because point (and likewise the mark) is between two columns, but within
a line.
</P><P>

<DL COMPACT>
<DT><KBD>C-x r k</KBD>
<DD>Kill the text of the region-rectangle, saving its contents as the 
"last killed rectangle" (<CODE>kill-rectangle</CODE>).
<DT><KBD>C-x r d</KBD>
<DD>Delete the text of the region-rectangle (<CODE>delete-rectangle</CODE>).
<DT><KBD>C-x r y</KBD>
<DD>Yank the last killed rectangle with its upper left corner at point
(<CODE>yank-rectangle</CODE>).
<DT><KBD>C-x r o</KBD>
<DD>Insert blank space to fill the space of the region-rectangle
(<CODE>open-rectangle</CODE>).  This pushes the previous contents of the
region-rectangle rightward.
<DT><KBD>M-x clear-rectangle</KBD>
<DD>Clear the region-rectangle by replacing its contents with spaces.
<DT><KBD>M-x delete-whitespace-rectangle</KBD>
<DD>Delete whitespace in each of the lines on the specified rectangle,
starting from the left edge column of the rectangle.
<DT><KBD>C-x r t <VAR>string</VAR> <KBD>RET</KBD></KBD>
<DD>Replace rectangle contents with <VAR>string</VAR> on each line.
(<CODE>string-rectangle</CODE>).
<DT><KBD>M-x string-insert-rectangle <KBD>RET</KBD> <VAR>string</VAR> <KBD>RET</KBD></KBD>
<DD>Insert <VAR>string</VAR> on each line of the rectangle.
</DL>
<P>

  The rectangle operations fall into two classes: commands for
deleting and inserting rectangles, and commands for blank rectangles.
</P><P>

<A NAME="IDX281"></A>
<A NAME="IDX282"></A>
<A NAME="IDX283"></A>
<A NAME="IDX284"></A>
  There are two ways to get rid of the text in a rectangle: you can
discard the text (delete it) or save it as the "last killed"
rectangle.  The commands for these two ways are <KBD>C-x r d</KBD>
(<CODE>delete-rectangle</CODE>) and <KBD>C-x r k</KBD> (<CODE>kill-rectangle</CODE>).  In
either case, the portion of each line that falls inside the rectangle's
boundaries is deleted, causing any following text on the line to
move left into the gap.
</P><P>

  Note that "killing" a rectangle is not killing in the usual sense; the
rectangle is not stored in the kill ring, but in a special place that
can only record the most recent rectangle killed.  This is because yanking
a rectangle is so different from yanking linear text that different yank
commands have to be used and yank-popping is hard to make sense of.
</P><P>

<A NAME="IDX285"></A>
<A NAME="IDX286"></A>
  To yank the last killed rectangle, type <KBD>C-x r y</KBD>
(<CODE>yank-rectangle</CODE>).  Yanking a rectangle is the opposite of killing
one.  Point specifies where to put the rectangle's upper left corner.
The rectangle's first line is inserted there, the rectangle's second
line is inserted at the same horizontal position, but one line
vertically down, and so on.  The number of lines affected is determined
by the height of the saved rectangle.
</P><P>

  You can convert single-column lists into double-column lists using
rectangle killing and yanking; kill the second half of the list as a
rectangle and then yank it beside the first line of the list.
See section <A HREF="emacs_32.html#SEC463">AC.23 Two-Column Editing</A>, for another way to edit multi-column text.
</P><P>

  You can also copy rectangles into and out of registers with <KBD>C-x r
r <VAR>r</VAR></KBD> and <KBD>C-x r i <VAR>r</VAR></KBD>.  See section <A HREF="emacs_12.html#SEC72">Rectangle Registers</A>.
</P><P>

<A NAME="IDX287"></A>
<A NAME="IDX288"></A>
<A NAME="IDX289"></A>
  There are two commands you can use for making blank rectangles:
<KBD>M-x clear-rectangle</KBD> which blanks out existing text, and <KBD>C-x r
o</KBD> (<CODE>open-rectangle</CODE>) which inserts a blank rectangle.  Clearing a
rectangle is equivalent to deleting it and then inserting a blank
rectangle of the same size.
</P><P>

<A NAME="IDX290"></A>
  The command <KBD>M-x delete-whitespace-rectangle</KBD> deletes horizontal
whitespace starting from a particular column.  This applies to each of
the lines in the rectangle, and the column is specified by the left
edge of the rectangle.  The right edge of the rectangle does not make
any difference to this command.
</P><P>

<A NAME="IDX291"></A>
<A NAME="IDX292"></A>
  The command <KBD>C-x r t</KBD> (<CODE>string-rectangle</CODE>) replaces the
contents of a region-rectangle with a string on each line.  The
string's width need not be the same as the width of the rectangle.  If
the string's width is less, the text after the rectangle shifts left;
if the string is wider than the rectangle, the text after the
rectangle shifts right.
</P><P>

<A NAME="IDX293"></A>
  The command <KBD>M-x string-insert-rectangle</KBD> is similar to 
<CODE>string-rectangle</CODE>, but inserts the string on each line, 
shifting the original text to the right.
<A NAME="Registers"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_11.html#SEC67"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_12.html#SEC69"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated
on <I>April 2, 2002</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
