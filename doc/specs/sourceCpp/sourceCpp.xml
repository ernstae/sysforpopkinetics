<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                  "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd"[
  <!ENTITY uw "University of Washington">
  <!ENTITY dept "Department of Bioengineering">
]>
<article>
   <title>SPK Compiler Output (C++)</title>
   <articleinfo>
      <revhistory>
         <revision>
            <revnumber>1.16</revnumber>
            <date>November, 2004</date>
            <authorinitials>sh</authorinitials>
            <revremark>
            Specifying the return value of fitDriver.cpp and monteDriver.cpp.
            </revremark>
         </revision>
         <revision>
            <revnumber>1.15</revnumber>
            <date>September 30, 2004</date>
            <authorinitials>sh</authorinitials>
            <revremark>
            Specifying fixing elements of THETA.
            </revremark>
         </revision>
         <revision>
            <revnumber>1.14</revnumber>
            <date>September 8, 2004</date>
            <authorinitials>sh</authorinitials>
            <revremark>
            Replaced DataSet::xmlOut() with DataSet::operator<<().
            </revremark>
         </revision>
         <revision>
            <revnumber>1.13</revnumber>
            <date>September 8, 2004</date>
            <authorinitials>sh</authorinitials>
            <revremark>
            Added an explanation for IndData::getMeasurements() from the class client's perspective.
            </revremark>
         </revision>
         <revision>
            <revnumber>1.12</revnumber>
            <date>September 8, 2004</date>
            <authorinitials>sh</authorinitials>
            <revremark>
            The data type of DataSet::getAllMeasurements() and DataSet::getN()
            were specified incorrectly.  They were said std::vector, but
            acturally are std::valarray.
            </revremark>
         </revision>
         <revision>
            <revnumber>1.11</revnumber>
            <date>September 8, 2004</date>
            <authorinitials>sh</authorinitials>
            <revremark>
            Added a description for DataSet::DataSet().
            </revremark>
         </revision>
         <revision>
            <revnumber>1.10</revnumber>
            <date>September 7, 2004</date>
            <authorinitials>sh</authorinitials>
            <revremark>A &gt; was flipped around.
            </revremark>
         </revision>
         <revision>
            <revnumber>1.9</revnumber>
            <date>September 7, 2004</date>
            <authorinitials>sh</authorinitials>
            <revremark>DataSet::getN(), DataSet::getAllMeasurements(), DataSet::getPopSize(), DataSet()::xmlOut()
            </revremark>
         </revision>
         <revision>
            <revnumber>1.8</revnumber>
            <date>September 2, 2004</date>
            <authorinitials>sh</authorinitials>
            <revremark>Corrected the description for DataSet::getAllMeasurements().
            </revremark>
         </revision>
         <revision>
            <revnumber>1.7</revnumber>
            <date>August 3, 2004</date>
            <authorinitials>sh</authorinitials>
            <revremark>Explanations for Makefile.SPK and Monte Carlo related topics</revremark>
         </revision>
         <revision>
            <revnumber>1.6</revnumber>
            <date>July 1, 2004</date>
            <authorinitials>sh</authorinitials>
            <revremark>Complete reorganization.</revremark>
         </revision>
         <revision>
            <revnumber>1.5</revnumber>
            <date>April 6, 2004</date>
            <authorinitials>sh</authorinitials>
            <revremark>Updated the doc re. $PRED: Pred class derived from PredBase.</revremark>
         </revision>
         <revision>
            <revnumber>1.4</revnumber>
            <date>March 13, 2004</date>
            <authorinitials>alan</authorinitials>
            <revremark>Changes to move documentation to web server.</revremark>
         </revision>
         <revision>
            <revnumber>1.3</revnumber>
            <date>January 6, 2004</date>
            <authorinitials>alan</authorinitials>
            <revremark>Changed version of Docbook DTD from 4.1.2 to 4.2 in all .xml files</revremark>
         </revision>
         <revision>
            <revnumber>1.2</revnumber>
            <date>January 5, 2004</date>
            <authorinitials>alan</authorinitials>
            <revremark>Clean up.</revremark>
         </revision>
         <revision>
	    <revnumber>1.1</revnumber>
	    <date>December 8, 2003</date>
	    <authorinitials>sh</authorinitials>
	    <revremark>Initial version.</revremark>
         </revision>
      </revhistory>
      <abstract>
         <para>
SPK Compiler assembles information from a given pair of 
<ulink url="../sourceML/sourceML.html">SpkSourceML</ulink> and 
<ulink url="../dataML/dataML.html">SpkDataML</ulink> documents
and translates it to C++ source code.  The source code is organized into several
logical units and saved in files (.cpp and .h).  In this documentation,
you will find the descriptions and specifications of 
these logical units and their corresponding file names, and
the pieces of information (publically) available from these units.
         </para>
         <para>
For the terms, 
<emphasis>theta</emphasis>, <emphasis>Omega</emphasis>, <emphasis>eta</emphasis>,
<emphasis>Sigma</emphasis> and <emphasis>eps</emphasis>, refer to NONMEM manuals.
         </para>
     </abstract>
   </articleinfo>
   <sect1>
      <title>Related Articles</title>
      <para>
         <itemizedlist>
            <listitem>
               <para>
                  <ulink url="../modelCap/modelCap.tex">
                  Modeling Capabilities Specification</ulink>
               </para>
            </listitem>
            <listitem>
               <para>
                  <ulink url="../sourceML/sourceML.html">SpkSourceML</ulink>
               </para>
            </listitem>
            <listitem>
               <para>
                  <ulink url="../dataML/dataML.html">SpkDataML</ulink>
               </para>
            </listitem>
         </itemizedlist>
      </para>
   </sect1>
   <sect1>
      <title><filename>NonmemPars.h</filename></title>
      <para>
      This header file exports a namespace, <literal>NonmemPars</literal>, containing
      C++ translation of NONMEM control parameters. Most of the parameters declared within this
      namespace are originated directly from the given SpkSourceML document.
      Some extra information may be provided in the namespace as well.  
      They are values SPK Compiler could statically derive from the given parameters.

      Not all user-given control parameters are present in the namespace.
      If you, an SPK application developer, finds a piece of information missing
      from this namespace, please contact 
      <ulink url="mailto:honda99@u.washington.edu">honda99@u.washington.edu</ulink>.
      </para>
      <variablelist>
         <title>Namespace Entries</title>
         <varlistentry>
            <term><literal>const int nTheta</literal></term>
            <listitem>
               <para>
               is the length of <emphasis>theta</emphasis> vector.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const valarray&lt;double&gt; thetaUp</literal></term>
            <listitem>
               <para>
               contains the upper boundary value for <emphasis>theta</emphasis>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const valarray&lt;double&gt; thetaLow</literal></term>
            <listitem>
               <para>
               contains the lower boundary value for <emphasis>theta</emphasis>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const valarray&lt;double&gt; thetaIn</literal></term>
            <listitem>
               <para>
               contains the initial estimate for <emphasis>theta</emphasis>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const valarray&lt;double&gt; thetaFixed</literal></term>
            <listitem>
               <para>
               contains a vector of boolean flags telling the corresponding i-th element of 
               <emphasis>theta</emphasis> is fixed to the initial estimate value.
               <literal>thetaFixed[i]</literal> = true tells <emphasis>theta(i+1)</emphasis> is
               fixed.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const int nEta</literal></term>
            <listitem>
               <para>
               is the length of <emphasis>eta</emphasis> vector, 
               which determines the dimension of <emphasis>Omega</emphasis>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const valarray&lt;double&gt; etaIn</literal></term>
            <listitem>
               <para>
               is the initial estimate for <emphasis>eta</emphasis>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const enum PopPredModel::covStruct omegaStruct</literal></term>
            <listitem>
               <para>
               is present only if the <emphasis>population analysis</emphasis>
               is requested in the given SpkSourceML document.
               The value is either <varname>PopPredModel::DIAGONAL</varname> or 
               <varname>PopPredModel::FULL</varname>.
               <varname>DIAGONAL</varname> indicates that only the diagonal elements of 
               <emphasis>Omega</emphasis> matrix
               are subject to optimization.  <varname>FULL</varname> indicates that potentially all elements
               are subject to optimization (but remember, <emphasis>Omega</emphasis> is symmetric).
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const enum IndPredModel::covStruct omegaStruct</literal></term>
            <listitem>
               <para>
               is present only if the <emphasis>individual analysis</emphasis>
               is requested in the given SpkSourceML document.
               The value is always <varname>PopPredModel::DIAGONAL</varname> for this type of analysis. 
               <varname>DIAGONAL</varname> indicates that only the diagonal elements of 
               <emphasis>Omega</emphasis> matrix are subject to optimization.  
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const int omegaDim</literal></term>
            <listitem>
               <para>
               is the dimension of <emphasis>Omega</emphasis> (symmetric) matrix.
               ex. for a 3 by 3 matrix, the value here is 3.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const int omegaOrder</literal></term>
            <listitem>
               <para>
               is the number of elements in <emphasis>Omega</emphasis> matrix that are subject to optimization
               (ie. the order of <emphasis>Omega</emphasis>).
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const valarray&lt;double&gt; omegaIn</literal></term>
            <listitem>
               <para>
               is the initial estimates for the elements of <emphasis>Omega</emphasis>
               that are subject to optimization.  Thus, the length of <varname>omegaIn</varname>
               is <literal>omegaOrder</literal>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const int nEps</literal></term>
            <listitem>
               <para>
               is the length of <emphasis>eps</emphasis> vector,
               which determines the dimension of <emphasis>Sigma</emphasis>.
               This field is present only if the <emphasis>population analysis</emphasis> is requested.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const enum PopPredModel::covStruct sigmaStruct</literal></term>
            <listitem>
               <para>
               is present only if the <emphasis>population analysis</emphasis> is requested.
               The value is either <varname>PopPredModel::DIAGONAL</varname>
               or <varname>PopPredModel::FULL</varname>.
               <varname>DIAGONAL</varname> indicates that only the diagonal elements of 
               <emphasis>Sigma</emphasis> matrix
               are subject to optimization.  <varname>FULL</varname> indicates that potentially all elements
               are subject to optimization (but remember, <emphasis>Sigma</emphasis> is symmetric).
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const int sigmaDim</literal></term>
            <listitem>
               <para>
               is the dimension of <emphasis>Sigma</emphasis> (symmetric) matrix.
               ex. For a 3 by 3 matrix, the value here is 3.
               This field is present only if the <emphasis>population analysis</emphasis> is requested.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const int sigmaOrder</literal></term>
            <listitem>
               <para>
               is the number of elements in <emphasis>Sigma</emphasis> matrix that are subject to optimization
               (ie. the order of <emphasis>Sigma</emphasis>).
               This field is present only if the <emphasis>population analysis</emphasis> is requested.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const valarray&lt;double&gt; sigmaIn</literal></term>
            <listitem>
               <para>
               is the initial estimates for the elements of <emphasis>Sigma</emphasis>
               that are subject to optimization.  Thus, the length of <varname>simgaIn</varname>
               is <varname>sigmaOrder</varname>.
               This field is present only if the <emphasis>population analysis</emphasis> is requested.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const int seed</literal></term>
            <listitem>
               <para>
               specifies the seed for random number generation.
               A value < 0 indicates no simulation to be done.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
   </sect1>
   <sect1>
      <title><filename>MontePars.h</filename></title>
      <para>
         This header file exports a namespace, <filename>MontePars</filename> containing
         parameters that control Monte Carlo simulation.
         This file is generated only if <emphasis>Monte Carlo simulation is requested</emphasis>
         from the given SpkSourceML document.
      </para>
      <variablelist>
         <varlistentry>
            <term><literal>const enum { plain, grid, misser, analytic } method</literal></term>
            <listitem>
               <para>specifies the method for approximating (or computing) the integral.
               </para>
               <para>  
               NOTE: Do not assume the order of appearance of enum values
               to be the same as the one appeared in this document!
               <variablelist>
                  <varlistentry>
                     <term><literal>plain</literal></term>
                     <listitem>
                        <para>Monte-Carlo approximation for integral
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>analytic</literal></term>
                     <listitem>
                        <para>Closed form solution only valid for <emphasis>LinearModel</emphasis> 
                        (consult <ulink url="mailto:brad@apl.washington.edu">Brad Bell</ulink> for details)
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>grid</literal></term>
                     <listitem>
                        <para>Approximation integral using evaluation on a uniform grid
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>miser</literal></term>
                     <listitem>
                        <para>Approximation integral using Miser algorithm</para>
                     </listitem>
                  </varlistentry>
               </variablelist>
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const int numberEval</literal></term>
            <listitem>
               <para>
               specifies the number of function evalautions to use for each
               individual in the population.
               Actually it is the maximum number when <varname>method</varname> is
               <literal>grid</literal>.  The value is ignored when <varname>method</varname>
               is <literal>analytic</literal>.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
   </sect1>
   <sect1>
      <title><filename>IndData.h</filename></title>
      <para>
      This header file exports the definition of a template class, <classname>IndData</classname>.
      The class is an abstraction of a set of data records for a single individual.
      Each data record is a s set of <emphasis>at least</emphasis> two data items: DV
      (Dependent Variable) and MDV (Missing Dependent Variable) 
      --- consult NONMEM manuals for further explanation on these terms ---.
      </para>
      <para>
      Those data items which are taken from an experiement shall be made available to the SPK applications as
      read-only.  ID, MDV and DV belong to this category.  
      On the other hand, there may be other values that cannot be determined until the PRED model is evaluated
      at each sampling point.  The class provides (writable) placeholders for convenience 
      for such values as well.
      </para>
      <para>
      Here is an example.  3 measurements were taken from a patient. 
      Her/his data set not only contains 3 data records corresponding to these 3 measurements but also
      an additional record containing only her/his gender information.  The model
      describing the behaviour of the drug is given by:
         <programlisting>
TmP1 = THETA(1) * 2.0
F = TmP1 + ETA(1)
         </programlisting>
      The measurements from the observation unit are described as DVs.
      The sampling points are in the TIME field.
      Then, an <classname>IndData</classname> object would expose read-only vectors of length 
      <varname>n</varname> named <varname>TIME</varname>, <varname>DV</varname> and <varname>MDV</varname>
      and read-write vectors of the same length named <varname>TmP1</varname> and
      <varname>F</varname>.  Plus, it will expose a read-write vector of 
      <varname>4</varname> vectors of length <varname>1</varname> named 
      <varname>THETA</varname> and <varname>ETA</varname>
      (ie. "1" comes from the fact <emphasis>theta</emphasis> and <emphasis>eta</emphasis> 
      vectors have only one element in this example).
      </para>
      <variablelist>
         <title>Public Methods</title>
         <varlistentry>
            <term><literal>const std::valarray&lt;double&gt; getMeasurements() const</literal></term>
            <listitem>
               <para>
               Returns a vector of measurements.  The i-th element of the vector is the i-th measurement
              (ie. the i-th sampling point) within this subject's data set.
               </para>
               <para>
               For programmers, this means that the vector contains only those DV values 
               of which corresponding MDV != 1.
               Thus, the i-th element of the vector is not necessary the DV value 
               from the i-th record.  For example, if there are 10 records among which 1st and 5th records have 
               MDV = 1.  The 1st element of the vector is the DV 
               value from the 2nd record in the original set
               and the 5th element is from the 7th record as demonstrated below:
               <programlisting>
indexes to all records                           : { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }
indexes to those records which have measurements : { 2, 3, 4, 6, 7, 8, 9, 10 }
               </programlisting>
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
      <variablelist>
         <title>Public Properties</title>
         <varlistentry>
            <term><literal>const std::vector&lt;T&gt; <replaceable>xXx</replaceable></literal></term>
            <listitem>
               <para>
               <replaceable>xXx</replaceable> is replaced by a user-given data label 
               such as DV.  The name will be exactly the same as the corresponding 
               data label specified in the given
               SpkSourceML document or SpkDataML document, maintaining upper/lower cases.
               It is a vector of length <varname>n</varname>, where <varname>n</varname>
               is the number of data records for the individual.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>std::vector&lt;T&gt; <replaceable>yYy</replaceable></literal></term>
            <listitem>
               <para>
               <replaceable>yYy</replaceable> is replaced by a PRED item such as <varname>TmP1</varname> 
               in the earlier example.  The name will be exactly the same as the corresponding PRED item name,
               maintaining upper/lower cases.
               It is a vector of length <varname>n</varname>, where <varname>n</varname>
               is the number of data records for the individual.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>std::vector&lt; std::vector&lt;T&gt; &gt; THETA</literal></term>
            <listitem>
               <para>
               A read-write vector of <varname>n</varname> 
               <varname>nTheta</varname>-dimensional vectors, 
               where <varname>n</varname> is the number of data records for the indiviual and
               <varname>nTheta</varname> is the size of <emphasis>theta</emphasis> vector.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>std::vector&lt; std::vector&lt;T&gt; &gt; ETA</literal></term>
            <listitem>
               <para>
               A read-write vector of <varname>n</varname> 
               <varname>nEta</varname>-dimensional vectors, 
               where <varname>n</varname> is the number of data records for the indiviual and
               <varname>nTheta</varname> is the size of <emphasis>eta</emphasis> vector.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>std::vector&lt; std::vector&lt;T&gt; &gt; EPS</literal></term>
            <listitem>
               <para>
               A read-write vector that contains <varname>n</varname> 
               <varname>nEps</varname>-dimensional vectors, 
               where <varname>n</varname> is the number of data records for the indiviual and
               <varname>nTheta</varname> is the size of <emphasis>eps</emphasis> vector.
               <emphasis>This vector is present only if the population analysis is requested.</emphasis>
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
   </sect1>
   <sect1>
      <title><filename>DataSet.h</filename></title>
      <para>
      This header file exports the definition of a template class, <classname>DataSet</classname>.
      The class is an abstraction of data set for the entire population of size > 0.
      It basically bundles all individuals' data sets
      represented by <classname>IndData</classname> objects.  This class's default constructor is responsible
      for filling/initializing the set.  Note that, it is the <emphasis>default</emphasis> constructor
      that does the filling, which means all information are embedded (hard-coded) in the constructor 
      body by SPK Compiler.
      </para>
      <variablelist>
         <title>Constructor</title>
         <varlistentry>
            <term>
            DataSet&lt;class T&gt;::DataSet()
            </term>
            <listitem>
               <para>
               The type of the template parameter is somewhat restrictive at this point.
               <varname>T</varname> has to be a concrete type of <literal>CppAD</literal> template
               class.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
      <variablelist>
         <title>Public Methods</title>
         <varlistentry>
            <term><literal>int getPopSize() const </literal></term>
            <listitem>
               <para>
               Returns the number of individuals in the population.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const std::valarray&lt;double&gt; getAllMeasurements() const</literal></term>
            <listitem>
               <para>
               Returns a vector of measurements from the entire data set for the population.
               Every element of this vector can be subject to data fitting.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const std::valarray&lt;int&gt; getN() const</literal></term>
            <listitem>
               <para>
               Returns a vector of numbers of measurements.  The i-th element of the vector
               indicates the number of measurements for the i-th individual, 
               where 0 &lt;= i &lt; n and
               n is the number of individuals in the population.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>
               <literal>friend std::ostream& operator<<( std::ostream&amp; o, const DataSet&lt;T&gt; A )</literal>
            </term>
            <listitem>
               <para>
               Extracts the data set into <literal>o</literal> in the following format:
<programlisting>
&lt;presentation_data columns="10" rows="12"&gt;
   &lt;data_labels&gt;
      &lt;label name="ID"&gt;
      &lt;label name="TIME"&gt;
      &lt;label name="DV" synonym="CP"&gt;
      ...
   &lt;/data_label&gt;
   &lt;row position=""&gt;
      &lt;value type="double" ref="ID"&gt;
         1
      &lt;/value&gt;
      &lt;value type="double" ref="TIME"&gt;
         0.0
      &lt;/value&gt;
      &lt;value type="double" ref="DV"&gt;
         0.0
      &lt;/value&gt;
      ...
   &lt;/row&gt;
   &lt;row position=""&gt;
      &lt;value type="double" ref="ID"&gt;
         1
      &lt;/value&gt;
      &lt;value type="double" ref="TIME"&gt;
         1.0
      &lt;/value&gt;
      &lt;value type="double" ref="DV"&gt;
         3.0
      &lt;/value&gt;
      ...
   &lt;/row&gt;

&lt;/<replaceable>presentation_data</replaceable>&gt;
</programlisting>
               The order in which &lt;label&gt;s in &lt;data_labels&gt; appear is arbitrary.  
               However, the &lt;value&gt;s in a &lt;row&gt; are guaranteed to be listed
               in the same order as &lt;label&gt;s.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
   </sect1>
   <sect1>
      <title><filename>Pred.h</filename></title>
      <para>
<filename>Pred.h</filename> defines a template class, <classname>Pred</classname>,
which is derived from an abstract class, <classname>PredBase</classname>.
<classname>Pred</classname> is basically a wrapper for $PRED model definition.
The class provides a public interface that allows clients to request an evaluation
of the model at a certain point.
      </para>
      <para>
The definition of $PRED, which is written 
in NM-TRAN (ie. a subset of FORTRAN 77), is translated into C++ and 
inserted into a generated (by SPK Compiler) 
subclass of an existing abstract class, <classname>PredBase</classname>.
<classname>PredBase</classname>
declares a pure virtual member function called <function>eval()</function>,
that is to be implemented.  SPK Compiler produces a C++ source code for
<classname>Pred</classname>, a concrete template sub-class of the abstract
base and store the definition in a file named, <filename>Pred.h</filename>.
The C++ version of PRED definition takes up the core computational portion
of the function implementation.
      </para>
      <sect2>
         <title>Abstract Base Class: <classname>PredBase</classname></title>
         <anchor id="predbase"/>
         <para>
            <classname>PredBase</classname> declares a pure virtual function, 
            <function>eval()</function>.  This function evaluates
            the C++ translation of user's $PRED model for the j-th component of
            the i-th individual's measurement data.  The class <classname>PredBase</classname>
            is part of <varname>spkpred</varname> library and declared in 
            <filename>PredBase.h</filename>.
         </para>
         <programlisting>
// This class is defined in &lt;spk/PredBase.h&gt;.
template &lt;class T&gt;
PredBase{
   public:
      virtual bool eval( int spk_thetaOffset, int spk_thetaLen,
		     int spk_etaOffset,   int spk_etaLen,
		     int spk_epsOffset,   int spk_epsLen,
		     int spk_fOffset,     int spk_fLen,
		     int spk_yOffset,     int spk_yLen,
		     int spk_i,
		     int spk_j,
		     const std::vector&lt;T&gt; & spk_indepVar,
		     std::vector&lt;T&gt; & spk_depVar ) = 0;
      virtual ~PredBase(){}
   protected:
      PredBase(){}
      PredBase( const PredBase& ){}
      PredBase& operator=( const PredBase& ){}
}
         </programlisting>
         <formalpara>
            <title>Requirements</title>
            <para>
               <itemizedlist>
                  <listitem>
                     <para>
At the end of an iteration of population parameter optimization,
a <emphasis>complete</emphasis> set of values assigned 
to the all variables appeared 
on the left hand side of assignment statements in the user's 
PRED model definition, evaluated at every sampling point for 
each individual shall be kept and be available externally.
This implies that the values from the previous iteration shall
be available if the current iteration failed in the middle
of computation.
                     </para>
                  </listitem>  
                  <listitem>
                     <para>
The user's model definition which is in a psudo FORTRAN language
shall retain the case-insensitive attribute when it is translated to C++.
                     </para>
                  </listitem>
                  <listitem>
                     <para>
A prefix <literal>spk_</literal> is reserved for use by SPK Compiler developers.
                     </para>
                  </listitem>
               </itemizedlist>
            </para>
         </formalpara>
         <formalpara>
            <title>Returned Value</title>
            <para>
<literal>true</literal> if the MDV for the corresponding data record ---
the i-th individual's j-th data record --- is 0.  <literal>false</literal> otherwise.
            </para>
         </formalpara>
         <variablelist>
            <title>Arguments</title>
            <varlistentry>
               <term><literal>const int spk_thetaOffset</literal></term>
               <listitem>
	          <para>
                  is the index to the head of <emphasis>theta</emphasis> vector within <varname>spk_indepVar</varname>.
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>const int spk_thetaLen</literal></term>
               <listitem>
                  <para>
                  is the length of <emphasis>theta</emphasis> vector.  The vector elements are assumed to be placed
                  from <varname>spk_indepVar[spk_thetaOffset]</varname> 
                  to <varname>spk_indepVar[spk_theetaOffset + spk_thetaLen]</varname>.
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>const int spk_etaOffset</literal></term>
               <listitem>
                  <para>
                  is the index to the head of <emphasis>eta</emphasis> vector within <varname>spk_indepVar</varname>.
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>const int spk_etaLen</literal></term>
               <listitem>
                  <para>
                  is the length of <emphasis>eta</emphasis> vector.  The vector elements are assumed to be placed
                  from <varname>spk_indepVar[spk_etaOffset]</varname>
                  to <varname>spk_indepVar[spk_etaOffset + spk_etaLen]</varname>.
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>const int spk_epsOffset</literal></term>
               <listitem>
                  <para>
                  is the index to the head of <emphasis>eps</emphasis> vector within <varname>spk_indepVar</varname>.
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>const int spk_epsLen</literal></term>
               <listitem>
                  <para>
                  is the length of <emphasis>eps</emphasis> vector.
                  The vector elements are assumed to be placed
                  from <varname>spk_indepVar[spk_thetaOffset]</varname> 
                  to <varname>spk_indepVar[spk_theetaOffset + spk_theetaLen]</varname>.
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>const int spk_fOffset</literal></term>
               <listitem>
                  <para>
                  is the index to the element in <varname>spk_depVar</varname> in which
                  the prediction for the j-th data record for the i-th individual, 
                  <emphasis>F</emphasis> (in NONMEM's term), shall be placed.
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>const int spk_fLen</literal></term>
               <listitem>
                  <para>
                  is the number of measurements for the i-th individual.
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>const int spk_yOffset</literal></term>
               <listitem>
                  <para>
                  is the index to the element in <varname>spk_depVar</varname> in which
                  the error model value for the j-th data record for the i-th individual,
                  <emphasis>Y</emphasis> (in NONMEM's term), shall be placed.
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>const int spk_yLen</literal></term>
               <listitem>
                  <para>
                  is the number of measurments for the i-th individual..
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>const int spk_i</literal></term>
               <listitem>
                  <para>
                  is the index to the i-th individual 
                  within the population (0 indicates the first individual).
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>const int spk_j</literal></term>
               <listitem>
                  <para>
                  is the index to the j-th data record of the i-th individual.
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>const std::vector&lt;T&gt; & spk_indepVar</literal></term>
               <listitem>
                  <para>
                  is the vector containing independent variables: 
                  <emphasis>theta</emphasis>, <emphasis>eta</emphasis> 
                  and <emphasis>eps</emphasis>.
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>std::vector&lt;T&gt; & spk_depVar</literal></term>
               <listitem>
                  <para>
                  is an output in which the predicted value for the i-th individual's j-th data record
                  will be placed at the <varname>spk_yOffset</varname>-th element.
                  The <literal>spk_yOffset</literal>-th elements will be 
                  are replaced by the error model value for the i-th individual's j-th data record.
                  </para>
               </listitem>
            </varlistentry>
         </variablelist>
      </sect2>
      <sect2>
         <title>An instance of $PRED and <filename>Pred.h</filename></title>
         <anchor id="pred"/>
         <sect3>
            <title>$PRED</title>
            <programlisting>
;THETA(1)=MEAN ABSORPTION RATE CONSTANT (1/HR)
;THETA(2)=MEAN ELIMINATION RATE CONSTANT (1/HR)
;THETA(3)=SLOPE OF CLEARANCE VS WEIGHT RELATIONSHIP (LITERS/HR/KG)
;DOSE=WT-ADJUSTED DOSE (MG/KG)
;DS=NON-WT-ADJUSTED DOSE (MG)

IF (DOSE.NE.0) THEN
   DS=DOSE*WT
   W=WT
ENDIF
KA=THETA(1) + ETA(1)
KE=THETA(2) + ETA(2)
CL=THETA(3) * WT + ETA(3)
D=EXP(-KE*TIME)-EXP(-KA*TIME)
E=CL*(KA-KE)
F=DS*KE*KA/E*D
Y=F+EPS(1)
            </programlisting>
         </sect3>
         <sect3>
            <title><filename>Pred.h</filename></title>
            <programlisting>
#ifndef PRED_H
#define PRED_H

#include &lt;vector&gt;
#include &lt;string&gt;
#include "DataSet.h"
#include "PredBase.h"

template &lt;class T&gt;
class Pred : public PredBase
{
public:
   virtual bool eval( int spk_thetaOffset, int spk_thetaLen,
                      int spk_etaOffset,   int spk_etaLen,
                      int spk_epsOffset,   int spk_epsLen,
                      int spk_fOffset,     int spk_fLen,
                      int spk_yOffset,     int spk_yLen,
                      int spk_i,
                      int spk_j,
                      const std::vector&lt;T&gt;& spk_indepVar,
                      std::vector&lt;T&gt;& spk_depVar );
   Pred( const DataSet&lt;T&gt; * dataIn ){}
   ~Pred(){}

protected:
   Pred(){}
   Pred( const Pred& ){}
   Pred & operator=( const Pred& ){}
private:
   // # of individuals in the population
   const int nIndividuals;

   // A pointer to the data set
   const DataSet&lt;T&gt; *set;

   // temporary placeholders for the user's equations to be able to access
   // the data items freely.
   mutable std::string id;
   mutable T time;
   mutable T cp;
   mutable T dv;
   mutable T wt;
   mutable T dose;
   mutable T mdv;
   mutable T cl;
   mutable T d;
   mutable T ds;
   mutable T e;
   mutable T f;
   mutable T y;
   mutable T ka;
   mutable T ke;
};

template &lt;class T&gt;
bool Pred&lt;T&gt;::eval( int spk_thetaOffset, int spk_thetaLen,
                    int spk_etaOffset,   int spk_etaLen,
                    int spk_epsOffset,   int spk_epsLen,
                    int spk_fOffset,     int spk_fLen,
                    int spk_yOffset,     int spk_yLen,
                    int spk_i,
                    int spk_j,
                    const std::vector&lt;T&gt;& spk_indepVar,
                    std::vector&lt;T&gt;& spk_depVar )
{

   //==================================================================================
   // Preliminaries:
   //
   // Place the data items to temporary variables for easy data access.
   //==================================================================================
   id   = set->data[spk_i]->id[spk_j];
   time = set->data[spk_i]->time[spk_j];
   cp   = set->data[spk_i]->cp[spk_j];
   dv   = set->data[spk_i]->dv[spk_j];
   wt   = set->data[spk_i]->wt[spk_j];
   dose = set->data[spk_i]->dose[spk_j];
   mdv  = set->data[spk_i]->mdv[spk_j];
   typename std::vector&lt;T&gt;::const_iterator theta1 = spk_indepVar.begin() + spk_thetaOffset + 0;
   typename std::vector&lt;T&gt;::const_iterator theta2 = spk_indepVar.begin() + spk_thetaOffset + 1;
   typename std::vector&lt;T&gt;::const_iterator theta3 = spk_indepVar.begin() + spk_thetaOffset + 2;
   typename std::vector&lt;T&gt;::const_iterator eta1   = spk_indepVar.begin() + spk_etaOffset   + 0;
   typename std::vector&lt;T&gt;::const_iterator eta2   = spk_indepVar.begin() + spk_etaOffset   + 1;
   typename std::vector&lt;T&gt;::const_iterator eta3   = spk_indepVar.begin() + spk_etaOffset   + 2;
   typename std::vector&lt;T&gt;::const_iterator eps1   = spk_indepVar.begin() + spk_epsOffset   + 0;
   typename std::vector&lt;T&gt;::const_iterator eps2   = spk_indepVar.begin() + spk_epsOffset   + 1;
   typename std::vector&lt;T&gt;::const_iterator theta  = spk_indepVar.begin() + spk_thetaOffset;
   typename std::vector&lt;T&gt;::const_iterator eta    = spk_indepVar.begin() + spk_etaOffset;
   typename std::vector&lt;T&gt;::const_iterator eps    = spk_indepVar.begin() + spk_epsOffset;
   f = 0.0;
   y = 0.0;

   //==================================================================================
   // Begin User Code                         
   //----------------------------------------------------------------------------------
   // THETA(1)=MEAN ABSORPTION RATE CONSTANT (1/HR)
   // THETA(2)=MEAN ELIMINATION RATE CONSTANT (1/HR)
   // THETA(3)=SLOPE OF CLEARANCE VS WEIGHT RELATIONSHIP (LITERS/HR/kg)
   // DOSE=WT-ADJUSTED DOSE (mg/kg)
   // DS=NON-WT-ADJUSTED DOSE (mg)
   if( dose != 0 )
   {
      ds = dose * wt;
      w = wt;
   }

   ka = theta[ ( 1 ) - 1 ] + eta[ ( 1 ) - 1 ];
   ke = theta[ ( 2 ) - 1 ] + eta[ ( 2 ) - 1 ];
   cl = theta[ ( 3 ) - 1 ] * w + eta[ ( 3 ) - 1 ];
   d = exp( -ke * time ) - exp( -ka * time );
   e = cl * ( ka - ke );
   f = ds * ke * ka / e * d;
   y = f + eps[ ( 1 ) - 1 ];
   //----------------------------------------------------------------------------------
   // End User Code                           
   //==================================================================================


   //==================================================================================
   // Wrap up:
   //
   // Place values to expected locations in given vectors.
   //==================================================================================
   spk_depVar[ spk_fOffset ] = f;
   spk_depVar[ spk_yOffset ] = y;


   //==================================================================================
   // Return:
   //
   // Return true if MDV (missing dependent variable) for this record is false.
   // Otherwise return false (which is not supported for ver 0.1).
   //==================================================================================
   if( set->data[ spk_i ]->mdv[ spk_j ] == 0 )
      return true;
   else 
      return false;
}

#endif
            </programlisting>
         </sect3>
      </sect2>
   </sect1>
   <sect1>
      <title><filename>fitDriver.cpp</filename></title>
      <para>
      This is a driver for data simulation, optimization and statistics 
      computation.
      </para>
      <variablelist>
         <title>Return value</title>
         <varlistentry>
            <term>0</term>
            <listitem>
               <para>
               Successful/normal completion.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>1</term>
            <listitem>
               <para>
               Abnormal completion due to the optimization failure.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>2</term>
            <listitem>
               <para>
               Abnormal completion due to a file/directory access failure.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>4</term>
            <listitem>
               <para>
               Abnormal completion due to the statisitcs calculation failure.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>5</term>
            <listitem>
               <para>
               Abnormal completion dur to the data simulation failure.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>&gt;5</term>
            <listitem>
               <para>
               Abnormal completion for unknown reasons.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
      <variablelist>
         <title>Screen Output</title>
                  <varlistentry>
                     <term>Standard Error</term>
                     <listitem>
                        <para>
<emphasis>Plain</emphasis> error messages that are directed to the standard error and cannot be
caught by the driver normally still go to the standard error.
Such messages may include an error generated as a rusult of violation of an assertion statement.
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term>Standard Output</term>
                     <listitem>
                        <para>
The optimizer's tracing information which is generated for each iteration of
optimization is directed to the standard output as long as tracing level 
is requested to be greater than 0 by the user.  
At the very end of the execution, an exit value is also printed in the following format:
<literal>exit code = INT</literal>, where <literal>INT</literal> is one of the return values defined above.
                        </para>
                     </listitem>
                  </varlistentry>
      </variablelist>
   </sect1>
   <sect1>
      <title><filename>monteDriver.cpp</filename></title>
      <para>
      This is a driver for a post-integration process (ex. Monte Carlo).
      </para>
      <variablelist>
         <title>Return value</title>
         <varlistentry>
            <term>0</term>
            <listitem>
               <para>
               Successful/normal completion.
               </para>
            </listitem>
         </varlistentry>
         <!-- varlistentry>
            <term>1</term>
            <listitem>
               <para>
               Abnormal completion due to the optimization failure.
               </para>
            </listitem>
         </varlistentry -->
         <varlistentry>
            <term>2</term>
            <listitem>
               <para>
               Abnormal completion due to a file/directory access failure.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>3</term>
            <listitem>
               <para>
               Abnormal completion due to the (post-) integration failure.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>&gt;5</term>
            <listitem>
               <para>
               Abnormal completion for unknown reasons.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
   </sect1>
   <sect1>
      <title><filename>Makefile.SPK</filename></title>
      <para>
      The primary goals of this Make file is to define rules to build 
      two versions of executables.  One is an executable hooked to the production
      version of libraries and the other is to the test version of libraries.
      An executable is either for the parameter optimization or for 
      the Monte Carlo integration.
      </para>
      <variablelist>
         <title>Targets</title>
         <varlistentry>
            <term>proc <emphasis>(default)</emphasis></term>
            <listitem>
               <para>
               Compile SPK-Compiler-generated C++ source code files,
               link to <emphasis>production</emphasis> libraries 
               (ie. libspk, libspkpred, and libopt)
               and build a driver, named <filename>driver</filename>.
               The <emphasis>production</emphasis> libraries are expected to be 
               found in <filename>/usr/local/lib/spkprod/</filename>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>test</term>
            <listitem>
               <para>
               Compile SPK-Compiler-generated C++ source code files,
               link to <emphasis>test</emphasis> libraries 
               (ie. libspk, libspkpred, and libopt)
               and build a driver, named <filename>driver</filename>.
               The <emphasis>production</emphasis> libraries are expected to be 
               found in <filename>/usr/local/lib/spktest/</filename>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>clean</term>
            <listitem>
               <para>
               Delete all artifacts generated by SPK Compiler except for itself, 
               <filename>Makefile.SPK</filename>.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
      <variablelist> 
         <title>Source Code Files</title>
         <varlistentry>
            <term>Common source</term>
            <listitem>
               <para>
               The source code files commonly needed by the two processes: optimization and Monte Carlo.
               The files are expected to be found in the current directory.
               </para>
               <para>
                  <itemizedlist>
                     <listitem>
                        <para>NonmemPars.h</para>
                     </listitem>
                     <listitem>
                        <para>IndData.h</para>
                     </listitem>
                     <listitem>
                        <para>DataSet.h</para>
                     </listitem>
                     <listitem>
                        <para>Pred.h</para>
                     </listitem>
                  </itemizedlist>
               </para>                     
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>Optimization-specific source</term>
            <listitem>
               <para>
               The source code file only needed by the optimization process.
               The file is expected to be found in the current directory.
               </para>
               <para>
                  <itemizedlist>
                      <listitem>
                         <para>fitDriver.cpp</para>
                      </listitem>
                  </itemizedlist>
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term>Monte Carlo-specific source</term>
            <listitem>
               <para>
               The source code files only needed by the Monte Carlo process.
               </para>
               <para>
               The following header is expected be found in the current directory.
               </para>
               <para>
                  <itemizedlist>
                     <listitem>
                        <para>MontePars.h</para>
                     </listitem>
                  </itemizedlist>
               </para>
               <para>
               The following files are expected to be found in <filename>/usr/local/src/spktest/ml/</filename>.
               </para>
               <para>
                  <itemizedlist>
                     <listitem>
                        <para>monteDriver.cpp</para>
                     </listitem>
                     <listitem>
                        <para>AnalyticalIntegral.h</para>
                     </listitem>
                     <listitem>
                        <para>AnalyticalIntegral.cpp</para>
                     </listitem>
                     <listitem>
                        <para>GridIntegral.h</para>
                     </listitem>
                     <listitem>
                        <para>GridIntegral.cpp</para>
                     </listitem>
                     <listitem>
                        <para>GridIntegral.h</para>
                     </listitem>
                     <listitem>
                        <para>MapBay.h</para>
                     </listitem>
                     <listitem>
                        <para>MapBay.cpp</para>
                     </listitem>
                     <listitem>
                        <para>MapBay.h</para>
                     </listitem>
                     <listitem>
                        <para>MontePopObj.h</para>
                     </listitem>
                     <listitem>
                        <para>MontePopObj.cpp</para>
                     </listitem>
                  </itemizedlist>                     
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
   </sect1>
</article>
