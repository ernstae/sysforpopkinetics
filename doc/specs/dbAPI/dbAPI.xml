<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                  "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd"[
  <!ENTITY uw "University of Washington">
  <!ENTITY dept "Department of Bioengineering">
  <!ENTITY spkVersion "v0.1">
]>
<article><title>Database API</title>
 <articleinfo>
    <revhistory>
      <revision>
	<revnumber>1.0</revnumber>
	<date>December 12, 2003</date>
	<authorinitials>afw</authorinitials>
	<revremark>Initial version.</revremark>
      </revision>
      <revision>
	<revnumber>1.01</revnumber>
	<date>December 26, 2003</date>
	<authorinitials>afw</authorinitials>
	<revremark>Added 'Side Effects' and Transaction Processing Considerations'.</revremark>
      </revision>
      <revision>
	<revnumber>1.02</revnumber>
	<date>April 6, 2004</date>
	<authorinitials>afw</authorinitials>
	<revremark>Added two functions: get_cmp_jobs and get_run_jobs</revremark>
      </revision>
    </revhistory>
  <abstract>
      <para>
	An Application Programming Interface (API) to the Spk
	Database is defined.  The descriptions in this document
	are independent of any particular programming language.
      </para>
  </abstract>
 </articleinfo>
  <sect1>
    <title>Introduction</title>
    <para>
      A <emphasis>relational database</emphasis>
      plays a central role in the
      architecture of Spk, because it is the means by which the
      major independent components communicate with one another
      and because it is the basis for implementation of a 
      central feature of the design, known as the
      <ulink url="../jobHistory/jobHistory.html">
	Job History Model
      </ulink>.
    </para>
    <para>
      In order to operate a relational database, it is necessary
      to have a
      <emphasis>relational database management system (RDBMS).</emphasis> 
      Because Spk will be distributed under an open source
      license, the open source MySQL RDBMS will be used.
      MySQL has all the features required by Spk and has a very
      large user base.
    </para>
    <para>
      All of the widely used RDBMS share many
      similarities.  They implement certain underlying concepts
      based on the work of E.F.Codd (see for example
      <ulink url="http://www.acm.org/classics/nov95/toc.html">
	A Relational Model of Data for Large Shared Data Banks  
      </ulink>)
      and many others, which define
      what a relational database is and does.  They all 
      provide a high-level interface language known as
      the Structured Query Language (SQL). Most also provide
      standard vendor-independent interfaces based on popular
      programming languages such as C, Java, and Perl.
      These interfaces are known as Application Programming
      Interfaces (API). At a fundamental level, Spk will rely
      on these standard APIs so that it will be possible
      to substitute another RDBMS for MySQL, if necessary.
    </para>
    <para>
      In order to insure the integrity of the database as 
      information is added and modified, it is desirable to 
      limit interactions with the database to a small body of
      well-tested code.  For this reason, Spk includes
      its own high-level API, which caters directly to the
      needs of the MDA, Aspk and Cspk, and hence eliminates
      any need for these components to use the low-level
      APIs directly.  This Spk-specific API is the
      topic of this document.
    </para>
    <para>
      The functions of the Spk API are described
      in a language independent manner.  There are three
      language-specific implementations of the API, known
      as language <emphasis>bindings</emphasis>.
      The Spk Database API has a Java binding, a C
      binding, and a Perl binding to satisfy the needs of the
      MDA, the Aspk and the Cspk, respectively.
    </para>
    <para>
      This specification can be best understood with reference to
      the following related documents:
      <itemizedlist>
	<listitem>
	  <para>
	    <ulink url="../jobHistory/jobHistory.html">
	      Job History Model
	    </ulink>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <ulink url="../erModel/erModel.html">
	      Database Entity-Relationship Model
	    </ulink>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <ulink url="../dbSchema/dbSchema.html">
	      Database Schema
	    </ulink>
	  </para>
	</listitem>
      </itemizedlist>
    </para>
  </sect1>
  <sect1>
    <title>Usage Scenario</title>
    <para>
      When a user decides to run a set of scientific data against
      a model, she calls upon the Spk MDA running on her
      workstation to submit the model and data as a job.  The
      MDA transmits this information across the Internet to a 
      process known as the MDA Surrogate, which runs on a web
      server.  The MDA Surrogate then creates a job by adding
      a row to the <emphasis>job</emphasis> table of the database,
      with the model in the <emphasis>xml_model</emphasis> field
      and the data in the <emphasis>xml_data</emphasis> field.
      The <emphasis>state_code</emphasis> field of this new row
      is set to the value 'q2c'
      thus adding the job to the compiler queue. This queue is a 
      <emphasis>logical</emphasis> entity based on values 
      stored in the <emphasis>job</emphasis> table, rather than
      a <emphasis>physical</emphasis> entity in which records are
      added and deleted.
    </para>
    <para>
      Running independently, either on the machine that runs the
      web server or on some other machine, an idle
      Aspk Compiler queries the compiler queue by searching
      the <emphasis>job</emphasis> table for jobs with 
      <emphasis>state_code</emphasis> equal to 
      'q2c' and selects the
      one which has the
      highest priority.  In a logical sense, it removes the 
      job from the compiler queue when it changes the 
      <emphasis>state_code</emphasis> from
      'q2c' to 'cmp'.
      The job is not removed from the 
      <emphasis>job </emphasis>table, however.  Jobs are
      never deleted from this table. 
    </para>
    <para>
      The process by which the Aspk Compiler selects the highest
      priority job that has <emphasis>state_code</emphasis> equal
      to 'q2c' and changes the 
      <emphasis>state_code</emphasis> to 'cmp' must occur atomically,
      because there may be several instances of the Compiler
      trying to do the same thing simultaneously. 
    </para>
    <para>
      Having selected a job to compile,
      the Aspk Compiler proceeds to transform the model source
      into the C++ language.  If it encounters errors, it
      adds an error report to the <emphasis>report</emphasis>
      field of the job, sets the <emphasis>state_code</emphasis>
      field to 'end' and the <emphasis>end_code</emphasis> field
      to 'cerr'.
      It is then idle and can scan for another job to compile.
    </para>
    <para>
      If the Aspk Compiler succeeds in compiling the model,
      it updates <emphasis>job</emphasis> by storing
      its output in the <emphasis>cpp_source</emphasis> field
      and changing the <emphasis>state_code</emphasis> to
      'q2r'.  The Compiler is then idle and can scan
      for another job to compile.
    </para>
    <para>
      When a Cspk becomes idle, it queries the run
      queue by selecting the highest priority job which has
      <emphasis>state_code</emphasis> equal to 
      'q2r'.  It logically removes the job from
      the queue by setting the <emphasis>state_code</emphasis>
      to 'run'.  The selection and the changing of 
      state must occur as an atomic transaction, because 
      there may be another Cspk process trying to select
      the highest priority job at the same time.
    </para>
    <para>
      When the Cpsk has finished running the job, it updates
      the <emphasis>job</emphasis> table by storing the 
      results of the computation in the <emphasis>report</emphasis>
      field, setting <emphasis>state_code</emphasis> to 'end'
      and <emphasis>end_code</emphasis> to 'srun'.
      The Cspk is then idle and can scan the queue for another
      job to run.
    </para>
    <para>
      The MDA via its MDA Surrogate, periodically queries the
      database to discover whether or not any of its user's
      outstanding jobs have reached the <emphasis>End</emphasis> state.  
      When it discovers that one has, it retrieves the 
      contents of the <emphasis>report</emphasis> field
      and presents them to the user.
    </para>
  </sect1>
  <sect1>
    <title>Functions</title>
    <para>
      In this section the individual API functions will be described.
      Although they are referred to as <emphasis>functions</emphasis> here,
      they are implemented as <emphasis>subroutines</emphasis> in the Perl
      language
      and as <emphasis>class methods</emphasis> in Java. The descriptions
      below define those properties that are independent of language binding.
    </para>
    <sect2>
      <title>Data Types Used in Function Specifications</title>
      <para>
	Data types are language dependent.  Because we
	are dealing with data fields that are defined in SQL, rather than
	Perl or Java, the reader should always consult the 
	<ulink url="../dbSchema/dbSchema.html">
	  Database Schema
	</ulink>
	to understand the true specification of a data item.
      </para>
      <para>
	Here is a glossary of data type names used in the function
	descriptions below:
	<glosslist>
	  <glossentry>
	    <glossterm>database handle</glossterm>
	    <glossdef>
	      <para>
		Typically some sort of reference. Each language binding defines
		a data type which is appropriate.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>pair list</glossterm>
	    <glossdef>
	      <para>
		A container which holds a list of field names and their associated
		field values, or references to names and values, depending on the
		language.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>positive integer</glossterm>
	    <glossdef>
	      <para>
		A whole number, at least 32 bits in length.
	      </para>
	    </glossdef>
	  </glossentry>
 	  <glossentry>
	    <glossterm>row</glossterm>
	    <glossdef>
	      <para>
		A container that can hold a sequence of field values or 
		references to field values, depending on the language.
	      </para>
	    </glossdef>
	  </glossentry>
 	  <glossentry>
	    <glossterm>row-array</glossterm>
	    <glossdef>
	      <para>
		An array of rows.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>string</glossterm>
	    <glossdef>
	      <para>
		A sequence of bytes, this type may contain binary
		data and may be many megabytes in length.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>true, false</glossterm>
	    <glossdef>
	      <para>
		Values which, in a particular language, are appropriate
		for "if" statements.
	      </para>
	    </glossdef>
	  </glossentry>
	</glosslist>
      </para>
    </sect2>
    <sect2>
      <title>Function Specifications</title>
      <sect3>
	<title id="connect">connect -- open a connection to the database</title>
	<glosslist>
	  <glossentry>
	    <glossterm>Synopsis</glossterm>
	    <glossdef>
	      <para>
		handle = connect dbname hostname dbuser dbpassword
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Description</glossterm>
	    <glossdef>
	      <para>
		Connect opens a connection to a database, returning a handle 
		that represents this connection when passed as an argument to
		other functions in the API.  A process may have several
		connections open simultaneously.  Because each connection 
		ties up resources in the RDBMS, it is important to use the
		<emphasis>disconnect</emphasis> function to close a connection
		as soon as it is no longer needed.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Side Effects</glossterm>
	    <glossdef>
	      <para>
		None.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Transaction Processing Considerations</glossterm>
	    <glossdef>
	      <para>
		None.
	      </para>
	    </glossdef>
	  </glossentry>
	</glosslist>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Values returned by connect</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Condition</entry>
		  <entry>Values</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>success</entry>
		  <entry>handle</entry>
		  <entry>Handle to an open database connection.</entry>
		</row>
		<row>
		  <entry>failure</entry>
		  <entry>null or undefined</entry>
		  <entry>
		    Failure occurs when the database user does not have permission to
		    connect to the named database on the given host, when the 
		    password is incorrect, or when the maximum number of handles
		    has been exceeded.  Additional error information is available
		    in the individual language bindings.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Arguments to connect</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Name of Argument</entry>
		  <entry>Data Type</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>dbname</entry>
		  <entry>string</entry>
		  <entry>Name of the relational database.</entry>
		</row>
		<row>
		  <entry>hostname</entry>
		  <entry>string</entry>
		  <entry>
		    Internet host at which from which user
		    is permitted to make a connection.
		  </entry>
		</row>
		<row>
		  <entry>dbuser</entry>
		  <entry>string</entry>
		  <entry>
		    Username for database access. This is not the
		    username of an Spk user.
		  </entry>
		</row>
		<row>
		  <entry>dbpassword</entry>
		  <entry>string</entry>
		  <entry>
		    Password for database access.  This is not the
		    password of an Spk user.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
      </sect3>
      <sect3>
	<title id="disconnect">disconnect -- close a connection to a database</title>
	<glosslist>
	  <glossentry>
	    <glossterm>Synopsis</glossterm>
	    <glossdef>
	      <para>
		r = disconnect handle
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Description</glossterm>
	    <glossdef>
	      <para>
		An open database connection is closed,
		thus releasing resources in the RDBMS.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Side Effects</glossterm>
	    <glossdef>
	      <para>
		None.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Transaction Processing Considerations</glossterm>
	    <glossdef>
	      <para>
		None.
	      </para>
	    </glossdef>
	  </glossentry>
	</glosslist>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Values returned by disconnect</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Condition</entry>
		  <entry>Values</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>success</entry>
		  <entry>true</entry>
		  <entry></entry>
		</row>
		<row>
		  <entry>failure</entry>
		  <entry>false</entry>
		  <entry>
		    Failure can occur if the handle is invalid.  Additional
		    error information is available in the individual language
		    bindings.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Arguments to disconnect</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Name of Argument</entry>
		  <entry>Data Type</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>handle</entry>
		  <entry>database handle</entry>
		  <entry>The handle returned by a previous call to the connect function.</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
      </sect3>
      <sect3>
	<title id="new_job">new_job -- submit a new job</title>
	<glosslist>
	  <glossentry>
	    <glossterm>Synopsis</glossterm>
	    <glossdef>
	      <para>
		job_id = new_job handle user_id abstract dataset_id dataset_version model_id model_version xml_source
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Description</glossterm>
	    <glossdef>
	      <para>
		A new job is created by adding a row to the
		<emphasis>job</emphasis> table.  The
		value of the job_id field of this row is returned.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Side Effects</glossterm>
	    <glossdef>
	      <para>
		The state_code field of the job is set to 'q2c'.
	      </para>
	    </glossdef>
	    <glossdef>
	      <para>
		The event_time field is set to the time of insertion.
	      </para>
	    </glossdef>
	    <glossdef>
	      <para>
		A state transition record is appended to the 
		<emphasis>history</emphasis> table.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Transaction Processing Considerations</glossterm>
	    <glossdef>
	      <para>
		None, assuming that the database supports transactions with 
		autocommit (eg., MySQL database with TYPE=InnoDB) and that
		the <emphasis>job_id</emphasis> field carries the auto_increment
		modifier.
	      </para>
	    </glossdef>
	  </glossentry>
	</glosslist>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Values returned by new_job</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Condition</entry>
		  <entry>Values</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>success</entry>
		  <entry>positive integer</entry>
		  <entry>
		    Unique value of the job_id field of a newly created row in
		    the <emphasis>job</emphasis> table.
		  </entry>
		</row>
		<row>
		  <entry>failure</entry>
		  <entry>0</entry>
		  <entry>
		    Failure occurs if the handle, the user_id, or the model_id are
		    invalid.  Additional error information is available in the
		    individual language bindings.
		 </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Arguments to new_job</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Name of Argument</entry>
		  <entry>Data Type</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>handle</entry>
		  <entry>database handle</entry>
		  <entry>
		    A handle to an open database connection.
		  </entry>
		</row>
		<row>
		  <entry>user_id</entry>
		  <entry>positive integer</entry>
		  <entry>
		    Key to the user's row in the <emphasis>user</emphasis> table.
		  </entry>
		</row>
		<row>
		  <entry>dataset_id</entry>
		  <entry>positive integer</entry>
		  <entry>
		    Key to a row in the <emphasis>dataset</emphasis>
		    table, which contains in its
		    archive field an RCS-compatible archive comprising the
		    current version and all previous versions of a dataset.
		  </entry>
		</row>
		<row>
		  <entry>dataset_version</entry>
		  <entry>string</entry>
		  <entry>
		    RCS version of the dataset.
		  </entry>
		</row>
		<row>
		  <entry>model_id</entry>
		  <entry>positive integer</entry>
		  <entry>
		    Key to a row in the <emphasis>model</emphasis>
		    table, which contains in its
		    archive field an RCS-compatible archive comprising the
		    current version and all previous versions of a model.
		  </entry>
		</row>
		<row>
		  <entry>model_version</entry>
		  <entry>string</entry>
		  <entry>
		    RCS version of the model.
		  </entry>
		</row>
		<row>
		  <entry>xml_source</entry>
		  <entry>string</entry>
		  <entry>
		    An XML document containing source code for the model, 
		    constraints, parameters and presentation directives.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
      </sect3>
      <sect3>
	<title id="job_status">job_status -- return the current state of a job</title>
	<glosslist>
	  <glossentry>
	    <glossterm>Synopsis</glossterm>
	    <glossdef>
	      <para>
		row = job_status handle job_id 
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Description</glossterm>
	    <glossdef>
	      <para>
		The state_code, the event_time of the 
		most recent state transition, and the end_code (which may be null)
		are returned.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Side Effects</glossterm>
	    <glossdef>
	      <para>
		None.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Transaction Processing Considerations</glossterm>
	    <glossdef>
	      <para>
		None.
	      </para>
	    </glossdef>
	  </glossentry>
	</glosslist>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Values returned by job_status</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Condition</entry>
		  <entry>Values</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>success</entry>
		  <entry>row </entry>
		  <entry>
		    state_code, event_time, end_code (end_code will
		    be null unless state_code = 'end')
		  </entry>
		</row>
		<row>
		  <entry>failure</entry>
		  <entry>Null or undefined</entry>
		  <entry>
		    Failure occurs if the handle or job_id is invalid.
		    Additional error information is available in the individual language bindings.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Arguments to job_status</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Name of Argument</entry>
		  <entry>Data Type</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>handle</entry>
		  <entry>database handle</entry>
		  <entry>Handle to an open database connection.</entry>
		</row>
		<row>
		  <entry>job_id</entry>
		  <entry>positive integer</entry>
		  <entry>
		    Key to a row in the <emphasis>job</emphasis> table.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
      </sect3>
      <sect3>
	<title id="job_history">job_history -- retrieve history for a given job</title>
	<glosslist>
	  <glossentry>
	    <glossterm>Synopsis</glossterm>
	    <glossdef>
	      <para>
		row-array = job_history handle job_id
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Description</glossterm>
	    <glossdef>
	      <para>
		All rows of the history table that correspond to a given job_id are
		returned.  Each row describes a state transition.
	      </para>
	    </glossdef>
	  </glossentry>
	</glosslist>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Values returned by job_history</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="1*"/>
	      <colspec colname="c2" colwidth="1*"/>
	      <colspec colname="c3" colwidth="5*"/>
	      <thead>
		<row>
		  <entry>Condition</entry>
		  <entry>Values</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>success</entry>
		  <entry>row-array</entry>
		  <entry>An array containing all history for the given job</entry>
		</row>
		<row>
		  <entry>failure</entry>
		  <entry>Null or undefined.</entry>
		  <entry>
		     Failure occurs if their is no history for the job_id.
		    Additional error information depends on the individual
		    language bindings.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Arguments to job_history</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="1*"/>
	      <colspec colname="c2" colwidth="1*"/>
	      <colspec colname="c3" colwidth="5*"/>
	      <thead>
		<row>
		  <entry>Name of Argument</entry>
		  <entry>Data Type</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>handle</entry>
		  <entry>database handle</entry>
		  <entry>Handle to an open database connection.</entry>
		</row>
		<row>
		  <entry>job_id</entry>
		  <entry>positive integer</entry>
		  <entry>Key to a row in the job table.</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
      </sect3>
      <sect3>
	<title id="get_job">get_job -- retrieve a row from the job table</title>
	<glosslist>
	  <glossentry>
	    <glossterm>Synopsis</glossterm>
	    <glossdef>
	      <para>
		row = get_job handle job_id
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Description</glossterm>
	    <glossdef>
	      <para>
		This function retrieves the entire row from the job table that corresponds
		to the given job_id.  
	      </para>
	    </glossdef>
	  </glossentry>
	</glosslist>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Values returned by get_job</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="1*"/>
	      <colspec colname="c2" colwidth="1*"/>
	      <colspec colname="c3" colwidth="5*"/>
	      <thead>
		<row>
		  <entry>Condition</entry>
		  <entry>Values</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>success</entry>
		  <entry>row</entry>
		  <entry>An entire row of the job table.</entry>
		</row>
		<row>
		  <entry>failure</entry>
		  <entry>null or undefined</entry>
		  <entry>
		    The case where there is no row corresponding to the
		    job id is distinguishable from a failure due to 
		    database error.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Arguments to get_job</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="1*"/>
	      <colspec colname="c2" colwidth="1*"/>
	      <colspec colname="c3" colwidth="5*"/>
	      <thead>
		<row>
		  <entry>Name of Argument</entry>
		  <entry>Data Type</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>handle</entry>
		  <entry>database handle</entry>
		  <entry>Handle to an open database connection.</entry>
		</row>
		<row>
		  <entry>job_id</entry>
		  <entry>positive integer</entry>
		  <entry>A valid key to the job table.</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
      </sect3>
      <sect3>
	<title id="user_jobs">user_jobs -- get status for user's most recent jobs</title>
	<glosslist>
	  <glossentry>
	    <glossterm>Synopsis</glossterm>
	    <glossdef>
	      <para>
		row-array = user_jobs handle user_id maxnum
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Description</glossterm>
	    <glossdef>
	      <para>
		Returns an array of rows, each of which contains the
		current status of one of a given user's jobs.  Jobs are
		sorted in reverse order of job_id, hence the most recently
		submitted job appears first. The  maximum number of jobs to
		return is given as one of the arguments.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Side Effects</glossterm>
	    <glossdef>
	      <para>
		None.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Transaction Processing Considerations</glossterm>
	    <glossdef>
	      <para>
		None, assuming that the database supports consistent reads
		(as does MySQL database, with type=InnoDB).
	      </para>
	    </glossdef>
	  </glossentry>
	</glosslist>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Values returned by user-jobs</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Condition</entry>
		  <entry>Values</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>success</entry>
		  <entry>row-array</entry>
		  <entry>In each row: job_id, abstract, state_code, start_time, event_time, end_code</entry>
		</row>
		<row>
		  <entry>failure</entry>
		  <entry>null or undefined</entry>
		  <entry>
		    Failure occurs if the handle or user_id is invalid.
		    Additional error information is available in the
		    individual language bindings.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Arguments to user_jobs</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Name of Argument</entry>
		  <entry>Data Type</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>handle</entry>
		  <entry>database handle</entry>
		  <entry>Handle to an open database connection.</entry>
		</row>
		<row>
		  <entry>user_id</entry>
		  <entry>positive integer</entry>
		  <entry>
		    Key to the user's row in the <emphasis>user</emphasis> table.
		  </entry>
		</row>
		<row>
		  <entry>maxnum</entry>
		  <entry>positive integer</entry>
		  <entry>
		    Maximum number of rows to be returned. For example, if only
		    the status of the most recent job is desired, this argument
		    would have the value 1.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
      </sect3>
      <sect3>
	<title id="de_q2c">de_q2c -- select highest priority job from compiler queue</title>
	<glosslist>
	  <glossentry>
	    <glossterm>Synopsis</glossterm>
	    <glossdef>
	      <para>
		row = de_q2c handle
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Description</glossterm>
	    <glossdef>
	      <para>
		The <emphasis>job</emphasis> table is queried to find the
		highest priority job with state_code equal to 'q2c'.
		If the queue is not empty, the fields needed by the Aspk
		Compiler are returned.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Side Effects</glossterm>
	    <glossdef>
	      <para>
		The state code field of the job is set to cmp.
	      </para>
	    </glossdef>
	    <glossdef>
	      <para>
		The event_time field is updated to the time of this state transition.		      
	      </para>
	    </glossdef>
	    <glossdef>
	      <para>
		A state transition record is added to the 
		<emphasis>history</emphasis> table.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Transaction Processing Considerations</glossterm>
	    <glossdef>
	      <para>
		The work of this function is performed within transaction state,
		between a <command>begin</command> database command and a 
		<command>commit</command>.  The job is found by using a 
		<command>select for update</command> command. In case of error,
		the functions performs a <command>rollback</command> before
		exiting.
	      </para>
	    </glossdef>
	  </glossentry>
	</glosslist>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Values returned by de_q2c</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Condition</entry>
		  <entry>Values</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>success</entry>
		  <entry>row </entry>
		  <entry>job_id, dataset_id, dataset_version, xml_source</entry>
		</row>
		<row>
		  <entry>failure</entry>
		  <entry>null or undefined</entry>
		  <entry>
		    Information that can be used to differentiate between
		    an empty queue and an error condition such as an invalid
		    handle is provided by the individual language bindings.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Arguments to de_q2c</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Name of Argument</entry>
		  <entry>Data Type</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>handle</entry>
		  <entry>database handle</entry>
		  <entry>Handle to an open database connection.</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
      </sect3>
      <sect3>
	<title id="get_cmp_jobs">get_cmp_jobs -- get all jobs currently being compiled</title>
	<glosslist>
	  <glossentry>
	    <glossterm>Synopsis</glossterm>
	    <glossdef>
	      <para>
		row-array = get_cmp_jobs handle
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Description</glossterm>
	    <glossdef>
	      <para>
		An array of rows containing all jobs with state_code = 'cmp' is returned.
		The rows contain the fields job_id, dataset_id and xml_source.  This 
		function would typically be called by the compiler deamon upon starting
		up, in order to discover any jobs which were being compiled when the
		the compiler sub-system was shut down, so that those jobs could be compiled
		again.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Side Effects</glossterm>
	    <glossdef>
	      <para>
		None.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Transaction Processing Considerations</glossterm>
	    <glossdef>
	      <para>
		None.
	      </para>
	    </glossdef>
	  </glossentry>
	</glosslist>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Values returned by get_cmp_jobs</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="1*"/>
	      <colspec colname="c2" colwidth="1*"/>
	      <colspec colname="c3" colwidth="5*"/>
	      <thead>
		<row>
		  <entry>Condition</entry>
		  <entry>Values</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>success</entry>
		  <entry>row-array</entry>
		  <entry>In each row: job_id, dataset_id, dataset_version, and xml_source</entry>
		</row>
		<row>
		  <entry>failure</entry>
		  <entry>null or undefined</entry>
		  <entry>
		    Information that can be used to differentiate between a select
		    that returns the empty set and a database error condition is 
		    provided by the individual language bindings.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Arguments to get_cmp_jobs</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="1*"/>
	      <colspec colname="c2" colwidth="1*"/>
	      <colspec colname="c3" colwidth="5*"/>
	      <thead>
		<row>
		  <entry>Name of Argument</entry>
		  <entry>Data Type</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>handle</entry>
		  <entry>database handle</entry>
		  <entry>Handle to an open database connection.</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
      </sect3>
      <sect3>
	<title id="en_q2r">en_q2r -- add a compiled job to the run queue</title>
	<glosslist>
	  <glossentry>
	    <glossterm>Synopsis</glossterm>
	    <glossdef>
	      <para>
		r = en_q2r handle job_id cpp_source
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Description</glossterm>
	    <glossdef>
	      <para>
		The Aspk Compiler uses this function to move a 
		job that it has compiled to the queue of jobs 
		that are ready to be run by the Cspk.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Side Effects</glossterm>
	    <glossdef>
	      <para>
		The state_code field of the job is changed to 'q2r'.
	      </para>
	    </glossdef>
	    <glossdef>
	      <para>
		The cpp_source field of the job contains c++ source code.
	      </para>
	    </glossdef>
	    <glossdef>
	      <para>
		The event_time field is updated to the time of this state transition.
	      </para>
	    </glossdef>
	    <glossdef>
	      <para>
		A state transition record is added to the
		<emphasis>history</emphasis> table.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Transaction Processing Considerations</glossterm>
	    <glossdef>
	      <para>
		None, assuming that the database supports updates with autocommit
		(eg. MySQL with type=InnoDB).
	      </para>
	    </glossdef>
	  </glossentry>
	</glosslist>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Values returned by en_q2r</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Condition</entry>
		  <entry>Values</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>success</entry>
		  <entry>true</entry>
		  <entry></entry>
		</row>
		<row>
		  <entry>failure</entry>
		  <entry>false</entry>
		  <entry>
		    Failure occurs if the handle or job_id is invalid.
		    Additional error information is available in the
		    individual language bindings.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Arguments to en_q2r</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Name of Argument</entry>
		  <entry>Data Type</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>handle</entry>
		  <entry>database handle</entry>
		  <entry>A handle to an open database connection.</entry>
		</row>
		<row>
		  <entry>job_id</entry>
		  <entry>positive integer</entry>
		  <entry>
		    Key to a row in the <emphasis>job</emphasis> table.
		  </entry>
		</row>
		<row>
		  <entry>cpp_source</entry>
		  <entry>string</entry>
		  <entry>
		    An archive of text files in compressed tar format.  
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
      </sect3>
      <sect3>
	<title id="de_q2r">de_q2r -- select the highest priority job from the run queue</title>
	<glosslist>
	  <glossentry>
	    <glossterm>Synopsis</glossterm>
	    <glossdef>
	      <para>
		row = de_q2r handle
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Description</glossterm>
	    <glossdef>
	      <para>
		The <emphasis>job</emphasis> table is queried for the highest
		priority job with state_code equal to 'q2r'.  If the
		queue is not empty, the fields needed by Cspk are returned.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Side Effects</glossterm>
	    <glossdef>
	      <para>
		The state code field of the job is set to 'run'.
	      </para>
	    </glossdef>
	    <glossdef>
	      <para>
		The event_time field is updated to the time of this state transition.
	      </para>
	    </glossdef>
	    <glossdef>
	      <para>
		A state transition record is added to the 
		<emphasis>history</emphasis> table.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Transaction Processing Considerations</glossterm>
	    <glossdef>
	      <para>
 		The work of this function is performed within transaction state,
		between a <command>begin</command> database command and a 
		<command>commit</command>.  The job is found by using a 
		<command>select for update</command> command. In case of error,
		the functions performs a <command>rollback</command> before
		exiting.
	      </para>
	    </glossdef>
	  </glossentry>
	</glosslist>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Values returned by de_q2r</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Condition</entry>
		  <entry>Values</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>success</entry>
		  <entry>row </entry>
		  <entry>job_id, cpp_source</entry>
		</row>
		<row>
		  <entry>failure</entry>
		  <entry>null or undefined</entry>
		  <entry>
		    Information that can be used to distinguish between
		    an empty queue and an error condition such as an
		    invalid handle is provided
		    in each of the language bindings.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Arguments to de_q2r</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Name of Argument</entry>
		  <entry>Data Type</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>handle</entry>
		  <entry>database handle</entry>
		  <entry>Handle to an open database connection.</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
      </sect3>
      <sect3>
	<title id="get_run_jobs">get_run_jobs -- get all jobs currently being running</title>
	<glosslist>
	  <glossentry>
	    <glossterm>Synopsis</glossterm>
	    <glossdef>
	      <para>
		row-array = get_run_jobs handle
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Description</glossterm>
	    <glossdef>
	      <para>
		An array of rows containing all jobs with state_code = 'run' is returned.
		Each row contains  only the field: job_id.  This 
		function would typically be called by the runtime deamon upon starting
		up, in order to discover any jobs which were being run when the
		the computational sub-system was shut down, so that those jobs could be 
		restarted.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Side Effects</glossterm>
	    <glossdef>
	      <para>
		None.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Transaction Processing Considerations</glossterm>
	    <glossdef>
	      <para>
		None.
	      </para>
	    </glossdef>
	  </glossentry>
	</glosslist>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Values returned by get_run_jobs</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="1*"/>
	      <colspec colname="c2" colwidth="1*"/>
	      <colspec colname="c3" colwidth="5*"/>
	      <thead>
		<row>
		  <entry>Condition</entry>
		  <entry>Values</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>success</entry>
		  <entry>row-array</entry>
		  <entry>In each row: job_id, cpp_source</entry>
		</row>
		<row>
		  <entry>failure</entry>
		  <entry>undefined</entry>
		  <entry>
		    Information that can be used to differentiate between a select
		    that returns the empty set and a database error condition is 
		    provided by the individual language bindings.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Arguments to get_run_jobs</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="1*"/>
	      <colspec colname="c2" colwidth="1*"/>
	      <colspec colname="c3" colwidth="5*"/>
	      <thead>
		<row>
		  <entry>Name of Argument</entry>
		  <entry>Data Type</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>handle</entry>
		  <entry>database handle</entry>
		  <entry>Handle to an open database connection.</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
      </sect3>
      <sect3>
	<title id="end_job">end_job -- end a job, whether successful or not</title>
	<glosslist>
	  <glossentry>
	    <glossterm>Synopsis</glossterm>
	    <glossdef>
	      <para>
		r = end_job handle job_id end_code report
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Description</glossterm>
	    <glossdef>
	      <para>
		Cause a job to make the transition to the
		<emphasis>End</emphasis> state.
		This can occur at the end of a successful run, at the
		end of a failed run, or in case of errors occurring
		during Aspk compilation.
	      </para>
	      <para>
		Note: this function cannot be used to terminate a compilation
		or a run.  It is used, instead, to record the fact that the job has
		terminated or completed.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Side Effects</glossterm>
	    <glossdef>
	      <para>
		The state_code field of the job is changed to 'end'.
	      </para>
	    </glossdef>
	    <glossdef>
	      <para>
		The end_code of the job is changed to $end_code.
	      </para>
	    </glossdef>
	    <glossdef>
	      <para>
		The report field contains a report.
	      </para>
	    </glossdef>
	    <glossdef>
	      <para>
		The event_time field is updated to the time of this state transition.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Transaction Processing Considerations</glossterm>
	    <glossdef>
	      <para>
		None, assuming that the database supports updates and inserts with autocommit
		(eg. MySQL with type=InnoDB).
	      </para>
	    </glossdef>
	  </glossentry>
	</glosslist>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Values returned by end_job</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Condition</entry>
		  <entry>Values</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>success</entry>
		  <entry>true</entry>
		  <entry></entry>
		</row>
		<row>
		  <entry>failure</entry>
		  <entry>false</entry>
		  <entry>
		    Failure occurs when the handle, job_id, or end_code
		    is invalid. Additional error information is available
		    in the individual language bindings.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Arguments to end_job</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Name of Argument</entry>
		  <entry>Data Type</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>handle</entry>
		  <entry>database handle</entry>
		  <entry>Handle to an open database connection.</entry>
		</row>
		<row>
		  <entry>job_id</entry>
		  <entry>positive integer</entry>
		  <entry>Key to a row in the <emphasis>job</emphasis> table.</entry>
		</row>
		<row>
		  <entry>end_code</entry>
		  <entry>string</entry>
		  <entry>Valid key to a row in the <emphasis>end</emphasis> table.</entry>
		</row>
		<row>
		  <entry>report</entry>
		  <entry>string</entry>
		  <entry>
		    XML containing the final report, whether the results of
		    successful computation, partial results after an incomplete
		    run, or description of an error condition.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
      </sect3>
      <sect3>
	<title id="job_report">job_report -- retrieve the final report for a job</title>
	<glosslist>
	  <glossentry>
	    <glossterm>Synopsis</glossterm>
	    <glossdef>
	      <para>
		report = job_report handle job_id
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Description</glossterm>
	    <glossdef>
	      <para>
		The final report, in XML, is returned.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Side Effects</glossterm>
	    <glossdef>
	      <para>
		None.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Transaction Processing Considerations</glossterm>
	    <glossdef>
	      <para>
		None.
	      </para>
	    </glossdef>
	  </glossentry>
	</glosslist>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Values returned by job_report</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Condition</entry>
		  <entry>Values</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>success</entry>
		  <entry>string</entry>
		  <entry>A string containing a complete XML document.</entry>
		</row>
		<row>
		  <entry>failure</entry>
		  <entry>null or undefined</entry>
		  <entry>
		    Failure occurs if the handle or job_id is invalid.
		    The language bindings return additional information about
		    error conditions.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Arguments to job_report</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Name of Argument</entry>
		  <entry>Data Type</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>handle</entry>
		  <entry>database handle</entry>
		  <entry>Handle to an open database connection.</entry>
		</row>
		<row>
		  <entry>job_id</entry>
		  <entry>positive integer</entry>
		  <entry>Key to a row in the <emphasis>job</emphasis> table.</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
      </sect3>
      <sect3>
	<title id="new_dataset">new_dataset -- add a dataset to the database</title>
	<glosslist>
	  <glossentry>
	    <glossterm>Synopsis</glossterm>
	    <glossdef>
	      <para>
		dataset_id = new_dataset handle user_id name abstract archive
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Description</glossterm>
	    <glossdef>
	      <para>
		The <emphasis>dataset</emphasis> table contains the source code
		for scientific datasets along with identification information.
		The archive field is an RCS-compatible file which contains the
		current and all previous versions of the XML text of the dataset.
		This function is used to establish the initial version of a 
		dataset in the database.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Side Effects</glossterm>
	    <glossdef>
	      <para>
		The event_time field is set to the time of insertion.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Transaction Processing Considerations</glossterm>
	    <glossdef>
	      <para>
		None, assuming that the database supports transactions with 
		autocommit (eg., MySQL database with TYPE=InnoDB), that
		the <emphasis>dataset_id</emphasis> field carries the auto_increment
		and that the <emphasis>name</emphasis> field is unique for
		the given <emphasis>user_id</emphasis> due to a 
		<command>UNIQUE user_id (user_id, name)</command> modifier.
	      </para>
	    </glossdef>
	  </glossentry>
	</glosslist>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Values returned by new_dataset</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Condition</entry>
		  <entry>Values</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>success</entry>
		  <entry>positive integer</entry>
		  <entry>Key to a row newly added to the <emphasis>dataset</emphasis> table.</entry>
		</row>
		<row>
		  <entry>failure</entry>
		  <entry>0</entry>
		  <entry>
		    Failure occurs if the or the user_id is invalid.
		    Additional information about the nature of the failure is provided
		    by individual language bindings.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Arguments to new_dataset</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Name of Argument</entry>
		  <entry>Data Type</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>handle</entry>
		  <entry>database handle</entry>
		  <entry>Handle to an open database connection.</entry>
		</row>
		<row>
		  <entry>user_id</entry>
		  <entry>positive integer</entry>
		  <entry>Key to a row in the <emphasis>user</emphasis> table.</entry>
		</row>
		<row>
		  <entry>name</entry>
		  <entry>string</entry>
		  <entry>Name of the dataset.</entry>
		</row>
		<row>
		  <entry>abstract</entry>
		  <entry>string</entry>
		  <entry>Succinct description of the dataset.</entry>
		</row>
		<row>
		  <entry>archive</entry>
		  <entry>string</entry>
		  <entry>RCS-compatible source archive.</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
      </sect3>
      <sect3>
	<title id="get_dataset">get_dataset -- retrieve a dataset</title>
	<glosslist>
	  <glossentry>
	    <glossterm>Synopsis</glossterm>
	    <glossdef>
	      <para>
		list = get_dataset handle dataset_id
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Description</glossterm>
	    <glossdef>
	      <para>
		Given the key into the <emphasis>dataset</emphasis> table, the
		corresponding row is returned.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Side Effects</glossterm>
	    <glossdef>
	      <para>
		None.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Transaction Processing Considerations</glossterm>
	    <glossdef>
	      <para>
		None.
	      </para>
	    </glossdef>
	  </glossentry>
	</glosslist>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Values returned by get_dataset</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Condition</entry>
		  <entry>Values</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>success</entry>
		  <entry>pair list</entry>
		  <entry>
		    List of all field names for the <emphasis>dataset</emphasis>
		    table, along with associated values.
		  </entry>
		</row>
		<row>
		  <entry>failure</entry>
		  <entry>null or undefined</entry>
		  <entry>
		    Failure occurs if the handle or the dataset_id is invalid.
		    Information that can be used to distinguish a missing row
		    from an error is provided by the individual language bindings.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Arguments to get_dataset</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Name of Argument</entry>
		  <entry>Data Type</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>handle</entry>
		  <entry>database handle</entry>
		  <entry>Handle to an open database connection.</entry>
		</row>
		<row>
		  <entry>dataset_id</entry>
		  <entry>positive integer</entry>
		  <entry>Key to a row in the <emphasis>dataset</emphasis> table.</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
      </sect3>
      <sect3>
	<title id="update_dataset">
	  update_dataset -- update a row in the <emphasis>dataset</emphasis> table
	</title>
	<glosslist>
	  <glossentry>
	    <glossterm>Synopsis</glossterm>
	    <glossdef>
	      <para>
		update_dataset handle dataset_id list
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Description</glossterm>
	    <glossdef>
	      <para>
		A set of fields in a row of the <emphasis>dataset</emphasis> table
		are updated.  It is not necessary to update all rows.  The list
		is a set of (name, value) pairs, which specifies the names of 
		fields and the new values which are to be stored into them.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Side Effects</glossterm>
	    <glossdef>
	      <para>
		The event_time field is set to the time of the update.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Transaction Processing Considerations</glossterm>
	    <glossdef>
	      <para>
		None, assuming that the database supports transactions with 
		autocommit (eg., MySQL database with TYPE=InnoDB)
		and that the <emphasis>name</emphasis> field is unique for
		the given <emphasis>user_id</emphasis> due to a 
		<command>UNIQUE user_id (user_id, name)</command> modifier.
	      </para>
	    </glossdef>
	  </glossentry>
	</glosslist>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Values returned by update_dataset</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Condition</entry>
		  <entry>Values</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>success</entry>
		  <entry>true</entry>
		  <entry></entry>
		</row>
		<row>
		  <entry>failure</entry>
		  <entry>false</entry>
		  <entry>
		    Failure occurs if the handle or the dataset_id is invalid.
		    Individual language bindings provide additional information
		    in case of error.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Arguments to update_dataset</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Name of Argument</entry>
		  <entry>Data Type</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>handle</entry>
		  <entry>database handle</entry>
		  <entry>Handle to an open database connection.</entry>
		</row>
		<row>
		  <entry>dataset_id</entry>
		  <entry>positive integer</entry>
		  <entry>Key to a row in the <emphasis>dataset</emphasis> table.</entry>
		</row>
		<row>
		  <entry>list</entry>
		  <entry>pair list</entry>
		  <entry>
		    The list consists of names of fields in the <emphasis>dataset</emphasis>
		    table and the corresponding values that should replace current values.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
      </sect3>
      <sect3>
	<title id="user_datasets">user_datasets -- get a user's datasets</title>
	<glosslist>
	  <glossentry>
	    <glossterm>Synopsis</glossterm>
	    <glossdef>
	      <para>
		row-array = user_datasets handle user_id
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Description</glossterm>
	    <glossdef>
	      <para>
		Returns an array of rows, each of which contains a description
		of one of a given user's datasets. Rows are sorted in order of
		dataset_id.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Side Effects</glossterm>
	    <glossdef>
	      <para>
		None.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Transaction Processing Considerations</glossterm>
	    <glossdef>
	      <para>
		None, assuming that the database supports consistent reads
		(as does MySQL database, with type=InnoDB).
	      </para>
	    </glossdef>
	  </glossentry>
	</glosslist>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Values returned by user_datasets</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Condition</entry>
		  <entry>Values</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>success</entry>
		  <entry>row-array</entry>
		  <entry>In each row: dataset_id, name, abstract.</entry>
		</row>
		<row>
		  <entry>failure</entry>
		  <entry>null or undefined</entry>
		  <entry>
		    Failure occurs if the handle or user_id is invalid.
		    Individual language bindings provide information sufficient
		    to recognize the case where no datasets for this user exist and
		    to identify faults.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Arguments to user_datasets</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Name of Argument</entry>
		  <entry>Data Type</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>handle</entry>
		  <entry>database handle</entry>
		  <entry>Handle to an open database connection.</entry>
		</row>
		<row>
		  <entry>user_id</entry>
		  <entry>positive integer</entry>
		  <entry>Key to a row in the <emphasis>user</emphasis> table.</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
      </sect3>
      <sect3>
	<title id="new_model">new_model -- add a model to the database</title>
	<glosslist>
	  <glossentry>
	    <glossterm>Synopsis</glossterm>
	    <glossdef>
	      <para>
		model_id = new_model handle user_id name abstract archive
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Description</glossterm>
	    <glossdef>
	      <para>
		The <emphasis>model</emphasis> table contains the source code
		for scientific models along with identification information.
		The archive field is an RCS-compatible file which contains the
		current and all previous versions of the XML text of the model.
		This function is used to establish the initial version of a 
		model in the database.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Side Effects</glossterm>
	    <glossdef>
	      <para>
		The event_time field is set to the time of insertion.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Transaction Processing Considerations</glossterm>
	    <glossdef>
	      <para>
		None, assuming that the database supports transactions with 
		autocommit (eg., MySQL database with TYPE=InnoDB), that
		the <emphasis>model_id</emphasis> field carries the auto_increment
		and that the <emphasis>name</emphasis> field is unique for
		the given <emphasis>user_id</emphasis> due to a 
		<command>UNIQUE user_id (user_id, name)</command> modifier.
	      </para>
	    </glossdef>
	  </glossentry>
	</glosslist>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Values returned by new_model</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Condition</entry>
		  <entry>Values</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>success</entry>
		  <entry>positive integer</entry>
		  <entry>Key to a row newly added to the <emphasis>model</emphasis> table.</entry>
		</row>
		<row>
		  <entry>failure</entry>
		  <entry>0</entry>
		  <entry>
		    Failure occurs if the or the user_id is invalid.
		    Additional information about the nature of the failure is provided
		    by individual language bindings.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Arguments to new_model</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Name of Argument</entry>
		  <entry>Data Type</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>handle</entry>
		  <entry>database handle</entry>
		  <entry>Handle to an open database connection.</entry>
		</row>
		<row>
		  <entry>user_id</entry>
		  <entry>positive integer</entry>
		  <entry>Key to a row in the <emphasis>user</emphasis> table.</entry>
		</row>
		<row>
		  <entry>name</entry>
		  <entry>string</entry>
		  <entry>Name of the model.</entry>
		</row>
		<row>
		  <entry>abstract</entry>
		  <entry>string</entry>
		  <entry>Succinct description of the model.</entry>
		</row>
		<row>
		  <entry>archive</entry>
		  <entry>string</entry>
		  <entry>RCS-compatible source archive.</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
      </sect3>
      <sect3>
	<title id="get_model">get_model -- retrieve a model</title>
	<glosslist>
	  <glossentry>
	    <glossterm>Synopsis</glossterm>
	    <glossdef>
	      <para>
		list = get_model handle model_id
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Description</glossterm>
	    <glossdef>
	      <para>
		Given the key into the <emphasis>model</emphasis> table, the
		corresponding row is returned.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Side Effects</glossterm>
	    <glossdef>
	      <para>
		None.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Transaction Processing Considerations</glossterm>
	    <glossdef>
	      <para>
		None.
	      </para>
	    </glossdef>
	  </glossentry>
	</glosslist>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Values returned by get_model</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Condition</entry>
		  <entry>Values</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>success</entry>
		  <entry>pair list</entry>
		  <entry>
		    List of all field names for the <emphasis>model</emphasis>
		    table, along with associated values.
		  </entry>
		</row>
		<row>
		  <entry>failure</entry>
		  <entry>null or undefined</entry>
		  <entry>
		    Failure occurs if the handle or the model_id is invalid.
		    Information that can be used to distinguish a missing row
		    from an error is provided by the individual language bindings.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Arguments to get_model</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Name of Argument</entry>
		  <entry>Data Type</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>handle</entry>
		  <entry>database handle</entry>
		  <entry>Handle to an open database connection.</entry>
		</row>
		<row>
		  <entry>model_id</entry>
		  <entry>positive integer</entry>
		  <entry>Key to a row in the <emphasis>model</emphasis> table.</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
      </sect3>
      <sect3>
	<title id="update_model">
	  update_model -- update a row in the <emphasis>model</emphasis> table
	</title>
	<glosslist>
	  <glossentry>
	    <glossterm>Synopsis</glossterm>
	    <glossdef>
	      <para>
		update_model handle model_id list
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Description</glossterm>
	    <glossdef>
	      <para>
		A set of fields in a row of the <emphasis>model</emphasis> table
		are updated.  It is not necessary to update all rows.  The list
		is a set of (name, value) pairs, which specifies the names of 
		fields and the new values which are to be stored into them.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Side Effects</glossterm>
	    <glossdef>
	      <para>
		The event_time field is set to the time of the update.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Transaction Processing Considerations</glossterm>
	    <glossdef>
	      <para>
		None, assuming that the database supports transactions with 
		autocommit (eg., MySQL database with TYPE=InnoDB)
		and that the <emphasis>name</emphasis> field is unique for
		the given <emphasis>user_id</emphasis> due to a 
		<command>UNIQUE user_id (user_id, name)</command> modifier.
	      </para>
	    </glossdef>
	  </glossentry>
	</glosslist>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Values returned by update_model</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Condition</entry>
		  <entry>Values</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>success</entry>
		  <entry>true</entry>
		  <entry></entry>
		</row>
		<row>
		  <entry>failure</entry>
		  <entry>false</entry>
		  <entry>
		    Failure occurs if the handle or the model_id is invalid.
		    Individual language bindings provide additional information
		    in case of error.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Arguments to update_model</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Name of Argument</entry>
		  <entry>Data Type</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>handle</entry>
		  <entry>database handle</entry>
		  <entry>Handle to an open database connection.</entry>
		</row>
		<row>
		  <entry>model_id</entry>
		  <entry>positive integer</entry>
		  <entry>Key to a row in the <emphasis>model</emphasis> table.</entry>
		</row>
		<row>
		  <entry>list</entry>
		  <entry>pair list</entry>
		  <entry>
		    The list consists of names of fields in the <emphasis>model</emphasis>
		    table and the corresponding values that should replace current values.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
      </sect3>
      <sect3>
	<title id="user_models">user_models -- get a user's models</title>
	<glosslist>
	  <glossentry>
	    <glossterm>Synopsis</glossterm>
	    <glossdef>
	      <para>
		row-array = user_models handle user_id
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Description</glossterm>
	    <glossdef>
	      <para>
		Returns an array of rows, each of which contains a description
		of one of a given user's models. Rows are sorted in order of
		model_id.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Side Effects</glossterm>
	    <glossdef>
	      <para>
		None.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Transaction Processing Considerations</glossterm>
	    <glossdef>
	      <para>
		None, assuming that the database supports consistent reads
		(as does MySQL database, with type=InnoDB).
	      </para>
	    </glossdef>
	  </glossentry>
	</glosslist>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Values returned by user_models</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Condition</entry>
		  <entry>Values</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>success</entry>
		  <entry>row-array</entry>
		  <entry>In each row: model_id, name, abstract.</entry>
		</row>
		<row>
		  <entry>failure</entry>
		  <entry>null or undefined</entry>
		  <entry>
		    Failure occurs if the handle or user_id is invalid.
		    Individual language bindings provide information sufficient
		    to recognize the case where no models for this user exist and
		    to identify faults.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Arguments to user_models</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Name of Argument</entry>
		  <entry>Data Type</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>handle</entry>
		  <entry>database handle</entry>
		  <entry>Handle to an open database connection.</entry>
		</row>
		<row>
		  <entry>user_id</entry>
		  <entry>positive integer</entry>
		  <entry>Key to a row in the <emphasis>user</emphasis> table.</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
      </sect3>
      <sect3>
	<title id="new_user">new_user -- add a new user</title>
	<glosslist>
	  <glossentry>
	    <glossterm>Synopsis</glossterm>
	    <glossdef>
	      <para>
		user_id = new_user handle username password ...
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Description</glossterm>
	    <glossdef>
	      <para>
		Add a new Spk user.	      
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Side Effects</glossterm>
	    <glossdef>
	      <para>
		None.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Transaction Processing Considerations</glossterm>
	    <glossdef>
	      <para>
		None, assuming that the database supports transactions with 
		autocommit (eg., MySQL database with TYPE=InnoDB) and that
		the <emphasis>user_id</emphasis> field carries the auto_increment
		modifier.
	      </para>
	    </glossdef>
	  </glossentry>
	</glosslist>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Values returned by new_user</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Condition</entry>
		  <entry>Values</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>success</entry>
		  <entry>positive integer</entry>
		  <entry>Key to a row newly added to the <emphasis>user</emphasis> table.</entry>
		</row>
		<row>
		  <entry>failure</entry>
		  <entry>0</entry>
		  <entry>
		    Failure occurs if the handle is invalid, or if the list does not
		    include at least a unique username and a password.
		    Additional information about the nature of the failure is provided
		    by individual language bindings.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Arguments to new_user</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Name of Argument</entry>
		  <entry>Data Type</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>handle</entry>
		  <entry>database handle</entry>
		  <entry>Handle to an open database connection.</entry>
		</row>
		<row>
		  <entry>list</entry>
		  <entry>name and value list</entry>
		  <entry>
		    A list if names of fields in the <emphasis>user</emphasis>
		    table, along with values to be stored in the corresponding
		    fields.  This list must include, at a minimum, username
		    and password, along with their associated values.  
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
      </sect3>
      <sect3>
	<title id="update_user">
	  update_user -- update a row in the <emphasis>user</emphasis> table
	</title>
	<glosslist>
	  <glossentry>
	    <glossterm>Synopsis</glossterm>
	    <glossdef>
	      <para>
		r = update_user handle user_id list
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Description</glossterm>
	    <glossdef>
	      <para>
		Update fields of the row in the <emphasis>user</emphasis>
		table that corresponds to user_id.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Side Effects</glossterm>
	    <glossdef>
	      <para>
		None.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Transaction Processing Considerations</glossterm>
	    <glossdef>
	      <para>
		None, assuming that the database supports transactions with 
		autocommit (eg., MySQL database with TYPE=InnoDB).
	      </para>
	    </glossdef>
	  </glossentry>
	</glosslist>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Values returned by update_user</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Condition</entry>
		  <entry>Values</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>success</entry>
		  <entry>true</entry>
		  <entry></entry>
		</row>
		<row>
		  <entry>failure</entry>
		  <entry>false</entry>
		  <entry>
		    Failure occurs if the handle or the user_id is invalid.
		    Individual language bindings provide additional information
		    in case of error.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Arguments to update_user</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Name of Argument</entry>
		  <entry>Data Type</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>handle</entry>
		  <entry>database handle</entry>
		  <entry>Handle to an open database connection.</entry>
		</row>
		<row>
		  <entry>user_id</entry>
		  <entry>positive integer</entry>
		  <entry>Key to a row in the <emphasis>user</emphasis> table.</entry>
		</row>
		<row>
		  <entry>list</entry>
		  <entry>pair list</entry>
		  <entry>
		    The list consists of names of fields in the
		    <emphasis>user</emphasis> table and the corresponding values
		    that should replace current values.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
      </sect3>
      <sect3>
	<title id="get_user">get_user -- retrieve a user record by username</title>
	<glosslist>
	  <glossentry>
	    <glossterm>Synopsis</glossterm>
	    <glossdef>
	      <para>
		list = get_user handle username
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Description</glossterm>
	    <glossdef>
	      <para>
		This function retrieves the entire row in the 
		<emphasis>user</emphasis> table corresponding to the username.
		Since username is a unique alternative key, there will be no
		more than one row returned.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Side Effects</glossterm>
	    <glossdef>
	      <para>
		None.
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Transaction Processing Considerations</glossterm>
	    <glossdef>
	      <para>
		None, assuming that the database supports consistent reads
		(as does MySQL database, with type=InnoDB).
	      </para>
	    </glossdef>
	  </glossentry>
	</glosslist>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Values returned by get_user</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Condition</entry>
		  <entry>Values</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>success</entry>
		  <entry>pair list</entry>
		  <entry>
		    List of all field names for the <emphasis>user</emphasis>
		    table, along with their associated values.
		  </entry>
		</row>
		<row>
		  <entry>failure</entry>
		  <entry>null or undefined</entry>
		  <entry>
		    Failure occurs if the handle or the username is invalid.
		    Information sufficient to distinguish the case of a nonexistent
		    user from various error conditions is provided by the 
		    language bindings.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Arguments to get_user</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="3*"/>
	      <colspec colname="c2" colwidth="2*"/>
	      <colspec colname="c3" colwidth="7*"/>
	      <thead>
		<row>
		  <entry>Name of Argument</entry>
		  <entry>Data Type</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>handle</entry>
		  <entry>database handle</entry>
		  <entry>Handle to an open database connection.</entry>
		</row>
		<row>
		  <entry>username</entry>
		  <entry>string</entry>
		  <entry>User name for logging in to Spk via the MDA.</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
      </sect3>
      <sect3>
	<title id="get_end_table">get_end_table - - return the entire end table</title>
	<glosslist>
	  <glossentry>
	    <glossterm>Synopsis</glossterm>
	    <glossdef>
	      <para>
		row-array = get_end_table handle
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Description</glossterm>
	    <glossdef>
	      <para>
		The end table maps end codes into their English language equivalents.
		The table is not very large, hence it is most efficient for the
		function to return the entire table.
	      </para>
	    </glossdef>
	  </glossentry>
	</glosslist>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Values returned by get_end_table</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="1*"/>
	      <colspec colname="c2" colwidth="1*"/>
	      <colspec colname="c3" colwidth="5*"/>
	      <thead>
		<row>
		  <entry>Condition</entry>
		  <entry>Values</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>success</entry>
		  <entry>row-array</entry>
		  <entry>end_code, end_name</entry>
		</row>
		<row>
		  <entry>failure</entry>
		  <entry>null or undefined</entry>
		  <entry>
		    The database "select" that this function performs should never
		    come up empty, hence the only basis for failure would be a 
		    database error, in which case the result would be null or undefined,
		    depending on the language binding.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Arguments to get_end_table</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="1*"/>
	      <colspec colname="c2" colwidth="1*"/>
	      <colspec colname="c3" colwidth="5*"/>
	      <thead>
		<row>
		  <entry>Name of Argument</entry>
		  <entry>Data Type</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>handle</entry>
		  <entry>database handle</entry>
		  <entry>Handle to an open database connection.</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
      </sect3>
      <sect3>
	<title id="get_state_table">get_state_table - - return the entire state table</title>
	<glosslist>
	  <glossentry>
	    <glossterm>Synopsis</glossterm>
	    <glossdef>
	      <para>
		row-array = get_state_table handle
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Description</glossterm>
	    <glossdef>
	      <para>
		The state table maps state codes into their English language equivalents.
		The table is not very large, hence it is most efficient for the
		function to return the entire table.
	      </para>
	    </glossdef>
	  </glossentry>
	</glosslist>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Values returned by get_state_table</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="1*"/>
	      <colspec colname="c2" colwidth="1*"/>
	      <colspec colname="c3" colwidth="5*"/>
	      <thead>
		<row>
		  <entry>Condition</entry>
		  <entry>Values</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>success</entry>
		  <entry>row-array</entry>
		  <entry>state_code, state_name</entry>
		</row>
		<row>
		  <entry>failure</entry>
		  <entry>null or undefined</entry>
		  <entry>
		    The database "select" that this function performs should never
		    come up empty, hence the only basis for failure would be a 
		    database error, in which case the result would be null or undefined,
		    depending on the language binding.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Arguments to get_state_table</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="1*"/>
	      <colspec colname="c2" colwidth="1*"/>
	      <colspec colname="c3" colwidth="5*"/>
	      <thead>
		<row>
		  <entry>Name of Argument</entry>
		  <entry>Data Type</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>handle</entry>
		  <entry>database handle</entry>
		  <entry>Handle to an open database connection.</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
      </sect3>
<!--
      <sect3>
	<title id="blah">blah - - blah blah</title>
	<glosslist>
	  <glossentry>
	    <glossterm>Synopsis</glossterm>
	    <glossdef>
	      <para>
		blah = blah blah blah
	      </para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>Description</glossterm>
	    <glossdef>
	      <para>
		blah blah
	      </para>
	    </glossdef>
	  </glossentry>
	</glosslist>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Values returned by Blah</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="1*"/>
	      <colspec colname="c2" colwidth="1*"/>
	      <colspec colname="c3" colwidth="5*"/>
	      <thead>
		<row>
		  <entry>Condition</entry>
		  <entry>Values</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>success</entry>
		  <entry>blah</entry>
		  <entry>Blah.</entry>
		</row>
		<row>
		  <entry>failure</entry>
		  <entry>blah</entry>
		  <entry>
		    Blah. 
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
	<para>
	  <table frame="all" pgwide="1">
	    <title>Arguments to Blah</title>
	    <tgroup cols="3">
	      <colspec colname="c1" colwidth="1*"/>
	      <colspec colname="c2" colwidth="1*"/>
	      <colspec colname="c3" colwidth="5*"/>
	      <thead>
		<row>
		  <entry>Name of Argument</entry>
		  <entry>Data Type</entry>
		  <entry>Description</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>handle</entry>
		  <entry>database handle</entry>
		  <entry>Handle to an open database connection.</entry>
		</row>
		<row>
		  <entry>blah</entry>
		  <entry>blah</entry>
		  <entry>Blah blah.</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
      </sect3>
-->
    </sect2>
    <sect2>
      <title>Function Availability by Language</title>
      <para>
	Not all functions are implemented in each of the three
	language bindings.
	<table frame="all" pgwide="0">
	  <title>Functions by Language</title>
	  <tgroup cols="3">
	    <colspec colwidth="5*"/>
	    <colspec colwidth="1*" align="center"/>
	    <colspec colwidth="1*" align="center"/>
	    <thead>
	      <row>
		<entry>Function</entry>
		<entry>Perl</entry>
		<entry>Java</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry><link linkend="connect">connect</link></entry>
		<entry>x</entry>
		<entry>x</entry>
	      </row>
	      <row>
		<entry><link linkend="disconnect">disconnect</link></entry>
		<entry>x</entry>
		<entry>x</entry>
	      </row>
	      <row>
		<entry><link linkend="new_job">new_job</link></entry>
		<entry>x</entry>
		<entry>x</entry>
	      </row>
	      <row>
		<entry><link linkend="job_history">job_history</link></entry>
		<entry></entry>
		<entry>x</entry>
	      </row>
	      <row>
		<entry><link linkend="get_job">get_job</link></entry>
		<entry></entry>
		<entry>x</entry>
	      </row>
	      <row>
		<entry><link linkend="job_status">job_status</link></entry>
		<entry>x</entry>
		<entry>x</entry>
	      </row>
	      <row>
		<entry><link linkend="user_jobs">user_jobs</link></entry>
		<entry>x</entry>
		<entry>x</entry>
	      </row>
	      <row>
		<entry><link linkend="de_q2c">de_q2c</link></entry>
		<entry>x</entry>
		<entry></entry>
	      </row>
	      <row>
		<entry><link linkend="get_cmp_jobs">get_cmp_jobs</link></entry>
		<entry>x</entry>
		<entry></entry>
	      </row>
	      <row>
		<entry><link linkend="en_q2r">en_q2r</link></entry>
		<entry>x</entry>
		<entry></entry>
	      </row>
	      <row>
		<entry><link linkend="de_q2r">de_q2r</link></entry>
		<entry>x</entry>
		<entry></entry>
	      </row>
	      <row>
		<entry><link linkend="get_run_jobs">get_run_jobs</link></entry>
		<entry>x</entry>
		<entry></entry>
	      </row>
	      <row>
		<entry><link linkend="end_job">end_job</link></entry>
		<entry>x</entry>
		<entry>x</entry>
	      </row>
	      <row>
		<entry><link linkend="job_report">job_report</link></entry>
		<entry>x</entry>
		<entry>x</entry>
	      </row>
	      <row>
		<entry><link linkend="new_dataset">new_dataset</link></entry>
		<entry>x</entry>
		<entry>x</entry>
	      </row>
	      <row>
		<entry><link linkend="get_dataset">get_dataset</link></entry>
		<entry>x</entry>
		<entry>x</entry>
	      </row>
	      <row>
		<entry><link linkend="update_dataset">update_dataset</link></entry>
		<entry>x</entry>
		<entry>x</entry>
	      </row>
	      <row>
		<entry><link linkend="user_datasets">user_datasets</link></entry>
		<entry>x</entry>
		<entry>x</entry>
	      </row>
	      <row>
		<entry><link linkend="new_model">new_model</link></entry>
		<entry>x</entry>
		<entry>x</entry>
	      </row>
	      <row>
		<entry><link linkend="get_model">get_model</link></entry>
		<entry>x</entry>
		<entry>x</entry>
	      </row>
	      <row>
		<entry><link linkend="update_model">update_model</link></entry>
		<entry>x</entry>
		<entry>x</entry>
	      </row>
	      <row>
		<entry><link linkend="user_models">user_models</link></entry>
		<entry>x</entry>
		<entry>x</entry>
	      </row>
	      <row>
		<entry><link linkend="new_user">new_user</link></entry>
		<entry>x</entry>
		<entry>x</entry>
	      </row>
	      <row>
		<entry><link linkend="update_user">update_user</link></entry>
		<entry>x</entry>
		<entry>x</entry>
	      </row>
	      <row>
		<entry><link linkend="get_user">get_user</link></entry>
		<entry>x</entry>
		<entry>x</entry>
	      </row>
	      <row>
		<entry><link linkend="get_end_table">get_end_table</link></entry>
		<entry></entry>
		<entry>x</entry>
	      </row>
	      <row>
		<entry><link linkend="get_state_table">get_state_table</link></entry>
		<entry></entry>
		<entry>x</entry>
	      </row>
<!--
	      <row>
		<entry><link linkend="blah">blah</link></entry>
		<entry>x</entry>
		<entry>x</entry>
	      </row>
-->
	    </tbody>
	  </tgroup>
	</table>
      </para>
    </sect2>
  </sect1>
</article>

<!--  LocalWords:  DOCTYPE DocBook uw spkVersion API articleinfo revhistory Spk
 -->
<!--  LocalWords:  revnumber authorinitials revremark RDBMS MySQL SQL APIs MDA
 -->
<!--  LocalWords:  Aspk Cspk itemizedlist listitem ulink url xml cpp Cpsk thead
 -->
<!--  LocalWords:  glosslist glossentry glossterm glossdef dbname hostname de
 -->
<!--  LocalWords:  dbuser dbpassword pgwide tgroup colspec colname colwidth cmp
 -->
<!--  LocalWords:  tbody Username username linkend maxnum cerr srun autocommit
 -->
<!--  LocalWords:  InnoDB
 -->
