/** 
 * @file NM_generatePopDriver.cpp
 * Define NonmemTranslator::generatePopDriver().
 */
#include <fstream>

#include "NonmemTranslator.h"
#include "SpkCompilerException.h"

using namespace std;
using namespace xercesc;

void NonmemTranslator::generatePopDriver() const
{
  //==================================================================
  // Generate the drivers
  //==================================================================
  ofstream oPopDriver ( fFitDriver_cpp );
  if( !oPopDriver.good())
    {
      char mess[ SpkCompilerError::maxMessageLen() ];
      snprintf( mess, SpkCompilerError::maxMessageLen(),
		"Failed to create %s file.",
	        fFitDriver_cpp );
      SpkCompilerException e( SpkCompilerError::ASPK_STD_ERR, mess, __LINE__, __FILE__ );
      throw e;
    }

  const Symbol* pTheta = table->find(nonmem::THETA);
  const Symbol* pOmega = table->find(nonmem::OMEGA);
  const Symbol* pSigma = table->find(nonmem::SIGMA);
  const Symbol* pEta   = table->find(nonmem::ETA);

  // Generate indDriver.cpp
  if( getApproximation() == FOCE || getApproximation() == LAPLACE )
  {
    ofstream oIndDriver ( fIndDriver_cpp );
    if( !oIndDriver.good())
    {
      char mess[ SpkCompilerError::maxMessageLen() ];
      snprintf( mess, SpkCompilerError::maxMessageLen(),
		"Failed to create %s file.",
	        fIndDriver_cpp );
      SpkCompilerException e( SpkCompilerError::ASPK_STD_ERR, mess, __LINE__, __FILE__ );
      throw e;
    }
    oIndDriver << "#include <CppAD/CppAD.h>" << endl;
    oIndDriver << "#include <spk/spkpvm.h>" << endl;
    oIndDriver << "#include <spk/indOptPvm.h>" << endl;
    oIndDriver << "#include <spkpred/PopPredModel.h>" << endl;
    oIndDriver << "#include <pvm3.h>" << endl;
    oIndDriver << "#include \"DataSet.h\"" << endl;
    if( myModelSpec == PRED )
      oIndDriver << "#include \"Pred.h\""  << endl;
    else
      oIndDriver << "#include \"OdePred.h\"" << endl;
    oIndDriver << "#include \"NonmemPars.h\"" << endl;
    oIndDriver << endl;

    oIndDriver << "int main( int argc, const char* argv[] )" << endl;
    oIndDriver << "{" << endl;
    oIndDriver << "    if(chdir(argv[2]) != 0)" << endl;
    oIndDriver << "    {" << endl;
    oIndDriver << "        int ptid = pvm_parent();" << endl;
    oIndDriver << "        pvm_pkstr(\"could not change working directory\");" << endl;
    oIndDriver << "        pvm_send(ptid, SpkPvmErrorMessage);" << endl;
    oIndDriver << "        pvm_exit();" << endl;
    oIndDriver << "        return 100;  // FILE_ACCESS_FAILURE" << endl;
    oIndDriver << "    }" << endl;
    oIndDriver << endl;

    oIndDriver << "    const char* stderrFileName = \"software_error\";" << endl;
    oIndDriver << "    freopen( stderrFileName, \"w\", stderr );" << endl;
    oIndDriver << endl;

    oIndDriver << "    DataSet< double > set;" << endl;
    oIndDriver << "    DataSet< CppAD::AD<double> > setAD;" << endl;
    oIndDriver << "    DataSet< CppAD::AD< CppAD::AD<double> > > setADAD;" << endl;
    oIndDriver << endl;

    if( myModelSpec == PRED )
    {
      oIndDriver << "    Pred< double > mPred(&set);" << endl;
      oIndDriver << "    Pred< CppAD::AD<double> > mPredAD(&setAD);" << endl;
      oIndDriver << "    Pred< CppAD::AD< CppAD::AD<double> > > mPredADAD(&setADAD);" << endl;
    }
  else // ADVAN
    {
      oIndDriver << "    OdePred<double > mPred( &set, " << endl;
      oIndDriver << "                            NonmemPars::nIndividuals, " << endl;
      oIndDriver << "                            NonmemPars::isPkFunctionOfT," << endl;
      oIndDriver << "                            NonmemPars::nCompartments," << endl;
      oIndDriver << "                            NonmemPars::nParameters," << endl;
      oIndDriver << "                            NonmemPars::defaultDoseComp," << endl;
      oIndDriver << "                            NonmemPars::defaultObservationComp," << endl;
      oIndDriver << "                            NonmemPars::initialOff," << endl;
      oIndDriver << "                            NonmemPars::noOff," << endl;
      oIndDriver << "                            NonmemPars::noDose," << endl;
      oIndDriver << "                            NonmemPars::relTol" << endl;
      oIndDriver << "                           );" << endl;
      oIndDriver << "    OdePred<CppAD::AD<double> > mPredAD( &setAD, " << endl;
      oIndDriver << "                                          NonmemPars::nIndividuals, " << endl;
      oIndDriver << "                                          NonmemPars::isPkFunctionOfT," << endl;
      oIndDriver << "                                          NonmemPars::nCompartments," << endl;
      oIndDriver << "                                          NonmemPars::nParameters," << endl;
      oIndDriver << "                                          NonmemPars::defaultDoseComp," << endl;
      oIndDriver << "                                          NonmemPars::defaultObservationComp," << endl;
      oIndDriver << "                                          NonmemPars::initialOff," << endl;
      oIndDriver << "                                          NonmemPars::noOff," << endl;
      oIndDriver << "                                          NonmemPars::noDose," << endl;
      oIndDriver << "                                          NonmemPars::relTol" << endl;
      oIndDriver << "                                       );" << endl;
      oIndDriver << "    OdePred<CppAD::AD< CppAD::AD<double> > > mPredADAD( &setADAD, " << endl;
      oIndDriver << "                                                        NonmemPars::nIndividuals, " << endl;
      oIndDriver << "                                                        NonmemPars::isPkFunctionOfT," << endl;
      oIndDriver << "                                                        NonmemPars::nCompartments," << endl;
      oIndDriver << "                                                        NonmemPars::nParameters," << endl;
      oIndDriver << "                                                        NonmemPars::defaultDoseComp," << endl;
      oIndDriver << "                                                        NonmemPars::defaultObservationComp," << endl;
      oIndDriver << "                                                        NonmemPars::initialOff," << endl;
      oIndDriver << "                                                        NonmemPars::noOff," << endl;
      oIndDriver << "                                                        NonmemPars::noDose," << endl;
      oIndDriver << "                                                        NonmemPars::relTol" << endl;
      oIndDriver << "                                                      );" << endl;
    }
    
    oIndDriver << "    PopPredModel model( mPred,"  << endl;
    oIndDriver << "                        mPredAD," << endl;
    oIndDriver << "                        mPredADAD," << endl;
    oIndDriver << "                        NonmemPars::nTheta," << endl;
    oIndDriver << "                        NonmemPars::thetaLow," << endl;
    oIndDriver << "                        NonmemPars::thetaUp," << endl;
    oIndDriver << "                        NonmemPars::thetaIn," << endl;
    oIndDriver << "                        NonmemPars::nEta," << endl;
    oIndDriver << "                        NonmemPars::etaIn," << endl;
    oIndDriver << "                        NonmemPars::nEps," << endl;
    oIndDriver << "                        NonmemPars::omegaStruct," << endl;
    oIndDriver << "                        NonmemPars::omegaIn," << endl;
    oIndDriver << "                        NonmemPars::omegaFixed," << endl;
    oIndDriver << "                        NonmemPars::omegaBlockStruct," << endl;
    oIndDriver << "                        NonmemPars::omegaBlockDims," << endl;
    oIndDriver << "                        NonmemPars::omegaBlockSameAsPrev," << endl;
    oIndDriver << "                        NonmemPars::sigmaStruct," << endl;
    oIndDriver << "                        NonmemPars::sigmaIn," << endl;
    oIndDriver << "                        NonmemPars::sigmaFixed," << endl;
    oIndDriver << "                        NonmemPars::sigmaBlockStruct," << endl;
    oIndDriver << "                        NonmemPars::sigmaBlockDims," << endl;
    oIndDriver << "                        NonmemPars::sigmaBlockSameAsPrev );" << endl;
    oIndDriver << endl;

    oIndDriver << "    int exit_value = indOptPvm(argv[1], model);" << endl;
    oIndDriver << "    fclose( stderr );" << endl;
    oIndDriver << "    return exit_value;" << endl;
    oIndDriver << "}" << endl;
    oIndDriver.close();
  }

  // Generate fitDriver.cpp
  oPopDriver << "// " << myDescription << endl;

  oPopDriver << "#include <iostream>"               << endl;
  oPopDriver << "#include <fstream>"                << endl;
  oPopDriver << "#include <cmath>"                  << endl;
  oPopDriver << "#include <sys/time.h>"             << endl;
  oPopDriver << "#include <pvm3.h>"                 << endl;
  oPopDriver << endl;

  oPopDriver << "#include <spk/spkpvm.h>"           << endl;
  oPopDriver << "#include <spk/scalarToDouble.h>"   << endl;
  oPopDriver << "#include <spk/SpkValarray.h>"      << endl;
  oPopDriver << "#include <spk/SpkException.h>"     << endl;
  oPopDriver << "#include <spk/WarningsManager.h>"  << endl;
  oPopDriver << "#include <CppAD/CppAD.h>"          << endl;
  oPopDriver << endl;
  oPopDriver << "// For generating nonparametric initial grids " << endl;
  oPopDriver << "# include <gsl/gsl_rng.h>" << endl;
  oPopDriver << "# include <gsl/gsl_randist.h>" << endl;
  oPopDriver << endl;
  oPopDriver << "// For parameter estimate " << endl;
  oPopDriver << "#include <spk/fitPopulation.h>"    << endl;
  oPopDriver << "#include <spk/Optimizer.h>"        << endl;
  oPopDriver << endl;

  oPopDriver << "// For statistics" << endl;
  oPopDriver << "#include <spk/derParStatistics.h>" << endl;
  oPopDriver << "#include <spk/popStatistics.h>"    << endl;
  oPopDriver << "#include <spk/inverse.h>"          << endl;
  oPopDriver << "#include <spk/lTilde.h>"           << endl;
  oPopDriver << "#include <spk/NaiveFoModel.h>"     << endl;
  oPopDriver << "#include <spk/multiply.h>"         << endl;
  oPopDriver << "#include <spk/cholesky.h>"         << endl;
  oPopDriver << "#include <spk/indResiduals.h>"     << endl;
  oPopDriver << "#include <spk/popResiduals.h>"     << endl;
  oPopDriver << "#include <spk/symmetrize.h>"       << endl;
  oPopDriver << endl;

  oPopDriver << "// For data simulation" << endl;
  oPopDriver << "#include <spk/simulate.h>" << endl;
  oPopDriver << endl;

  oPopDriver << "// SPK Compiler generated headers/classes" << endl;
  oPopDriver << "#include \"IndData.h\""      << endl;
  oPopDriver << "#include \"DataSet.h\""      << endl;
  oPopDriver << endl;

  oPopDriver << "//   NONMEM specific"   << endl;
  if( myModelSpec == PRED )
    oPopDriver << "#include \"Pred.h\"" << endl;
  else
    oPopDriver << "#include \"OdePred.h\"" << endl;

  oPopDriver << "#include <spkpred/Cov.h>"                << endl;
  oPopDriver << "#include <spkpred/IndPredModel.h>"       << endl;
  oPopDriver << "#include <spkpred/PopPredModel.h>"       << endl;
  oPopDriver << "#include <spkpred/predNonparamMethod.h>" << endl;
  oPopDriver << "#include <spkpred/predTwoStageMethod.h>" << endl;
  oPopDriver << "#include \"NonmemPars.h\""   << endl;
  oPopDriver << endl;

  oPopDriver << "using SPK_VA::valarray;" << endl;
  oPopDriver << "using namespace std;" << endl;
  oPopDriver << endl;
  oPopDriver << "enum RETURN_CODE { SUCCESS                  = 0," << endl;
  oPopDriver << "                   UNKNOWN_ERROR            = 1," << endl;
  oPopDriver << "                   UNKNOWN_FAILURE          = 2," << endl;
  oPopDriver << "                   PVM_FAILURE              = 3," << endl;
  oPopDriver << "                   USER_ABORT               = 4," << endl;
  oPopDriver << "                   FILE_ACCESS_ERROR        = 10," << endl;
  oPopDriver << "                   OPTIMIZATION_ERROR       = 12," << endl;
  oPopDriver << "                   OPT_OK_STAT_ERROR        = 13," << endl;
  oPopDriver << "                   USER_INPUT_ERROR         = 14," << endl;
  oPopDriver << "                   PROGRAMMER_ERROR         = 15," << endl;
  oPopDriver << "                   SIMULATION_ERROR         = 16," << endl;
  oPopDriver << "                   MODEL_IDENT_ERROR        = 17," << endl;
  oPopDriver << "                   OPT_OK_RESID_ERROR       = 18," << endl;
  oPopDriver << "                   OPT_MAX_ITER_ERROR       = 19," << endl;
  oPopDriver << "                   FILE_ACCESS_FAILURE      = 100," << endl;
  oPopDriver << "                   RESERVED_DO_NOT_USE      = 101," << endl;
  oPopDriver << "                   OPTIMIZATION_FAILURE     = 102," << endl;
  oPopDriver << "                   OPT_OK_STAT_FAILURE      = 103," << endl;
  oPopDriver << "                   PROGRAMMER_FAILURE       = 105," << endl;
  oPopDriver << "                   SIMULATION_FAILURE       = 106," << endl;
  oPopDriver << "                   MODEL_IDENT_FAILURE      = 107," << endl;
  oPopDriver << "                   OPT_OK_RESID_FAILURE     = 108," << endl;
  oPopDriver << "                   OPT_MAX_ITER_FAILURE     = 119," << endl;
  oPopDriver << "                   OPT_MAX_ITER_STAT_ERROR  = 203," << endl;
  oPopDriver << "                   OPT_MAX_ITER_RESID_ERROR = 208," << endl;
  oPopDriver << "                   OPT_MAX_ITER_REACHED     = 301" << endl;
  oPopDriver << "                 };"       << endl;
  oPopDriver << endl;

  oPopDriver << "static void finish(int exit_value)"  << endl;
  oPopDriver << "{"  << endl;
  oPopDriver << "   int parent_tid = pvm_parent();"  << endl;
  oPopDriver << "   pvm_initsend(PvmDataDefault);"  << endl;
  oPopDriver << "   pvm_pkint(&exit_value, 1, 1);"  << endl;
  oPopDriver << "   pvm_send(parent_tid, SpkPvmExitValue);"  << endl;
  oPopDriver << "   pvm_exit();"  << endl;
  oPopDriver << "}"  << endl;
  oPopDriver << endl;

  oPopDriver << "int main( int argc, const char* argv[] )" << endl;
  oPopDriver << "{" << endl;
  oPopDriver << "   /*******************************************************************/" << endl;
  oPopDriver << "   /*                                                                 */" << endl;
  oPopDriver << "   /*   Variable declarations and definitions                         */" << endl;
  oPopDriver << "   /*                                                                 */" << endl;
  oPopDriver << "   /*******************************************************************/" << endl;
  oPopDriver << "   enum RETURN_CODE ret = SUCCESS;" << endl;
  oPopDriver << endl;

  oPopDriver << "   int nPvmTasks = 0;;" << endl;
  oPopDriver << "   if(argc > 1)" << endl;
  oPopDriver << "   {" << endl;
  oPopDriver << "      nPvmTasks = 1;"<< endl;
  oPopDriver << "      pvm_mytid();" << endl;
  oPopDriver << "      int parent_tid = pvm_parent();" << endl;
  oPopDriver << endl;

  oPopDriver << "      // Disallow direct routing of messages between tasks; otherwise" << endl;
  oPopDriver << "      // messages will arrive out of sequence." << endl;
  oPopDriver << "      pvm_setopt(PvmRoute, PvmDontRoute);" << endl;

  oPopDriver << "      pvm_notify(PvmTaskExit, PvmTaskExit, 1, &parent_tid);" << endl;
  oPopDriver << endl;

  oPopDriver << "      if(chdir(argv[1]) != 0)" << endl;
  oPopDriver << "      {" << endl;
  oPopDriver << "         finish(FILE_ACCESS_ERROR);" << endl;
  oPopDriver << "         return FILE_ACCESS_ERROR;" << endl;
  oPopDriver << "      }" << endl;
  oPopDriver << "   }" << endl;
  oPopDriver << "   if(argc > 2) nPvmTasks = atoi(argv[2]);" << endl;
  oPopDriver << endl;

  oPopDriver << "   // Redirect stdout and stderr to files" << endl;
  oPopDriver << "   const char* stdoutFileName = \"optimizer_trace.txt\";" << endl;
  oPopDriver << "   const char* stderrFileName = \"software_error\";" << endl;
  oPopDriver << "   freopen( stdoutFileName, \"w\", stdout );" << endl;
  oPopDriver << "   freopen( stderrFileName, \"w\", stderr );" << endl;
  oPopDriver << endl;

  oPopDriver << "   SpkException errors;" << endl;
  oPopDriver << "   try{" << endl;
  oPopDriver << "      ofstream oLongError;" << endl;
  oPopDriver << endl;

  oPopDriver << "      const bool isSimRequested     = " << (myIsSimulate? "true":"false") << ";" << endl;
  oPopDriver << "      bool haveCompleteData         = !isSimRequested;" << endl;
  oPopDriver << endl;

  oPopDriver << "      const bool isOptRequested     = " << (myIsEstimate? "true":"false") << ";" << endl;
  oPopDriver << "      bool isOptSuccess             = !isOptRequested;" << endl;
  oPopDriver << "      Objective objective           = ";
  if( getApproximation() == FO )
    oPopDriver << "FIRST_ORDER;" << endl;
  else if( getApproximation() == FOCE )
    oPopDriver << "EXPECTED_HESSIAN;" << endl;
  else if( getApproximation() == STD_TWO_STAGE )
    oPopDriver << "STANDARD_TWO_STAGE;" << endl;
  else if( getApproximation() == GLOBAL_TWO_STAGE )
    oPopDriver << "GLOBAL_TWO_STAGE;" << endl;
  else if( getApproximation() == ITERATIVE_TWO_STAGE )
    oPopDriver << "ITERATIVE_TWO_STAGE;" << endl;
  else if( getApproximation() == NONPARAM_GRID )
    oPopDriver << "NONPARAM_GRID;" << endl;
  else if( getApproximation() == NONPARAM_RANDOM_UNIFORM )
    oPopDriver << "NONPARAM_RANDOM_UNIFORM;" << endl;
  else
    oPopDriver << "MODIFIED_LAPLACE;" << endl;
  oPopDriver << endl;

  oPopDriver << "      const bool isStatRequested    = " << (myIsStat? "true":"false") << ";" << endl;
  oPopDriver << "      enum PopCovForm covForm       = " << myCovForm << ";" << endl;
  oPopDriver << "      bool isStatSuccess            = !isStatRequested;" << endl;
  oPopDriver << endl;

  oPopDriver << "      const bool isRestartRequested = " << (myIsRestart? "true":"false") << ";" << endl;
  oPopDriver << endl;

  oPopDriver << "      const int nRepeats            = " << mySubproblemsN << ";" << endl;
  oPopDriver << endl;

  oPopDriver << "      const bool isPostHoc          = " << (myIsPosthoc? "true" : "false") << ";" << endl;
  oPopDriver << endl;

  oPopDriver << "      int seed = NonmemPars::seed; " << endl;
  oPopDriver << "      srand( seed );" << endl;
  oPopDriver << endl;

  oPopDriver << "      DataSet< double > set;" << endl;
  oPopDriver << "      DataSet< CppAD::AD<double> > setAD;" << endl;
  oPopDriver << "      DataSet< CppAD::AD< CppAD::AD<double> > > setADAD;" << endl;
  oPopDriver << "      DataSet< CppAD::AD< CppAD::AD< CppAD::AD<double> > > > setADADAD;" << endl;
  oPopDriver << endl;
  oPopDriver << "      const int           nPop      = NonmemPars::nIndividuals;" << endl;
  oPopDriver << "      const valarray<int> NObservs  = set.getNObservs();" << endl;
  oPopDriver << "      const valarray<int> NRecords  = set.getNRecords();" << endl;
  oPopDriver << "      const int           nY        = NObservs.sum();" << endl;
  oPopDriver << "      valarray<double>    y( nY );" << endl;
  oPopDriver << endl;

  oPopDriver << "      valarray<double> thetaIn  ( NonmemPars::thetaIn );" << endl;
  oPopDriver << "      valarray<double> omegaIn  ( NonmemPars::omegaIn );" << endl;
  oPopDriver << "      valarray<double> sigmaIn  ( NonmemPars::sigmaIn );" << endl;
  oPopDriver << "      valarray<double> thetaOut ( NonmemPars::nTheta );" << endl;
  oPopDriver << "      valarray<double> omegaOut ( NonmemPars::omegaOrder );" << endl;
  oPopDriver << "      valarray<double> sigmaOut ( NonmemPars::sigmaOrder );" << endl;
  oPopDriver << endl;

  oPopDriver << "      ///////////////////////////////////////////////////////////////////" << endl;
  oPopDriver << "      //   Model initialization" << endl;
  if( myModelSpec == PRED )
    {
      oPopDriver << "      Pred< double > mPred(&set);" << endl;
      oPopDriver << "      Pred< CppAD::AD<double> > mPredAD(&setAD);" << endl;
      oPopDriver << "      Pred< CppAD::AD< CppAD::AD<double> > > mPredADAD(&setADAD);" << endl;
      oPopDriver << "      Pred< CppAD::AD< CppAD::AD< CppAD::AD<double> > > > mPredADADAD(&setADADAD);" << endl;
    }
  else // ADVAN
    {
      oPopDriver << "      OdePred<double > mPred( &set, " << endl;
      oPopDriver << "                              NonmemPars::nIndividuals, " << endl;
      oPopDriver << "                              NonmemPars::isPkFunctionOfT," << endl;
      oPopDriver << "                              NonmemPars::nCompartments," << endl;
      oPopDriver << "                              NonmemPars::nParameters," << endl;
      oPopDriver << "                              NonmemPars::defaultDoseComp," << endl;
      oPopDriver << "                              NonmemPars::defaultObservationComp," << endl;
      oPopDriver << "                              NonmemPars::initialOff," << endl;
      oPopDriver << "                              NonmemPars::noOff," << endl;
      oPopDriver << "                              NonmemPars::noDose," << endl;
      oPopDriver << "                              NonmemPars::relTol" << endl;
      oPopDriver << "                             );" << endl;
      oPopDriver << "      OdePred<CppAD::AD<double> > mPredAD( &setAD, " << endl;
      oPopDriver << "                                            NonmemPars::nIndividuals, " << endl;
      oPopDriver << "                                            NonmemPars::isPkFunctionOfT," << endl;
      oPopDriver << "                                            NonmemPars::nCompartments," << endl;
      oPopDriver << "                                            NonmemPars::nParameters," << endl;
      oPopDriver << "                                            NonmemPars::defaultDoseComp," << endl;
      oPopDriver << "                                            NonmemPars::defaultObservationComp," << endl;
      oPopDriver << "                                            NonmemPars::initialOff," << endl;
      oPopDriver << "                                            NonmemPars::noOff," << endl;
      oPopDriver << "                                            NonmemPars::noDose," << endl;
      oPopDriver << "                                            NonmemPars::relTol" << endl;
      oPopDriver << "                                         );" << endl;
      oPopDriver << "      OdePred<CppAD::AD< CppAD::AD<double> > > mPredADAD( &setADAD, " << endl;
      oPopDriver << "                                                          NonmemPars::nIndividuals, " << endl;
      oPopDriver << "                                                          NonmemPars::isPkFunctionOfT," << endl;
      oPopDriver << "                                                          NonmemPars::nCompartments," << endl;
      oPopDriver << "                                                          NonmemPars::nParameters," << endl;
      oPopDriver << "                                                          NonmemPars::defaultDoseComp," << endl;
      oPopDriver << "                                                          NonmemPars::defaultObservationComp," << endl;
      oPopDriver << "                                                          NonmemPars::initialOff," << endl;
      oPopDriver << "                                                          NonmemPars::noOff," << endl;
      oPopDriver << "                                                          NonmemPars::noDose," << endl;
      oPopDriver << "                                                          NonmemPars::relTol" << endl;
      oPopDriver << "                                                        );" << endl;
      oPopDriver << "      OdePred<CppAD::AD< CppAD::AD< CppAD::AD<double> > > > mPredADADAD( &setADADAD, " << endl;
      oPopDriver << "                                                          NonmemPars::nIndividuals, " << endl;
      oPopDriver << "                                                          NonmemPars::isPkFunctionOfT," << endl;
      oPopDriver << "                                                          NonmemPars::nCompartments," << endl;
      oPopDriver << "                                                          NonmemPars::nParameters," << endl;
      oPopDriver << "                                                          NonmemPars::defaultDoseComp," << endl;
      oPopDriver << "                                                          NonmemPars::defaultObservationComp," << endl;
      oPopDriver << "                                                          NonmemPars::initialOff," << endl;
      oPopDriver << "                                                          NonmemPars::noOff," << endl;
      oPopDriver << "                                                          NonmemPars::noDose," << endl;
      oPopDriver << "                                                          NonmemPars::relTol" << endl;
      oPopDriver << "                                                        );" << endl;
    }
  oPopDriver << endl;
  oPopDriver << "      PopPredModel model( mPred,"                   << endl;
  oPopDriver << "                          mPredAD,"                 << endl;
  oPopDriver << "                          mPredADAD,"               << endl;
  oPopDriver << "                          NonmemPars::nTheta,"      << endl;
  oPopDriver << "                          NonmemPars::thetaLow,"    << endl;
  oPopDriver << "                          NonmemPars::thetaUp,"     << endl;
  oPopDriver << "                          NonmemPars::thetaIn,"     << endl;
  oPopDriver << "                          NonmemPars::nEta,"        << endl;
  oPopDriver << "                          NonmemPars::etaIn,"       << endl;
  oPopDriver << "                          NonmemPars::nEps,"        << endl;
  oPopDriver << "                          NonmemPars::omegaStruct," << endl;
  oPopDriver << "                          NonmemPars::omegaIn,"     << endl;
  oPopDriver << "                          NonmemPars::omegaFixed,"  << endl;
  oPopDriver << "                          NonmemPars::omegaBlockStruct,"      << endl;
  oPopDriver << "                          NonmemPars::omegaBlockDims,"        << endl;
  oPopDriver << "                          NonmemPars::omegaBlockSameAsPrev,"  << endl;
  oPopDriver << "                          NonmemPars::sigmaStruct," << endl;
  oPopDriver << "                          NonmemPars::sigmaIn,"     << endl;
  oPopDriver << "                          NonmemPars::sigmaFixed,"  << endl;
  oPopDriver << "                          NonmemPars::sigmaBlockStruct,"      << endl;
  oPopDriver << "                          NonmemPars::sigmaBlockDims,"        << endl;
  oPopDriver << "                          NonmemPars::sigmaBlockSameAsPrev );"<< endl;
  oPopDriver << endl;
  oPopDriver << "      PopPredModelBase< CppAD::AD<double> > modelAD( mPredAD,"  << endl;
  oPopDriver << "                          mPredADAD,"               << endl;
  oPopDriver << "                          mPredADADAD,"             << endl;
  oPopDriver << "                          NonmemPars::nTheta,"      << endl;
  oPopDriver << "                          NonmemPars::thetaLow,"    << endl;
  oPopDriver << "                          NonmemPars::thetaUp,"     << endl;
  oPopDriver << "                          NonmemPars::thetaIn,"     << endl;
  oPopDriver << "                          NonmemPars::nEta,"        << endl;
  oPopDriver << "                          NonmemPars::etaIn,"       << endl;
  oPopDriver << "                          NonmemPars::nEps,"        << endl;
  oPopDriver << "                          NonmemPars::omegaStruct," << endl;
  oPopDriver << "                          NonmemPars::omegaIn,"     << endl;
  oPopDriver << "                          NonmemPars::omegaFixed,"  << endl;
  oPopDriver << "                          NonmemPars::omegaBlockStruct,"      << endl;
  oPopDriver << "                          NonmemPars::omegaBlockDims,"        << endl;
  oPopDriver << "                          NonmemPars::omegaBlockSameAsPrev,"  << endl;
  oPopDriver << "                          NonmemPars::sigmaStruct," << endl;
  oPopDriver << "                          NonmemPars::sigmaIn,"     << endl;
  oPopDriver << "                          NonmemPars::sigmaFixed,"  << endl;
  oPopDriver << "                          NonmemPars::sigmaBlockStruct,"      << endl;
  oPopDriver << "                          NonmemPars::sigmaBlockDims,"        << endl;
  oPopDriver << "                          NonmemPars::sigmaBlockSameAsPrev );"<< endl;
  oPopDriver << "      //" << endl;
  oPopDriver << "      ///////////////////////////////////////////////////////////////////" << endl;
  oPopDriver << endl;
  oPopDriver << "      ///////////////////////////////////////////////////////////////////" << endl;
  oPopDriver << "      //   DataSet and Model for disposal; this DataSet instance is used " << endl;
  oPopDriver << "      //   for computations other than parameter estimation, in order to" << endl;
  oPopDriver << "      //   save the values at the end of estimation." << endl;
  oPopDriver << "      DataSet< double > dataForDisposal;" << endl;
  oPopDriver << "      DataSet< CppAD::AD<double> > dataForDisposalAD;" << endl;
  oPopDriver << "      DataSet< CppAD::AD< CppAD::AD<double> > > dataForDisposalADAD;" << endl;
  oPopDriver << "      DataSet< CppAD::AD< CppAD::AD< CppAD::AD<double> > > > dataForDisposalADADAD;" << endl;
  if( myModelSpec == PRED )
    {
      oPopDriver << "      Pred< double > predForDisposal(&dataForDisposal);" << endl;
      oPopDriver << "      Pred< CppAD::AD<double> > predForDisposalAD(&dataForDisposalAD);" << endl;
      oPopDriver << "      Pred< CppAD::AD< CppAD::AD<double> > > predForDisposalADAD(&dataForDisposalADAD);" << endl;
      oPopDriver << "      Pred< CppAD::AD< CppAD::AD< CppAD::AD<double> > > > predForDisposalADADAD(&dataForDisposalADADAD);" << endl;
    }
  else
    {
      oPopDriver << "      OdePred< double > predForDisposal( &dataForDisposal, " << endl;
      oPopDriver << "                                         NonmemPars::nIndividuals, " << endl;
      oPopDriver << "                                         NonmemPars::isPkFunctionOfT," << endl;
      oPopDriver << "                                         NonmemPars::nCompartments," << endl;
      oPopDriver << "                                         NonmemPars::nParameters," << endl;
      oPopDriver << "                                         NonmemPars::defaultDoseComp," << endl;
      oPopDriver << "                                         NonmemPars::defaultObservationComp," << endl;
      oPopDriver << "                                         NonmemPars::initialOff," << endl;
      oPopDriver << "                                         NonmemPars::noOff," << endl;
      oPopDriver << "                                         NonmemPars::noDose," << endl;
      oPopDriver << "                                         NonmemPars::relTol" << endl;
      oPopDriver << "                                       );" << endl;
      oPopDriver << "      OdePred< CppAD::AD<double> > predForDisposalAD( &dataForDisposalAD, " << endl;
      oPopDriver << "                                         NonmemPars::nIndividuals, " << endl;
      oPopDriver << "                                         NonmemPars::isPkFunctionOfT," << endl;
      oPopDriver << "                                         NonmemPars::nCompartments," << endl;
      oPopDriver << "                                         NonmemPars::nParameters," << endl;
      oPopDriver << "                                         NonmemPars::defaultDoseComp," << endl;
      oPopDriver << "                                         NonmemPars::defaultObservationComp," << endl;
      oPopDriver << "                                         NonmemPars::initialOff," << endl;
      oPopDriver << "                                         NonmemPars::noOff," << endl;
      oPopDriver << "                                         NonmemPars::noDose," << endl;
      oPopDriver << "                                         NonmemPars::relTol" << endl;
      oPopDriver << "                                       );" << endl;
      oPopDriver << "      OdePred< CppAD::AD< CppAD::AD<double> > > predForDisposalADAD( &dataForDisposalADAD, " << endl;
      oPopDriver << "                                         NonmemPars::nIndividuals, " << endl;
      oPopDriver << "                                         NonmemPars::isPkFunctionOfT," << endl;
      oPopDriver << "                                         NonmemPars::nCompartments," << endl;
      oPopDriver << "                                         NonmemPars::nParameters," << endl;
      oPopDriver << "                                         NonmemPars::defaultDoseComp," << endl;
      oPopDriver << "                                         NonmemPars::defaultObservationComp," << endl;
      oPopDriver << "                                         NonmemPars::initialOff," << endl;
      oPopDriver << "                                         NonmemPars::noOff," << endl;
      oPopDriver << "                                         NonmemPars::noDose," << endl;
      oPopDriver << "                                         NonmemPars::relTol" << endl;
      oPopDriver << "                                       );" << endl;
      oPopDriver << "      OdePred< CppAD::AD< CppAD::AD< CppAD::AD<double> > > > predForDisposalADADAD( &dataForDisposalADADAD, " << endl;
      oPopDriver << "                                         NonmemPars::nIndividuals, " << endl;
      oPopDriver << "                                         NonmemPars::isPkFunctionOfT," << endl;
      oPopDriver << "                                         NonmemPars::nCompartments," << endl;
      oPopDriver << "                                         NonmemPars::nParameters," << endl;
      oPopDriver << "                                         NonmemPars::defaultDoseComp," << endl;
      oPopDriver << "                                         NonmemPars::defaultObservationComp," << endl;
      oPopDriver << "                                         NonmemPars::initialOff," << endl;
      oPopDriver << "                                         NonmemPars::noOff," << endl;
      oPopDriver << "                                         NonmemPars::noDose," << endl;
      oPopDriver << "                                         NonmemPars::relTol" << endl;
      oPopDriver << "                                       );" << endl;
    }
  oPopDriver << "      PopPredModel modelForDisposal( predForDisposal,"                   << endl;
  oPopDriver << "                                     predForDisposalAD,"       << endl;
  oPopDriver << "                                     predForDisposalADAD,"     << endl;
  oPopDriver << "                                     NonmemPars::nTheta,"      << endl;
  oPopDriver << "                                     NonmemPars::thetaLow,"    << endl;
  oPopDriver << "                                     NonmemPars::thetaUp,"     << endl;
  oPopDriver << "                                     NonmemPars::thetaIn,"     << endl;
  oPopDriver << "                                     NonmemPars::nEta,"        << endl;
  oPopDriver << "                                     NonmemPars::etaIn,"       << endl;
  oPopDriver << "                                     NonmemPars::nEps,"        << endl;
  oPopDriver << "                                     NonmemPars::omegaStruct," << endl;
  oPopDriver << "                                     NonmemPars::omegaIn,"     << endl;
  oPopDriver << "                                     NonmemPars::omegaFixed,"  << endl;
  oPopDriver << "                                     NonmemPars::omegaBlockStruct,"      << endl;
  oPopDriver << "                                     NonmemPars::omegaBlockDims,"        << endl;
  oPopDriver << "                                     NonmemPars::omegaBlockSameAsPrev,"  << endl;
  oPopDriver << "                                     NonmemPars::sigmaStruct," << endl;
  oPopDriver << "                                     NonmemPars::sigmaIn,"     << endl;
  oPopDriver << "                                     NonmemPars::sigmaFixed,"  << endl;
  oPopDriver << "                                     NonmemPars::sigmaBlockStruct,"      << endl;
  oPopDriver << "                                     NonmemPars::sigmaBlockDims,"        << endl;
  oPopDriver << "                                     NonmemPars::sigmaBlockSameAsPrev );"<< endl;
  oPopDriver << "      PopPredModelBase< CppAD::AD<double> > modelForDisposalAD( predForDisposalAD," << endl;
  oPopDriver << "                                     predForDisposalADAD,"       << endl;
  oPopDriver << "                                     predForDisposalADADAD,"     << endl;
  oPopDriver << "                                     NonmemPars::nTheta,"      << endl;
  oPopDriver << "                                     NonmemPars::thetaLow,"    << endl;
  oPopDriver << "                                     NonmemPars::thetaUp,"     << endl;
  oPopDriver << "                                     NonmemPars::thetaIn,"     << endl;
  oPopDriver << "                                     NonmemPars::nEta,"        << endl;
  oPopDriver << "                                     NonmemPars::etaIn,"       << endl;
  oPopDriver << "                                     NonmemPars::nEps,"        << endl;
  oPopDriver << "                                     NonmemPars::omegaStruct," << endl;
  oPopDriver << "                                     NonmemPars::omegaIn,"     << endl;
  oPopDriver << "                                     NonmemPars::omegaFixed,"  << endl;
  oPopDriver << "                                     NonmemPars::omegaBlockStruct,"      << endl;
  oPopDriver << "                                     NonmemPars::omegaBlockDims,"        << endl;
  oPopDriver << "                                     NonmemPars::omegaBlockSameAsPrev,"  << endl;
  oPopDriver << "                                     NonmemPars::sigmaStruct," << endl;
  oPopDriver << "                                     NonmemPars::sigmaIn,"     << endl;
  oPopDriver << "                                     NonmemPars::sigmaFixed,"  << endl;
  oPopDriver << "                                     NonmemPars::sigmaBlockStruct,"      << endl;
  oPopDriver << "                                     NonmemPars::sigmaBlockDims,"        << endl;
  oPopDriver << "                                     NonmemPars::sigmaBlockSameAsPrev );"<< endl;
  oPopDriver << "      //" << endl;
  oPopDriver << "      ///////////////////////////////////////////////////////////////////" << endl;
  oPopDriver << endl;

  oPopDriver << "      ///////////////////////////////////////////////////////////////////" << endl;
  oPopDriver << "      //   Models for two-stage or nonparametric methods." << endl;
  oPopDriver << "      IndPredModel indModelForTwoStageOrNonparam( predForDisposal," << endl;
  oPopDriver << "                                                  predForDisposalAD," << endl;
  oPopDriver << "                                                  predForDisposalADAD," << endl;
  oPopDriver << "                                                  NonmemPars::nTheta," << endl;
  oPopDriver << "                                                  NonmemPars::thetaLow," << endl;
  oPopDriver << "                                                  NonmemPars::thetaUp," << endl;
  oPopDriver << "                                                  NonmemPars::thetaIn," << endl;
  oPopDriver << "                                                  NonmemPars::nEps," << endl;
  oPopDriver << "                                                  NonmemPars::sigmaStruct," << endl;
  oPopDriver << "                                                  NonmemPars::sigmaIn );" << endl;
  oPopDriver << endl;
  oPopDriver << "      IndPredModelBase< CppAD::AD<double> > indModelForTwoStageOrNonparamAD( predForDisposalAD," << endl;
  oPopDriver << "                                                  predForDisposalADAD," << endl;
  oPopDriver << "                                                  predForDisposalADADAD," << endl;
  oPopDriver << "                                                  NonmemPars::nTheta," << endl;
  oPopDriver << "                                                  NonmemPars::thetaLow," << endl;
  oPopDriver << "                                                  NonmemPars::thetaUp," << endl;
  oPopDriver << "                                                  NonmemPars::thetaIn," << endl;
  oPopDriver << "                                                  NonmemPars::nEps," << endl;
  oPopDriver << "                                                  NonmemPars::sigmaStruct," << endl;
  oPopDriver << "                                                  NonmemPars::sigmaIn );" << endl;
  oPopDriver << endl;
  oPopDriver << "      bool isTwoStageMethod;" << endl;
  oPopDriver << "      valarray<double> bTwoStageOrNonparamOut;" << endl;
  oPopDriver << endl;
  oPopDriver << "      // The population model's sigma value contains the population" << endl;
  oPopDriver << "      // mean of the individuals' omega values." << endl;
  oPopDriver << "      const int nSigmaParTwoStageOrNonparam = model.getSigma().getNPar();" << endl;
  oPopDriver << endl;
  oPopDriver << "      const int nBTwoStageOrNonparam = indModelForTwoStageOrNonparam.getNIndPar();" << endl;
  oPopDriver << endl;
  oPopDriver << "      if( objective == STANDARD_TWO_STAGE            ||" << endl;
  oPopDriver << "          objective == ITERATIVE_TWO_STAGE           ||" << endl;
  oPopDriver << "          objective == GLOBAL_TWO_STAGE              ||" << endl;
  oPopDriver << "          objective == MAP_BAYES_STANDARD_TWO_STAGE  ||" << endl;
  oPopDriver << "          objective == MAP_BAYES_ITERATIVE_TWO_STAGE ||" << endl;
  oPopDriver << "          objective == MAP_BAYES_GLOBAL_TWO_STAGE )" << endl;
  oPopDriver << "      {" << endl;
  oPopDriver << "         isTwoStageMethod = true;" << endl;
  oPopDriver << "      }" << endl;
  oPopDriver << "      else" << endl;
  oPopDriver << "      {" << endl;
  oPopDriver << "         isTwoStageMethod = false;" << endl;
  oPopDriver << "      }" << endl;
  oPopDriver << endl;
  oPopDriver << "      bool isNonparamMethod;" << endl;
  oPopDriver << "      int nBMeasurePointIn;" << endl;
  oPopDriver << "      int nBMeasurePointPerDimIn;" << endl;
  oPopDriver << "      valarray<double> bNonparamLow;" << endl;
  oPopDriver << "      valarray<double> bNonparamUp;" << endl;
  oPopDriver << "      valarray<double> bMeasurePointIn;" << endl;
  oPopDriver << "      valarray<double> bMeasurePointOut;" << endl;
  oPopDriver << "      valarray<double> bWeightOut;" << endl;
  oPopDriver << "      valarray<double> bProbDensityOut;" << endl;
  oPopDriver << "      valarray<double> bPostMeanOut( nPop * nBTwoStageOrNonparam );" << endl;
  oPopDriver << endl;
  oPopDriver << "      if( objective == NONPARAM_GRID                 ||" << endl;
  oPopDriver << "          objective == NONPARAM_RANDOM_UNIFORM )" << endl;
  oPopDriver << "      {" << endl;
  oPopDriver << "         isNonparamMethod = true;" << endl;
  oPopDriver << endl;
  oPopDriver << "         bNonparamLow.resize( nBTwoStageOrNonparam );" << endl;
  oPopDriver << "         bNonparamUp .resize( nBTwoStageOrNonparam );" << endl;
  oPopDriver << endl;
  oPopDriver << "         indModelForTwoStageOrNonparam.getIndParLimits( bNonparamLow, bNonparamUp );" << endl;
  oPopDriver << "      }" << endl;
  oPopDriver << "      else" << endl;
  oPopDriver << "      {" << endl;
  oPopDriver << "         isNonparamMethod = false;" << endl;
  oPopDriver << "      }" << endl;
  oPopDriver << endl;
  oPopDriver << "      if( isTwoStageMethod || isNonparamMethod )" << endl;
  oPopDriver << "      {" << endl;
  oPopDriver << "         bTwoStageOrNonparamOut.resize( nBTwoStageOrNonparam * nPop );" << endl;
  oPopDriver << "      }" << endl;
  oPopDriver << endl;
  oPopDriver << "      //" << endl;
  oPopDriver << "      ///////////////////////////////////////////////////////////////////" << endl;
  oPopDriver << endl;

  oPopDriver << "      const int nAlp = model.getNPopPar();" << endl;
  oPopDriver << "      const int nB   = model.getNIndPar();" << endl;
  oPopDriver << endl;
   
  oPopDriver << "      valarray<double> alpIn  ( nAlp );" << endl;
  oPopDriver << "      valarray<double> alpUp  ( nAlp );" << endl;
  oPopDriver << "      valarray<double> alpLow ( nAlp );" << endl;
  oPopDriver << "      valarray<double> alpStep( nAlp );" << endl;
  oPopDriver << "      valarray<double> alpOut ( nAlp );" << endl;
  oPopDriver << "      valarray<bool>   alpMask( nAlp );" << endl;
  oPopDriver << endl;
  
  oPopDriver << "      double           alpObjOut;" << endl;
  oPopDriver << "      valarray<double> alpObj_alpOut    ( nAlp );" << endl;
  oPopDriver << "      valarray<double> alpObj_alp_alpOut( nAlp * nAlp );" << endl;
  oPopDriver << endl;

  oPopDriver << "      model.getPopPar         ( alpIn );" << endl;
  oPopDriver << "      model.getPopParLimits   ( alpLow, alpUp );" << endl;
  oPopDriver << "      model.getPopParStep     ( alpStep );" << endl;

  oPopDriver << endl;

  oPopDriver << "      valarray<double> bIn  ( nB * nPop );" << endl;
  oPopDriver << "      valarray<double> biIn ( nB );" << endl;
  oPopDriver << "      valarray<double> bUp  ( nB );" << endl;
  oPopDriver << "      valarray<double> bLow ( nB );" << endl;
  oPopDriver << "      valarray<double> bStep( nB );" << endl;
  oPopDriver << "      valarray<double> bOut ( nB * nPop );" << endl;
  oPopDriver << "      model.getIndParLimits ( bLow, bUp );" << endl;
  oPopDriver << "      model.getIndParStep   ( bStep );" << endl;
  oPopDriver << endl;
  oPopDriver << "      // Set the initial b values depending on the method." << endl;
  oPopDriver << "      if( objective == NONPARAM_RANDOM_UNIFORM )" << endl;
  oPopDriver << "      {" << endl;
  oPopDriver << "         nBMeasurePointIn = NonmemPars::nBMeasurePointIn;" << endl;
  oPopDriver << "         bMeasurePointIn.resize( nBTwoStageOrNonparam * nBMeasurePointIn );" << endl;
  oPopDriver << endl;
  oPopDriver << "         // Prepare the randon number generator." << endl;
  oPopDriver << "         gsl_rng* randNumberGen                 = 0;" << endl;
  oPopDriver << "         const gsl_rng_type* randNumberGenType  = gsl_rng_default;" << endl;
  oPopDriver << "         randNumberGen                          = gsl_rng_alloc( randNumberGenType );" << endl;
  oPopDriver << "         gsl_rng_set( randNumberGen, seed );" << endl;
  oPopDriver << "         assert( randNumberGen != 0 );" << endl;
  oPopDriver << endl;
  oPopDriver << "         // Choose the initial measure point using the random uniform" << endl;
  oPopDriver << "         // distribution," << endl;
  oPopDriver << "         //" << endl;
  oPopDriver << "         //     bIn      ~  Uniform[bNonparamLow   , bNonparamUp   ]  ." << endl;
  oPopDriver << "         //        j(k)                         (k)             (k)" << endl;
  oPopDriver << "         //" << endl;
  oPopDriver << "         for( int j=0; j<nBMeasurePointIn; j++ )" << endl;
  oPopDriver << "         {" << endl;
  oPopDriver << "            for(int k = 0; k < nBTwoStageOrNonparam; k++)" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               bMeasurePointIn[k + j * nBTwoStageOrNonparam] = " << endl;
  oPopDriver << "                 gsl_ran_flat( randNumberGen, bNonparamLow[k], bNonparamUp[k] );" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "         }" << endl;
  oPopDriver << "      }" << endl;
  oPopDriver << "      else if( objective == NONPARAM_GRID )" << endl;
  oPopDriver << "      {" << endl;
  oPopDriver << "         nBMeasurePointPerDimIn = NonmemPars::nBMeasurePointPerDimIn;" << endl;
  oPopDriver << "         nBMeasurePointIn = static_cast<int>( " << endl;
  oPopDriver << "            std::pow( static_cast<double>( nBMeasurePointPerDimIn ), nBTwoStageOrNonparam ) );" << endl;
  oPopDriver << "         bMeasurePointIn.resize( nBTwoStageOrNonparam * nBMeasurePointIn );" << endl;
  oPopDriver << endl;
  oPopDriver << "         // Start all of the elements' indices equal to one." << endl;
  oPopDriver << "         valarray<int> index( 1, nBTwoStageOrNonparam );" << endl;
  oPopDriver << endl;
  oPopDriver << "         // Set the initial measure points equal to a grid with" << endl;
  oPopDriver << "         // nBMeasurePointPerDimIn points in each dimension, and with" << endl;
  oPopDriver << "         // the following spacing between each grid point," << endl;
  oPopDriver << "         //" << endl;
  oPopDriver << "         //      bNonparamUp    -  bNonparamLow" << endl;
  oPopDriver << "         //                 (k)                (k)" << endl;
  oPopDriver << "         //" << endl;
  oPopDriver << "         //     -----------------------------------  ." << endl;
  oPopDriver << "         //" << endl;
  oPopDriver << "         //        nBMeasurePointPerDimIn - 1" << endl;
  oPopDriver << "         //" << endl;
  oPopDriver << "         for( int j=0; j<nBMeasurePointIn; j++ )" << endl;
  oPopDriver << "         {" << endl;
  oPopDriver << "            for(int k = 0; k < nBTwoStageOrNonparam; k++)" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               bMeasurePointIn[k + j * nBTwoStageOrNonparam] = " << endl;
  oPopDriver << "                 bNonparamLow[k] +" << endl;
  oPopDriver << "                 ( index[k] - 1 ) * " << endl;
  oPopDriver << "                 ( bNonparamUp[k] - bNonparamLow[k] ) / ( nBMeasurePointPerDimIn - 1 );" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << endl;
  oPopDriver << "            // Add one to the last element's index." << endl;
  oPopDriver << "            index[nBTwoStageOrNonparam - 1]++;" << endl;
  oPopDriver << endl;
  oPopDriver << "            // Update all of the elements' indices." << endl;
  oPopDriver << "            for(int k = nBTwoStageOrNonparam - 1; k > 0; k--)" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               // See if this index is larger than the number of" << endl;
  oPopDriver << "               // points per dimension." << endl;
  oPopDriver << "               if ( index[k] > nBMeasurePointPerDimIn )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  // Reset this element's index to one." << endl;
  oPopDriver << "                  index[k] = 1;" << endl;
  oPopDriver << endl;
  oPopDriver << "                  // Add one to the index for the previous element," << endl;
  oPopDriver << "                  // i.e., do a carry operation like in addition." << endl;
  oPopDriver << "                  index[k-1]++;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "         }" << endl;
  oPopDriver << "      }" << endl;
  oPopDriver << "      else" << endl;
  oPopDriver << "      {" << endl;
  oPopDriver << "         for( int i=0; i<nPop; i++ )" << endl;
  oPopDriver << "         {" << endl;
  oPopDriver << "            model.selectIndividual( i ); " << endl;
  oPopDriver << "            model.getIndPar( biIn );" << endl;
  oPopDriver << "            bIn[ slice(i*nB, nB, 1) ] = biIn;" << endl;
  oPopDriver << "         }" << endl;
  oPopDriver << "      }" << endl;
  oPopDriver << endl;

  oPopDriver << "      timeval optBegin, optEnd;" << endl;
  oPopDriver << "      double  optTimeSec = 0.0;" << endl;
  oPopDriver << "      const   double popEps             = "   << myPopEpsilon    << ";" << endl;
  oPopDriver << "      const   int    popMitr            = "   << myPopMitr       << ";" << endl;
  oPopDriver << "      const   int    popTrace           = "   << myPopTraceLevel << ";" << endl;
  oPopDriver << "      const   string popCheckpointFile  = \"" << fCheckpoint_xml << "\";" << endl;
  oPopDriver << "      bool           popWriteCheckpoint = "   << (myPopWriteCheckpoint? "true":"false") << ";" << endl;
  oPopDriver << "      bool           isPopOptAtMaxIter  = false;" << endl;
  oPopDriver << "      ifstream       iCheckpoint( popCheckpointFile.c_str() );"  << endl;
  oPopDriver << "      // Error if the user asked to continue but no checkpoint.xml is found " << endl;
  oPopDriver << "      // in the current directory." << endl;
  oPopDriver << "      if( isRestartRequested && !iCheckpoint.good() )" << endl;
  oPopDriver << "      {" << endl;
  oPopDriver << "         char m[ SpkError::maxMessageLen()];" << endl;
  oPopDriver << "         snprintf( m, " << endl;
  oPopDriver << "                   SpkError::maxMessageLen()," << endl;
  oPopDriver << "                   \"Warm start is request but no checkpoint file found.\" );" << endl;
  oPopDriver << "         SpkError e( SpkError::SPK_STD_ERR, m, __LINE__, __FILE__);" << endl;
  oPopDriver << "         errors.push( e );" << endl;
  oPopDriver << "         ret = FILE_ACCESS_ERROR;" << endl;
  oPopDriver << "      }" << endl;
  oPopDriver << "      // Flag to read the checkpoint file if that exists even " << endl;
  oPopDriver << "      // if the user didn't ask a continuation." << endl;
  oPopDriver << "      bool           popReadCheckpoint  = iCheckpoint.good();"   << endl;
  oPopDriver << "      iCheckpoint.close();"                                    << endl;
  oPopDriver << "      Optimizer      popOpt( popEps, "                           << endl;
  oPopDriver << "                             popMitr, "                          << endl;
  oPopDriver << "                             popTrace, "                         << endl;
  oPopDriver << "                             popCheckpointFile, "                << endl;
  oPopDriver << "                             popReadCheckpoint,"                 << endl;
  oPopDriver << "                             popWriteCheckpoint );"              << endl;
  oPopDriver << endl;
  oPopDriver << "      const double   indEps   = " << myIndEpsilon    << ";" << endl;
  oPopDriver << "      const int      indMitr  = " << myIndMitr       << ";" << endl;
  oPopDriver << "      const int      indTrace = " << myIndTraceLevel << ";" << endl;
  oPopDriver << "      Optimizer      indOpt( indEps, indMitr, indTrace );"  << endl;
  oPopDriver << endl;
 
  oPopDriver << "      timeval statBegin, statEnd;"                               << endl;
  oPopDriver << "      double statTimeSec = 0.0;"                                 << endl;
  oPopDriver << "      valarray<double> alpCov( nAlp * nAlp );"                   << endl;
  oPopDriver << "      valarray<double> stdPar( nAlp );"                          << endl;
  oPopDriver << "      valarray<double> stdPar_alp( nAlp * nAlp );"               << endl;
  oPopDriver << "      valarray<bool>   stdParMask( nAlp );"                      << endl;
  oPopDriver << "      const int nDegOfFreedom = nY - nAlp;"                      << endl;
  oPopDriver << "      bool isCovOut         = " << ( myIsCov?    "true" : "false" ) << ";"      << endl;
  oPopDriver << "      bool isInvCovOut      = " << ( myIsInvCov? "true" : "false" ) << ";"      << endl;
  oPopDriver << "      bool isStdErrOut      = " << ( myIsStderr? "true" : "false" ) << ";"      << endl;
  oPopDriver << "      bool isCorrelationOut = " << ( myIsCorrelation? "true" : "false" ) << ";" << endl;
  oPopDriver << "      bool isCoefficientOut = " << ( myIsCoefficient? "true" : "false" ) << ";" << endl;
  oPopDriver << "      bool isConfidenceOut  = " << ( myIsConfidence?  "true" : "false" ) << ";" << endl;
  oPopDriver << "      valarray<double> stdParCovOut        ( nAlp * nAlp );"     << endl;
  oPopDriver << "      valarray<double> stdParSEOut         ( nAlp );"            << endl;
  oPopDriver << "      valarray<double> stdParCorrelationOut( nAlp * nAlp );"     << endl;
  oPopDriver << "      valarray<double> stdParCoefficientOut( nAlp );"            << endl;
  oPopDriver << "      valarray<double> stdParConfidenceOut ( 2 * nAlp );"        << endl;
  oPopDriver << "      valarray<double> stdParInvCovOut     ( nAlp * nAlp );"     << endl;
  oPopDriver << endl;

  oPopDriver << "      int nTotalRecords = 0;" << endl;
  oPopDriver << "      for( int i=0; i<nPop; i++ )" << endl;
  oPopDriver << "         nTotalRecords += NRecords[i];" << endl;
  oPopDriver << endl;
  oPopDriver << "      valarray<double> predOut               ( nTotalRecords );"      << endl;
  oPopDriver << "      valarray<double> resOut                ( nTotalRecords );"      << endl;
  oPopDriver << "      valarray<double> resWtdOut             ( nTotalRecords );"      << endl;
  oPopDriver << "      valarray<double> parResOut             ( nB*nPop );" << endl;
  oPopDriver << "      valarray<double> parResWtdOut          ( nB*nPop );" << endl;
  oPopDriver << "      valarray<double> predTruncatedOut      ( nY );"      << endl;
  oPopDriver << "      valarray<double> resTruncatedOut       ( nY );"      << endl;
  oPopDriver << "      valarray<double> resWtdTruncatedOut    ( nY );"      << endl;
  oPopDriver << endl;
  oPopDriver << "      valarray<double> iPredOut              ( nTotalRecords );"      << endl;
  oPopDriver << "      valarray<double> iResOut               ( nTotalRecords );"      << endl;
  oPopDriver << "      valarray<double> iResWtdOut            ( nTotalRecords );"      << endl;
  oPopDriver << "      valarray<double> iParResOut            ( nB*nPop );" << endl;
  oPopDriver << "      valarray<double> iParResWtdOut         ( nB*nPop );" << endl;
  oPopDriver << "      valarray<double> iPredTruncatedOut     ( nY );"      << endl;
  oPopDriver << "      valarray<double> iResTruncatedOut      ( nY );"      << endl;
  oPopDriver << "      valarray<double> iResWtdTruncatedOut   ( nY );"      << endl;
  oPopDriver << endl;
  oPopDriver << "      valarray<double> pPredOut              ( nTotalRecords );"      << endl;
  oPopDriver << "      valarray<double> pResOut               ( nTotalRecords );"      << endl;
  oPopDriver << "      valarray<double> pResWtdOut            ( nTotalRecords );"      << endl;
  oPopDriver << "      valarray<double> pParResOut            ( nB*nPop );" << endl;
  oPopDriver << "      valarray<double> pParResWtdOut         ( nB*nPop );" << endl;
  oPopDriver << "      valarray<double> pPredTruncatedOut     ( nY );"      << endl;
  oPopDriver << "      valarray<double> pResTruncatedOut      ( nY );"      << endl;
  oPopDriver << "      valarray<double> pResWtdTruncatedOut   ( nY );"      << endl;
  oPopDriver << endl;
  oPopDriver << "      valarray<double> cPredOut              ( nTotalRecords );"      << endl;
  oPopDriver << "      valarray<double> cResOut               ( nTotalRecords );"      << endl;
  oPopDriver << "      valarray<double> cResWtdOut            ( nTotalRecords );"      << endl;
  oPopDriver << "      valarray<double> cParResOut            ( nB*nPop );" << endl;
  oPopDriver << "      valarray<double> cParResWtdOut         ( nB*nPop );" << endl;
  oPopDriver << "      valarray<double> cPredTruncatedOut     ( nY );"      << endl;
  oPopDriver << "      valarray<double> cResTruncatedOut      ( nY );"      << endl;
  oPopDriver << "      valarray<double> cResWtdTruncatedOut   ( nY );"      << endl;
  oPopDriver << endl;

  oPopDriver << "      double zero = 0.0;" << endl;
  oPopDriver << endl;
  oPopDriver << "      // Initially set all of these equal to Not a Numbers (NaN) to" << endl;
  oPopDriver << "      // indicate that their values have not yet been calculated." << endl;
  oPopDriver << "      predOut    = zero / zero;" << endl;
  oPopDriver << "      resOut     = zero / zero;" << endl;
  oPopDriver << "      resWtdOut  = zero / zero;" << endl;
  oPopDriver << "      iPredOut   = zero / zero;" << endl;
  oPopDriver << "      iResOut    = zero / zero;" << endl;
  oPopDriver << "      iResWtdOut = zero / zero;" << endl;
  oPopDriver << "      pPredOut   = zero / zero;" << endl;
  oPopDriver << "      pResOut    = zero / zero;" << endl;
  oPopDriver << "      pResWtdOut = zero / zero;" << endl;
  oPopDriver << "      cPredOut   = zero / zero;" << endl;
  oPopDriver << "      cResOut    = zero / zero;" << endl;
  oPopDriver << "      cResWtdOut = zero / zero;" << endl;
  oPopDriver << endl;

  oPopDriver << "      ofstream oResults;" << endl;
  oPopDriver << "      string warningsOut;" << endl;
  oPopDriver << "      int iSub = 0;" << endl;
  oPopDriver << endl;

  // do data simulation first to replace DV data in IndData objects
  oPopDriver << "      if( ret != SUCCESS )" << endl;
  oPopDriver << "        goto REPORT_GEN;" << endl;
  oPopDriver << endl;
  oPopDriver << "      remove( \"result.xml\" );" << endl;
  oPopDriver << "      for( iSub=0; iSub<nRepeats; iSub++ )" << endl;
  oPopDriver << "      {" << endl;
  oPopDriver << "         /*******************************************************************/" << endl;
  oPopDriver << "         /*                                                                 */" << endl;
  oPopDriver << "         /*   Data Initialization                                           */" << endl;
  oPopDriver << "         /*                                                                 */" << endl;
  oPopDriver << "         /*******************************************************************/" << endl;
  oPopDriver << "         if( isSimRequested )" << endl;
  oPopDriver << "         {" << endl;
  oPopDriver << "            valarray<double> yOut( nY );" << endl;
  oPopDriver << "            try" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               simulate( model, alpIn, NObservs, bLow, bUp, yOut, bOut );" << endl;
  oPopDriver << "               bIn = bOut;" << endl;
  oPopDriver << "               set.replaceAllMeasurements( yOut );" << endl;
  oPopDriver << "               y   = yOut;" << endl;
  oPopDriver << "               haveCompleteData = true;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            catch( const SpkException& e )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               errors.cat( e );" << endl;
  oPopDriver << "               haveCompleteData = false;" << endl;
  oPopDriver << "               ret = SIMULATION_ERROR;" << endl;
  oPopDriver << "               goto REPORT_GEN;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            catch( const std::exception& stde )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               char message[] =\"A standard exception occurred in data simulation.\";" << endl;
  oPopDriver << "               SpkError e( stde, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "               errors.push( e );" << endl;
  oPopDriver << "               haveCompleteData = false;" << endl;
  oPopDriver << "               ret = SIMULATION_ERROR;" << endl;
  oPopDriver << "               goto REPORT_GEN;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            catch( ... )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               char message[] =\"An unknown exception occurred in data simulation.\";" << endl;
  oPopDriver << "               SpkError e( SpkError::SPK_UNKNOWN_ERR, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "               errors.push( e );" << endl;
  oPopDriver << "               haveCompleteData = false;" << endl;
  oPopDriver << "               ret = SIMULATION_ERROR;" << endl;
  oPopDriver << "               goto REPORT_GEN;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "         }" << endl;
  oPopDriver << "         else" << endl;
  oPopDriver << "         {" << endl;
  oPopDriver << "            y = set.getAllMeasurements();" << endl;
  oPopDriver << "            haveCompleteData = true;" << endl;
  oPopDriver << endl;
  oPopDriver << "         }" << endl;
  oPopDriver << endl;
 
  oPopDriver << "OPTIMIZATION:" << endl;
  oPopDriver << "         /*******************************************************************/" << endl;
  oPopDriver << "         /*                                                                 */" << endl;
  oPopDriver << "         /*   Parameter Estimation                                          */" << endl;
  oPopDriver << "         /*                                                                 */" << endl;
  oPopDriver << "         /*******************************************************************/" << endl;
  oPopDriver << "         if( isOptRequested && haveCompleteData )" << endl;
  oPopDriver << "         {" << endl;
  oPopDriver << "            gettimeofday( &optBegin, NULL );" << endl;
  oPopDriver << "            try" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               if( isTwoStageMethod )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  // Perform the two-stage analysis." << endl;
  oPopDriver << "                  predTwoStageMethod( model," << endl;
  oPopDriver << "                                      indModelForTwoStageOrNonparam," << endl;
  oPopDriver << "                                      objective," << endl;
  oPopDriver << "                                      NObservs," << endl;
  oPopDriver << "                                      y," << endl;
  oPopDriver << "                                      popOpt," << endl;
  oPopDriver << "                                      indOpt," << endl;
  oPopDriver << "                                      &bTwoStageOrNonparamOut );" << endl;
  oPopDriver << endl;
  oPopDriver << "                  // The two-stage methods do not provide values for" << endl;
  oPopDriver << "                  // the eta values that appear in the population" << endl;
  oPopDriver << "                  // model, so just set them all equal to zero." << endl;
  oPopDriver << "                  bOut = 0.0;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               else if( isNonparamMethod )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  // Perform the nonparametric population analysis." << endl;
  oPopDriver << "                  predNonparamMethod( model," << endl;
  oPopDriver << "                                      indModelForTwoStageOrNonparam," << endl;
  oPopDriver << "                                      indModelForTwoStageOrNonparamAD," << endl;
  oPopDriver << "                                      NObservs," << endl;
  oPopDriver << "                                      y," << endl;
  oPopDriver << "                                      popOpt," << endl;
  oPopDriver << "                                      indOpt," << endl;
  oPopDriver << "                                      bNonparamLow," << endl;
  oPopDriver << "                                      bNonparamUp," << endl;
  oPopDriver << "                                      bMeasurePointIn," << endl;
  oPopDriver << "                                      &alpObjOut," << endl;
  oPopDriver << "                                      &bMeasurePointOut," << endl;
  oPopDriver << "                                      &bWeightOut," << endl;
  oPopDriver << "                                      &bProbDensityOut," << endl;
  oPopDriver << "                                      &bPostMeanOut );" << endl;
  oPopDriver << endl;
  oPopDriver << "                  // Set the individual parameter values that are used" << endl;
  oPopDriver << "                  // for calculating residuals equal to the posterior" << endl;
  oPopDriver << "                  // mean for each individual." << endl;
  oPopDriver << "                  bTwoStageOrNonparamOut = bPostMeanOut;" << endl;
  oPopDriver << endl;
  oPopDriver << "                  // The nonparametric method does not provide values" << endl;
  oPopDriver << "                  // for the eta values that appear in the population" << endl;
  oPopDriver << "                  // model, so just set them all equal to zero." << endl;
  oPopDriver << "                  bOut = 0.0;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               else" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  // Set this so the population level optimization will" << endl;
  oPopDriver << "                  // not throw an exception when the maximum number of" << endl;
  oPopDriver << "                  // iterations is used." << endl;
  oPopDriver << "                  popOpt.setThrowExcepIfMaxIter( false );" << endl;
  oPopDriver << endl;
  oPopDriver << "                  // Perform the parametric population analysis." << endl;
  oPopDriver << "                  fitPopulation( model," << endl;
  oPopDriver << "                                 modelAD, " << endl;
  oPopDriver << "                                 objective, " << endl;
  oPopDriver << "                                 NObservs," << endl;
  oPopDriver << "                                 y," << endl;
  oPopDriver << "                                 popOpt," << endl;
  oPopDriver << "                                 alpLow," << endl;
  oPopDriver << "                                 alpUp," << endl;
  oPopDriver << "                                 alpIn," << endl;
  oPopDriver << "                                 alpStep," << endl;
  oPopDriver << "                                &alpOut," << endl;
  oPopDriver << "                                 indOpt," << endl;
  oPopDriver << "                                 bLow," << endl;
  oPopDriver << "                                 bUp," << endl;
  oPopDriver << "                                 bIn," << endl;
  oPopDriver << "                                 bStep," << endl;
  oPopDriver << "                                &bOut," << endl;
  oPopDriver << "                                &alpObjOut," << endl;
  oPopDriver << "                                &alpObj_alpOut," << endl;
  oPopDriver << "                                 NULL," << endl;
  oPopDriver << "                                 nPvmTasks );" << endl;
  oPopDriver << endl;
  oPopDriver << "                  // Check the individual level optimizer to see if" << endl;
  oPopDriver << "                  // the maximum number of iterations was reached.  If" << endl;
  oPopDriver << "                  // so, it should have resulted in an exception." << endl;
  oPopDriver << "                  if ( indOpt.getIsTooManyIter() )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     char message[] = \"Individual level optimization failed in an unexpected way. \\n\\nPlease submit a bug report.\";" << endl;
  oPopDriver << "                     SpkError e( SpkError::SPK_TOO_MANY_ITER, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "                     errors.push( e );" << endl;
  oPopDriver << "                     isOptSuccess = false;" << endl;
  oPopDriver << "                     ret = OPT_MAX_ITER_ERROR;" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << endl;
  oPopDriver << "                  // Check the population level optimizer to see if" << endl;
  oPopDriver << "                  // the maximum number of iterations was reached." << endl;
  oPopDriver << "                  if ( popOpt.getIsTooManyIter() )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     isPopOptAtMaxIter = true;" << endl;
  oPopDriver << "                     ret = OPT_MAX_ITER_REACHED;" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "                  else" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     isPopOptAtMaxIter = false;" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << endl;
  oPopDriver << "                  // Give the model the optimal parameter value." << endl;
  oPopDriver << "                  model.setPopPar( alpOut );" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               isOptSuccess = true;"          << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            catch( SpkException& e )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               if( e.find( SpkError::SPK_TOO_MANY_ITER ) >= 0 )" << endl;
  oPopDriver << "                  ret = OPT_MAX_ITER_ERROR;" << endl;
  oPopDriver << "               else" << endl;
  oPopDriver << "                  ret = OPTIMIZATION_ERROR;" << endl;
  oPopDriver << "               errors.cat( e );" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            catch( const std::exception& stde )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               char message[] = \"A standard exception occurred in parameter estimation.\";" << endl;
  oPopDriver << "               SpkError e( stde, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "               errors.push( e );" << endl;
  oPopDriver << "               isOptSuccess = false;" << endl;
  oPopDriver << "               ret = OPTIMIZATION_ERROR;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            catch( ... )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               char message[] = \"An unknown exception occurred in parameter estimation.\";" << endl;
  oPopDriver << "               SpkError e( SpkError::SPK_UNKNOWN_ERR, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "               errors.push( e );" << endl;
  oPopDriver << "               isOptSuccess = false;" << endl;
  oPopDriver << "               ret = OPTIMIZATION_ERROR;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            gettimeofday( &optEnd, NULL );" << endl;
  oPopDriver << "            optTimeSec = difftime( optEnd.tv_sec, optBegin.tv_sec );" << endl;
  oPopDriver << endl;
  oPopDriver << "            // Add a warning message if the optimization failed." << endl;
  oPopDriver << "            if ( !isOptSuccess )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               WarningsManager::addWarning(" << endl;
  oPopDriver << "                  \"The objective function, parameters, and presentation values were calculated \\nat the last successful optimizer iteration before any errors occurred.\"," << endl;
  oPopDriver << "                  __LINE__," << endl;
  oPopDriver << "                  __FILE__ );" << endl;
  oPopDriver << endl;
  oPopDriver << "               // Get the variable information if this job was not run" << endl;
  oPopDriver << "               // in parallel mode." << endl;
  oPopDriver << "               // " << endl;
  oPopDriver << "               // In parallel mode the values are calculated and" << endl;
  oPopDriver << "               // stored in the version of mPred that is on the" << endl;
  oPopDriver << "               // individual node where the failure occurred, i.e.," << endl;
  oPopDriver << "               // the values for this mPred have not been defined." << endl;
  oPopDriver << "               string varInfoMessage;" << endl;
  oPopDriver << "               if ( nPvmTasks < 2 )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  WarningsManager::addWarning(" << endl;
  oPopDriver << "                     \"See the optimization trace for variable values calculated at the last parameter \\nvalue tried by the optimizer.\"," << endl;
  oPopDriver << "                     __LINE__," << endl;
  oPopDriver << "                     __FILE__ );" << endl;
  oPopDriver << endl;
  oPopDriver << "                  if( !isTwoStageMethod && !isNonparamMethod )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     mPred.getVariableInfo( varInfoMessage );" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "                  else" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     predForDisposal.getVariableInfo( varInfoMessage );" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << endl;
  oPopDriver << "                  // Send the variable information to the trace." << endl;
  oPopDriver << "                  cout << endl;" << endl;
  oPopDriver << "                  cout << endl;" << endl;
  oPopDriver << "                  cout << \"The following variables had these values at the last parameter value tried \\nby the optimizer:\";" << endl;
  oPopDriver << "                  cout << endl;" << endl;
  oPopDriver << "                  cout << endl;" << endl;
  oPopDriver << "                  cout << varInfoMessage << endl;" << endl;
  oPopDriver << "                  cout << endl;" << endl;
  oPopDriver << "                  cout << endl;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << endl;
  oPopDriver << "            // Get the best values of theta, Omega, and Sigma." << endl;
  oPopDriver << "            if ( isOptSuccess )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               model.getTheta( thetaOut );" << endl;
  oPopDriver << "               model.getOmega( omegaOut );" << endl;
  oPopDriver << "               model.getSigma( sigmaOut );" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            else" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               // Set the objective function and parameter value from" << endl;
  oPopDriver << "               // the last successful optimizer iteration, which is" << endl;
  oPopDriver << "               // the best value that it was able to obtain." << endl;
  oPopDriver << "               popOpt.getObj( alpObjOut );" << endl;
  oPopDriver << "               popOpt.getPar( alpOut );" << endl;
  oPopDriver << endl;
  oPopDriver << "               // Give the model the optimal parameter value." << endl;
  oPopDriver << "               model.setPopPar( alpOut );" << endl;
  oPopDriver << endl;
  oPopDriver << "               model.getTheta( thetaOut );" << endl;
  oPopDriver << "               model.getOmega( omegaOut );" << endl;
  oPopDriver << "               model.getSigma( sigmaOut );" << endl;
  oPopDriver << " " << endl;
  oPopDriver << "               // Calculate bOut( alpOut )." << endl;
  oPopDriver << "               if( !isTwoStageMethod && !isNonparamMethod )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  try" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     // Set this so that no population level optimization" << endl;
  oPopDriver << "                     // is performed." << endl;
  oPopDriver << "                     popOpt.setNMaxIter( 0 );" << endl;
  oPopDriver << endl;
  oPopDriver << "                     // Evaluate each individual's parameter value b_i" << endl;
  oPopDriver << "                     // at alpOut." << endl;
  oPopDriver << "                     fitPopulation( modelForDisposal," << endl;
  oPopDriver << "                                    modelForDisposalAD, " << endl;
  oPopDriver << "                                    objective, " << endl;
  oPopDriver << "                                    NObservs," << endl;
  oPopDriver << "                                    y," << endl;
  oPopDriver << "                                    popOpt," << endl;
  oPopDriver << "                                    alpLow," << endl;
  oPopDriver << "                                    alpUp," << endl;
  oPopDriver << "                                    alpOut," << endl;
  oPopDriver << "                                    alpStep," << endl;
  oPopDriver << "                                    NULL," << endl;
  oPopDriver << "                                    indOpt," << endl;
  oPopDriver << "                                    bLow," << endl;
  oPopDriver << "                                    bUp," << endl;
  oPopDriver << "                                    bIn," << endl;
  oPopDriver << "                                    bStep," << endl;
  oPopDriver << "                                    &bOut," << endl;
  oPopDriver << "                                    NULL," << endl;
  oPopDriver << "                                    NULL," << endl;
  oPopDriver << "                                    NULL," << endl;
  oPopDriver << "                                    0 );" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "                  catch( SpkException& e )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     char mess[ SpkError::maxMessageLen() ];" << endl;
  oPopDriver << "                     snprintf( mess, " << endl;
  oPopDriver << "                               SpkError::maxMessageLen()," << endl;
  oPopDriver << "                              \"Failed to compute the optimal individual parameter values.\\n\" );" << endl;
  oPopDriver << "                     e.push( SpkError::SPK_OPT_ERR, mess, __LINE__, __FILE__ );" << endl;
  oPopDriver << "                     errors.cat( e );" << endl;
  oPopDriver << "                     isStatSuccess &= false;" << endl;
  oPopDriver << "                     ret = OPTIMIZATION_ERROR;" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "                  catch( const std::exception& stde )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     char message[] = \"A standard exception occurred in the optimal individual parameter calculation.\";" << endl;
  oPopDriver << "                     SpkError e( stde, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "                     errors.push( e );" << endl;
  oPopDriver << "                     isStatSuccess &= false;" << endl;
  oPopDriver << "                     ret = OPTIMIZATION_ERROR;" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "                  catch( ... )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     char message[] = \"An unknown exception occurred in the optimal individual parameter calculation.\";" << endl;
  oPopDriver << "                     SpkError e( SpkError::SPK_UNKNOWN_ERR, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "                     errors.push( e );" << endl;
  oPopDriver << "                     isStatSuccess &= false;" << endl;
  oPopDriver << "                     ret = OPTIMIZATION_ERROR;" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << endl;
  oPopDriver << "            set.replaceEta( bOut );" << endl;
  oPopDriver << endl;
  oPopDriver << "            if( !isOptSuccess )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               string optErrHeader;" << endl;
  oPopDriver << "               string optErrMessage;" << endl;
  oPopDriver << "               oLongError.open( \"" << fSpkRuntimeLongError_tmp << "\" );" << endl;
  oPopDriver << "               if( !oLongError.good() )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  char m[ SpkError::maxMessageLen() ];" << endl;
  oPopDriver << "                  snprintf( m, " << endl;
  oPopDriver << "                            SpkError::maxMessageLen()," << endl;
  oPopDriver << "                            \"Failed to create a temporary file, %s, for writing.\", " << endl;
  oPopDriver << "                           \"" << fSpkRuntimeLongError_tmp << "\" );" << endl;
  oPopDriver << "                  SpkError e( SpkError::SPK_STD_ERR, m, __LINE__, __FILE__ );" << endl;
  oPopDriver << "                  errors.push( e );" << endl;
  oPopDriver << "                  ret = FILE_ACCESS_ERROR;" << endl;
  oPopDriver << "                  goto REPORT_GEN;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               // If individual level estimation failed, then get any details as to why." << endl;
  oPopDriver << "               if( indOpt.isThereErrorInfo() )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  optErrHeader  = \"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \\n\";" << endl;
  oPopDriver << "                  optErrHeader += \"Individual level optimization failure details. \\n\";" << endl;
  oPopDriver << "                  optErrHeader += \"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \\n\";" << endl;
  oPopDriver << "                  optErrHeader += \"\\n\";" << endl;
  oPopDriver << "                  indOpt.getErrorInfo(" << endl;
  oPopDriver << "                                       optErrHeader," << endl;
  oPopDriver << "                                       optErrMessage," << endl;
  oPopDriver << "                                       __LINE__," << endl;
  oPopDriver << "                                       __FILE__ );" << endl;
  oPopDriver << "                  oLongError << optErrMessage << endl;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               // If population level estimation failed, then get any details as to why." << endl;
  oPopDriver << "               if( popOpt.isThereErrorInfo() )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  optErrHeader  = \"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \\n\";" << endl;
  oPopDriver << "                  optErrHeader += \"Population level optimization failure details. \\n\";" << endl;
  oPopDriver << "                  optErrHeader += \"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \\n\";" << endl;
  oPopDriver << "                  optErrHeader += \"\\n\";" << endl;
  oPopDriver << "                  popOpt.getErrorInfo(" << endl;
  oPopDriver << "                                       optErrHeader," << endl;
  oPopDriver << "                                       optErrMessage," << endl;
  oPopDriver << "                                       __LINE__," << endl;
  oPopDriver << "                                       __FILE__ );" << endl;
  oPopDriver << "                  oLongError << optErrMessage << endl;" << endl;
  oPopDriver << "                  oLongError.close();" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "         }" << endl;
  oPopDriver << endl;

  oPopDriver << "         // Calculate the residuals for the parametric methods." << endl;
  oPopDriver << "         if( isOptRequested && isOptSuccess && !isTwoStageMethod && !isNonparamMethod )" << endl;
  oPopDriver << "         {" << endl;
  oPopDriver << "            assert( haveCompleteData );" << endl;
  oPopDriver << "            Objective objForDisposal = FIRST_ORDER;"    << endl;
  oPopDriver << "            valarray<double> yi;"                       << endl;
  oPopDriver << "            valarray<double> fi;"                       << endl;
  oPopDriver << "            valarray<double> bi( nB );"                 << endl;
  oPopDriver << "            valarray<double> ipredOut;"                 << endl;
  oPopDriver << "            valarray<double> iiPredOut;"                << endl;
  oPopDriver << "            valarray<double> iiResOut; "                << endl;
  oPopDriver << "            valarray<double> iiResWtdOut;"              << endl;
  oPopDriver << "            valarray<double> iiParResOut( nB );"        << endl;
  oPopDriver << "            valarray<double> iiParResWtdOut( nB );"     << endl;
  oPopDriver << "            valarray<double> iiResTruncatedOut; "       << endl;
  oPopDriver << "            valarray<double> iiResWtdTruncatedOut;"     << endl;
  oPopDriver << "            model           .setPopPar( alpOut );"      << endl;
  oPopDriver << "            modelForDisposal.setPopPar( alpOut );"      << endl;
  oPopDriver << "            for( int i=0, j=0, k=0; i<nPop; j+=NObservs[i], k+=NRecords[i++] )"     << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               yi.resize         ( NObservs[i] );"             << endl;
  oPopDriver << "               fi.resize         ( NObservs[i] );"             << endl;
  oPopDriver << "               iiResOut.resize   ( NRecords[i] );" << endl;
  oPopDriver << "               iiResWtdOut.resize( NRecords[i] );" << endl;
  oPopDriver << "               iiResTruncatedOut.resize   ( NObservs[i] );"    << endl;
  oPopDriver << "               iiResWtdTruncatedOut.resize( NObservs[i] );"    << endl;
  oPopDriver << "               yi = y[ slice( j, NObservs[i], 1 ) ]; "         << endl;
  oPopDriver << "               bi = bOut[ slice( i*nB, nB, 1 ) ];"      << endl;
  oPopDriver << "               model           .selectIndividual( i );" << endl;
  oPopDriver << "               modelForDisposal.selectIndividual( i );" << endl;
  oPopDriver << "               // Calculate the residuals if the individual's" << endl;
  oPopDriver << "               // parameter has no Not a Number (NaN) values." << endl;
  oPopDriver << "               if ( !CppAD::hasnan( bi ) )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                 model           .setIndPar( bi );" << endl;
  oPopDriver << "                 modelForDisposal.setIndPar( bi );" << endl;
  oPopDriver << "                 try{" << endl;
  oPopDriver << "                    // Make sure each individual's data mean values has" << endl;
  oPopDriver << "                    // been calculated at the optimal parameter values." << endl;
  oPopDriver << "                    model.dataMean( fi );" << endl;
  oPopDriver << endl;
  oPopDriver << "                    // Don't calculate the individual's PRED values." << endl;
  oPopDriver << "                    valarray<double>* pVANull = 0;" << endl;
  oPopDriver << "                    indResiduals( modelForDisposal," << endl;
  oPopDriver << "                                  yi, " << endl;
  oPopDriver << "                                  bi," << endl;
  oPopDriver << "                                  pVANull," << endl;
  oPopDriver << "                                 &iiResTruncatedOut," << endl;
  oPopDriver << "                                 &iiResWtdTruncatedOut, " << endl;
  oPopDriver << "                                 &iiParResOut, " << endl;
  oPopDriver << "                                 &iiParResWtdOut );" << endl;
  oPopDriver << "                    dataForDisposal.expand( i, iiResTruncatedOut,    iiResOut );" << endl;
  oPopDriver << "                    dataForDisposal.expand( i, iiResWtdTruncatedOut, iiResWtdOut );" << endl;
  oPopDriver << "                 }" << endl;
  oPopDriver << "                 catch( SpkException& e )" << endl;
  oPopDriver << "                 {" << endl;
  oPopDriver << "                    char message[SpkError::maxMessageLen()];" << endl;
  oPopDriver << "                    snprintf( message, " << endl;
  oPopDriver << "                              SpkError::maxMessageLen()," << endl;
  oPopDriver << "                              \"Failed during the calculation of %i-th individual's residuals!\", i );" << endl;
  oPopDriver << "                    SpkError ee( SpkError::SPK_STATISTICS_ERR, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "                    e.push( ee );" << endl;
  oPopDriver << "                    errors.cat( e );" << endl;
  oPopDriver << "                    isStatSuccess &= false;" << endl;
  oPopDriver << "                    if ( !isPopOptAtMaxIter )" << endl;
  oPopDriver << "                       ret = OPT_OK_RESID_ERROR;" << endl;
  oPopDriver << "                    else" << endl;
  oPopDriver << "                       ret = OPT_MAX_ITER_RESID_ERROR;" << endl;
  oPopDriver << "                 }" << endl;
  oPopDriver << "                 catch( const std::exception& stde )" << endl;
  oPopDriver << "                 {" << endl;
  oPopDriver << "                    char message[SpkError::maxMessageLen()];" << endl;
  oPopDriver << "                    snprintf( message, " << endl;
  oPopDriver << "                              SpkError::maxMessageLen()," << endl;
  oPopDriver << "                             \"A standard exception occurred during the calculation of %i-th individual's residuals.\", i );" << endl;
  oPopDriver << "                    SpkError e( stde, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "                    errors.push( e );" << endl;
  oPopDriver << "                    isStatSuccess &= false;" << endl;
  oPopDriver << "                    if ( !isPopOptAtMaxIter )" << endl;
  oPopDriver << "                       ret = OPT_OK_RESID_ERROR;" << endl;
  oPopDriver << "                    else" << endl;
  oPopDriver << "                       ret = OPT_MAX_ITER_RESID_ERROR;" << endl;
  oPopDriver << "                 }" << endl;
  oPopDriver << "                 catch( ... )" << endl;
  oPopDriver << "                 {" << endl;
  oPopDriver << "                    char message[SpkError::maxMessageLen()];" << endl;
  oPopDriver << "                    snprintf( message, " << endl;
  oPopDriver << "                              SpkError::maxMessageLen()," << endl;
  oPopDriver << "                             \"An unknown exception occurred during the calculation of %i-th individual's residuals.\", i );" << endl;
  oPopDriver << "                    SpkError e( SpkError::SPK_UNKNOWN_ERR, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "                    errors.push( e );" << endl;
  oPopDriver << "                    isStatSuccess &= false;" << endl;
  oPopDriver << "                    if ( !isPopOptAtMaxIter )" << endl;
  oPopDriver << "                       ret = OPT_OK_RESID_ERROR;" << endl;
  oPopDriver << "                    else" << endl;
  oPopDriver << "                       ret = OPT_MAX_ITER_RESID_ERROR;" << endl;
  oPopDriver << "                 }" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               else" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                 // Fill these with NaN's if bi contained NaN's." << endl;
  oPopDriver << "                 iiResOut       = zero / zero;" << endl;
  oPopDriver << "                 iiResWtdOut    = zero / zero;" << endl;
  oPopDriver << "                 iiParResOut    = zero / zero;" << endl;
  oPopDriver << "                 iiParResWtdOut = zero / zero;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               iResOut      [ slice( k, NRecords[i], 1 ) ]  = iiResOut;"       << endl;
  oPopDriver << "               iResWtdOut   [ slice( k, NRecords[i], 1 ) ]  = iiResWtdOut;"    << endl;
  oPopDriver << "               iParResOut   [ slice( nB*i, nB, 1 ) ] = iiParResOut;"    << endl;
  oPopDriver << "               iParResWtdOut[ slice( nB*i, nB, 1 ) ] = iiParResWtdOut;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            // Set the IPRED values here so that they have values for" << endl;
  oPopDriver << "            // all of the data records.  Note that the OdePred" << endl;
  oPopDriver << "            // evaluator only saves values after the last individuals'" << endl;
  oPopDriver << "            // last data record has been accessed." << endl;
  oPopDriver << "            for( int i=0, k=0; i<nPop; k+=NRecords[i++] )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               iiPredOut.resize( NRecords[i] );" << endl;
  oPopDriver << "               bi = bOut[ slice( i*nB, nB, 1 ) ];" << endl;
  oPopDriver << "               // Use the calculated values if the individual's" << endl;
  oPopDriver << "               // parameter has no Not a Number (NaN) values." << endl;
  oPopDriver << "               if ( !CppAD::hasnan( bi ) )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                 for( int j=0; j<NRecords[i]; j++)" << endl;
  oPopDriver << "                 {" << endl;
  oPopDriver << "                    scalarToDouble( dataForDisposal.data[i]->PRED[j], iiPredOut[j] );" << endl;
  oPopDriver << "                 }" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               else" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                 // Fill this with NaN's if bi contained NaN's." << endl;
  oPopDriver << "                 iiPredOut = zero / zero;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               iPredOut[ slice( k, NRecords[i], 1 ) ]  = iiPredOut;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            set.replaceIPred   ( iPredOut );"           << endl;
  oPopDriver << "            set.replaceIRes    ( iResOut );"            << endl;
  oPopDriver << "            set.replaceIWRes   ( iResWtdOut );"         << endl;
  oPopDriver << "            set.replaceIEtaRes ( iParResOut );"         << endl;
  oPopDriver << "            set.replaceIWEtaRes( iParResWtdOut );"      << endl;
  oPopDriver << endl;
  oPopDriver << "            try{" << endl;
  oPopDriver << "               popResiduals( modelForDisposal, "        << endl;
  oPopDriver << "                             objective, "          << endl;
  oPopDriver << "                             NObservs,"                 << endl;
  oPopDriver << "                             y,"                        << endl;
  oPopDriver << "                             alpOut,"                   << endl;
  oPopDriver << "                             bOut,"                     << endl;
  oPopDriver << "                            &pPredTruncatedOut, "       << endl;
  oPopDriver << "                            &pResTruncatedOut, "        << endl;
  oPopDriver << "                            &pResWtdTruncatedOut, "     << endl;
  oPopDriver << "                            &pParResOut, "              << endl;
  oPopDriver << "                            &pParResWtdOut );"          << endl;
  oPopDriver << "               dataForDisposal.expand( pPredTruncatedOut,   pPredOut );"   << endl;
  oPopDriver << "               dataForDisposal.expand( pResTruncatedOut,    pResOut );"    << endl;
  oPopDriver << "               dataForDisposal.expand( pResWtdTruncatedOut, pResWtdOut );" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "            catch( SpkException& e )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               char message[] = \"Failed during the calculation of population (non-conditional) residuals.\";" << endl;
  oPopDriver << "               SpkError ee( SpkError::SPK_STATISTICS_ERR, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "               e.push( ee );" << endl;
  oPopDriver << "               errors.cat( e );" << endl;
  oPopDriver << "               if ( !isPopOptAtMaxIter )" << endl;
  oPopDriver << "                  ret = OPT_OK_RESID_ERROR;" << endl;
  oPopDriver << "               else" << endl;
  oPopDriver << "                  ret = OPT_MAX_ITER_RESID_ERROR;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            catch( const std::exception& stde )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               char message[] = \"A standard exception occurred during the calculation of population (non-conditional) residuals.\";" << endl;
  oPopDriver << "               SpkError e( stde, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "               errors.push( e );" << endl;
  oPopDriver << "               if ( !isPopOptAtMaxIter )" << endl;
  oPopDriver << "                  ret = OPT_OK_RESID_ERROR;" << endl;
  oPopDriver << "               else" << endl;
  oPopDriver << "                  ret = OPT_MAX_ITER_RESID_ERROR;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            catch( ... )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               char message[] = \"An unknown exception occurred during the calculation of population (non-conditional) residuals.\";" << endl;
  oPopDriver << "               SpkError e( SpkError::SPK_UNKNOWN_ERR, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "               errors.push( e );" << endl;
  oPopDriver << "               if ( !isPopOptAtMaxIter )" << endl;
  oPopDriver << "                  ret = OPT_OK_RESID_ERROR;" << endl;
  oPopDriver << "               else" << endl;
  oPopDriver << "                  ret = OPT_MAX_ITER_RESID_ERROR;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            set.replacePPred   ( pPredOut );"           << endl;
  oPopDriver << "            set.replacePRes    ( pResOut );"            << endl;
  oPopDriver << "            set.replacePWRes   ( pResWtdOut );"         << endl;
  oPopDriver << "            set.replacePEtaRes ( pParResOut );"         << endl;
  oPopDriver << "            set.replacePWEtaRes( pParResWtdOut );"      << endl;
  oPopDriver << endl;
  oPopDriver << "            try{" << endl;
  oPopDriver << "               if( objective == FIRST_ORDER  || objective == NAIVE_FIRST_ORDER )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  bool calcFoModelMinimizer = true;"       << endl;
  oPopDriver << "                  popResiduals( modelForDisposal, "        << endl;
  oPopDriver << "                                objective, "               << endl;
  oPopDriver << "                                NObservs,"                 << endl;
  oPopDriver << "                                y,"                        << endl;
  oPopDriver << "                                alpOut,"                   << endl;
  oPopDriver << "                                bOut,"                     << endl;
  oPopDriver << "                               &cPredTruncatedOut, "       << endl;
  oPopDriver << "                               &cResTruncatedOut, "        << endl;
  oPopDriver << "                               &cResWtdTruncatedOut, "     << endl;
  oPopDriver << "                               &cParResOut, "              << endl;
  oPopDriver << "                               &cParResWtdOut,"            << endl;
  oPopDriver << "                                calcFoModelMinimizer );"   << endl;
  oPopDriver << "                  dataForDisposal.expand( cPredTruncatedOut,   cPredOut );"   << endl;
  oPopDriver << "                  dataForDisposal.expand( cResTruncatedOut,    cResOut );"    << endl;
  oPopDriver << "                  dataForDisposal.expand( cResWtdTruncatedOut, cResWtdOut );" << endl;
  oPopDriver << "                  set.replaceCPred   ( cPredOut );"        << endl;
  oPopDriver << "                  set.replaceCRes    ( cResOut );"         << endl;
  oPopDriver << "                  set.replaceCWRes   ( cResWtdOut );"      << endl;
  oPopDriver << "                  set.replaceCEtaRes ( cParResOut );"      << endl;
  oPopDriver << "                  set.replaceCWEtaRes( cParResWtdOut );"   << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               else" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  set.replaceCPred   ( iPredOut );"           << endl;
  oPopDriver << "                  set.replaceCRes    ( iResOut );"            << endl;
  oPopDriver << "                  set.replaceCWRes   ( iResWtdOut );"         << endl;
  oPopDriver << "                  set.replaceCEtaRes ( iParResOut );"         << endl;
  oPopDriver << "                  set.replaceCWEtaRes( iParResWtdOut );"      << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            catch( SpkException& e )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               char message[] = \"Failed during the calculation of conditional residuals.\";" << endl;
  oPopDriver << "               SpkError ee( SpkError::SPK_STATISTICS_ERR, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "               e.push( ee );" << endl;
  oPopDriver << "               errors.cat( e );" << endl;
  oPopDriver << "               isStatSuccess &= false;" << endl;
  oPopDriver << "               if ( !isPopOptAtMaxIter )" << endl;
  oPopDriver << "                  ret = OPT_OK_RESID_ERROR;" << endl;
  oPopDriver << "               else" << endl;
  oPopDriver << "                  ret = OPT_MAX_ITER_RESID_ERROR;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            catch( const std::exception& stde )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               char message[] = \"A standard exception occurred during the calculation of conditional residuals.\";" << endl;
  oPopDriver << "               SpkError e( stde, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "               errors.push( e );" << endl;
  oPopDriver << "               isStatSuccess &= false;" << endl;
  oPopDriver << "               if ( !isPopOptAtMaxIter )" << endl;
  oPopDriver << "                  ret = OPT_OK_RESID_ERROR;" << endl;
  oPopDriver << "               else" << endl;
  oPopDriver << "                  ret = OPT_MAX_ITER_RESID_ERROR;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            catch( ... )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               char message[] = \"An unknown exception occurred during the calculation of conditional residuals.\";" << endl;
  oPopDriver << "               SpkError e( SpkError::SPK_UNKNOWN_ERR, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "               errors.push( e );" << endl;
  oPopDriver << "               isStatSuccess &= false;" << endl;
  oPopDriver << "               if ( !isPopOptAtMaxIter )" << endl;
  oPopDriver << "                  ret = OPT_OK_RESID_ERROR;" << endl;
  oPopDriver << "               else" << endl;
  oPopDriver << "                  ret = OPT_MAX_ITER_RESID_ERROR;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << endl;
  oPopDriver << "            // Calculate the residuals with the individual parameters" << endl;
  oPopDriver << "            // all equal to zero, which is the population mean value." << endl;
  oPopDriver << "            // But, don't calculate the individuals' PRED values." << endl;
  oPopDriver << "            try{" << endl;
  oPopDriver << "               objForDisposal = FIRST_ORDER;" << endl;
  oPopDriver << "               valarray<double> bAllZero( 0.0, nB * nPop );" << endl;
  oPopDriver << "               valarray<double>* pVANull = 0;" << endl;
  oPopDriver << "               popResiduals( modelForDisposal, " << endl;
  oPopDriver << "                             objForDisposal, " << endl;
  oPopDriver << "                             NObservs," << endl;
  oPopDriver << "                             y," << endl;
  oPopDriver << "                             alpOut," << endl;
  oPopDriver << "                             bAllZero," << endl;
  oPopDriver << "                             pVANull, " << endl;
  oPopDriver << "                            &resTruncatedOut, " << endl;
  oPopDriver << "                            &resWtdTruncatedOut, " << endl;
  oPopDriver << "                            &parResOut, " << endl;
  oPopDriver << "                            &parResWtdOut );" << endl;
  oPopDriver << "               dataForDisposal.expand( resTruncatedOut,    resOut );" << endl;
  oPopDriver << "               dataForDisposal.expand( resWtdTruncatedOut, resWtdOut );" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "            catch( SpkException& e )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               char message[] = \"Failed during the calculation of standard residuals.\";" << endl;
  oPopDriver << "               SpkError ee( SpkError::SPK_STATISTICS_ERR, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "               e.push( ee );" << endl;
  oPopDriver << "               errors.cat( e );" << endl;
  oPopDriver << "               if ( !isPopOptAtMaxIter )" << endl;
  oPopDriver << "                  ret = OPT_OK_RESID_ERROR;" << endl;
  oPopDriver << "               else" << endl;
  oPopDriver << "                  ret = OPT_MAX_ITER_RESID_ERROR;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            catch( const std::exception& stde )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               char message[] = \"A standard exception occurred during the calculation of standard residuals.\";" << endl;
  oPopDriver << "               SpkError e( stde, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "               errors.push( e );" << endl;
  oPopDriver << "               if ( !isPopOptAtMaxIter )" << endl;
  oPopDriver << "                  ret = OPT_OK_RESID_ERROR;" << endl;
  oPopDriver << "               else" << endl;
  oPopDriver << "                  ret = OPT_MAX_ITER_RESID_ERROR;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            catch( ... )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               char message[] = \"An unknown exception occurred during the calculation of standard residuals.\";" << endl;
  oPopDriver << "               SpkError e( SpkError::SPK_UNKNOWN_ERR, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "               errors.push( e );" << endl;
  oPopDriver << "               if ( !isPopOptAtMaxIter )" << endl;
  oPopDriver << "                  ret = OPT_OK_RESID_ERROR;" << endl;
  oPopDriver << "               else" << endl;
  oPopDriver << "                  ret = OPT_MAX_ITER_RESID_ERROR;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            // Set the PRED values here so that they have values for" << endl;
  oPopDriver << "            // all of the data records.  Note that the OdePred" << endl;
  oPopDriver << "            // evaluator only saves values after the last individuals'" << endl;
  oPopDriver << "            // last data record has been accessed." << endl;
  oPopDriver << "            for( int i=0, k=0; i<nPop; k+=NRecords[i++] )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               ipredOut.resize( NRecords[i] );" << endl;
  oPopDriver << "               for( int j=0; j<NRecords[i]; j++)" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  scalarToDouble( dataForDisposal.data[i]->PRED[j], ipredOut[j] );" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               predOut[ slice( k, NRecords[i], 1 ) ]  = ipredOut;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            set.replacePred   ( predOut );" << endl;
  oPopDriver << "            set.replaceRes    ( resOut );" << endl;
  oPopDriver << "            set.replaceWRes   ( resWtdOut );" << endl;
  oPopDriver << "            set.replaceEtaRes ( parResOut );" << endl;
  oPopDriver << "            set.replaceWEtaRes( parResWtdOut );" << endl;
  oPopDriver << "         }" << endl;

  oPopDriver << "         // Calculate the residuals for the two-stage or nonparametric methods." << endl;
  oPopDriver << "         if( isOptRequested && isOptSuccess && ( isTwoStageMethod || isNonparamMethod ) )" << endl;
  oPopDriver << "         {" << endl;
  oPopDriver << "            assert( haveCompleteData );" << endl;
  oPopDriver << "            valarray<double> yiTwoStageOrNonparam;" << endl;
  oPopDriver << "            valarray<double> fiTwoStageOrNonparam;" << endl;
  oPopDriver << "            valarray<double> biTwoStageOrNonparam( nBTwoStageOrNonparam );" << endl;
  oPopDriver << endl;
  oPopDriver << "            // The population model's theta value contains the population" << endl;
  oPopDriver << "            // mean of the individuals' theta values." << endl;
  oPopDriver << "            valarray<double> thetaTwoStageOrNonparamPopMean( NonmemPars::nTheta );" << endl;
  oPopDriver << "            model.getTheta( thetaTwoStageOrNonparamPopMean );" << endl;
  oPopDriver << "            indModelForTwoStageOrNonparam.setTheta( thetaTwoStageOrNonparamPopMean );" << endl;
  oPopDriver << endl;
  oPopDriver << "            // The population model's sigma value contains the population" << endl;
  oPopDriver << "            // mean of the individuals' omega values." << endl;
  oPopDriver << "            int nTwoStageOrNonparamSigmaPar = model.getSigma().getNPar();" << endl;
  oPopDriver << "            valarray<double> omegaTwoStageOrNonparamPopMeanMinRep( nTwoStageOrNonparamSigmaPar );" << endl;
  oPopDriver << "            valarray<double> omegaTwoStageOrNonparamPopMean( NonmemPars::nEps * NonmemPars::nEps );" << endl;
  oPopDriver << "            model.getSigma( omegaTwoStageOrNonparamPopMeanMinRep );" << endl;
  oPopDriver << "            model.getSigma().expandCovMinRep( omegaTwoStageOrNonparamPopMeanMinRep, omegaTwoStageOrNonparamPopMean );" << endl;
  oPopDriver << "            indModelForTwoStageOrNonparam.setOmega( omegaTwoStageOrNonparamPopMean );" << endl;
  oPopDriver << endl;
  oPopDriver << "            valarray<double> bTwoStageOrNonparamPopMean( nBTwoStageOrNonparam );" << endl;
  oPopDriver << "            indModelForTwoStageOrNonparam.getIndPar( bTwoStageOrNonparamPopMean );" << endl;
  oPopDriver << endl;
  oPopDriver << "            valarray<double> twoStageOrNonparamPredOut;" << endl;
  oPopDriver << "            valarray<double> twoStageOrNonparamResOut; " << endl;
  oPopDriver << "            valarray<double> twoStageOrNonparamResWtdOut;" << endl;
  oPopDriver << "            valarray<double> twoStageOrNonparamResTruncatedOut; " << endl;
  oPopDriver << "            valarray<double> twoStageOrNonparamResWtdTruncatedOut;" << endl;
  oPopDriver << "            for( int i=0, j=0, k=0; i<nPop; j+=NObservs[i], k+=NRecords[i++] )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               yiTwoStageOrNonparam.resize        ( NObservs[i] );" << endl;
  oPopDriver << "               twoStageOrNonparamPredOut.resize  ( NRecords[i] );" << endl;
  oPopDriver << "               twoStageOrNonparamResOut.resize   ( NRecords[i] );" << endl;
  oPopDriver << "               twoStageOrNonparamResWtdOut.resize( NRecords[i] );" << endl;
  oPopDriver << "               twoStageOrNonparamResTruncatedOut.resize   ( NObservs[i] );" << endl;
  oPopDriver << "               twoStageOrNonparamResWtdTruncatedOut.resize( NObservs[i] );" << endl;
  oPopDriver << "               yiTwoStageOrNonparam = y[ slice( j, NObservs[i], 1 ) ]; " << endl;
  oPopDriver << "               indModelForTwoStageOrNonparam.selectIndividual( i );" << endl;
  oPopDriver << "               try{" << endl;
  oPopDriver << "                  // Don't calculate the individual's parameter residuals" << endl;
  oPopDriver << "                  // or the individual's PRED values." << endl;
  oPopDriver << "                  valarray<double>* pVANull = 0;" << endl;
  oPopDriver << "                  indResiduals( indModelForTwoStageOrNonparam," << endl;
  oPopDriver << "                                yiTwoStageOrNonparam, " << endl;
  oPopDriver << "                                bTwoStageOrNonparamPopMean," << endl;
  oPopDriver << "                                pVANull," << endl;
  oPopDriver << "                               &twoStageOrNonparamResTruncatedOut," << endl;
  oPopDriver << "                               &twoStageOrNonparamResWtdTruncatedOut, " << endl;
  oPopDriver << "                                pVANull, " << endl;
  oPopDriver << "                                pVANull );" << endl;
  oPopDriver << endl;
  oPopDriver << "                  dataForDisposal.expand( i, twoStageOrNonparamResTruncatedOut,    twoStageOrNonparamResOut );" << endl;
  oPopDriver << "                  dataForDisposal.expand( i, twoStageOrNonparamResWtdTruncatedOut, twoStageOrNonparamResWtdOut );" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               catch( SpkException& e )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  char message[SpkError::maxMessageLen()];" << endl;
  oPopDriver << "                  snprintf( message, " << endl;
  oPopDriver << "                            SpkError::maxMessageLen()," << endl;
  oPopDriver << "                            \"Failed during the calculation of %i-th individual's residuals!\", i );" << endl;
  oPopDriver << "                  SpkError ee( SpkError::SPK_STATISTICS_ERR, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "                  e.push( ee );" << endl;
  oPopDriver << "                  errors.cat( e );" << endl;
  oPopDriver << "                  isStatSuccess &= false;" << endl;
  oPopDriver << "                  if ( !isPopOptAtMaxIter )" << endl;
  oPopDriver << "                     ret = OPT_OK_RESID_ERROR;" << endl;
  oPopDriver << "                  else" << endl;
  oPopDriver << "                     ret = OPT_MAX_ITER_RESID_ERROR;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               catch( const std::exception& stde )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  char message[SpkError::maxMessageLen()];" << endl;
  oPopDriver << "                  snprintf( message, " << endl;
  oPopDriver << "                            SpkError::maxMessageLen()," << endl;
  oPopDriver << "                           \"A standard exception occurred during the calculation of %i-th individual's residuals.\", i );" << endl;
  oPopDriver << "                  SpkError e( stde, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "                  errors.push( e );" << endl;
  oPopDriver << "                  isStatSuccess &= false;" << endl;
  oPopDriver << "                  if ( !isPopOptAtMaxIter )" << endl;
  oPopDriver << "                     ret = OPT_OK_RESID_ERROR;" << endl;
  oPopDriver << "                  else" << endl;
  oPopDriver << "                     ret = OPT_MAX_ITER_RESID_ERROR;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               catch( ... )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  char message[SpkError::maxMessageLen()];" << endl;
  oPopDriver << "                  snprintf( message, " << endl;
  oPopDriver << "                            SpkError::maxMessageLen()," << endl;
  oPopDriver << "                           \"An unknown exception occurred during the calculation of %i-th individual's residuals.\", i );" << endl;
  oPopDriver << "                  SpkError e( SpkError::SPK_UNKNOWN_ERR, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "                  errors.push( e );" << endl;
  oPopDriver << "                  isStatSuccess &= false;" << endl;
  oPopDriver << "                  if ( !isPopOptAtMaxIter )" << endl;
  oPopDriver << "                     ret = OPT_OK_RESID_ERROR;" << endl;
  oPopDriver << "                  else" << endl;
  oPopDriver << "                     ret = OPT_MAX_ITER_RESID_ERROR;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               resOut      [ slice( k, NRecords[i], 1 ) ]  = twoStageOrNonparamResOut;" << endl;
  oPopDriver << "               resWtdOut   [ slice( k, NRecords[i], 1 ) ]  = twoStageOrNonparamResWtdOut;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            // Set the PRED values here so that they have values for" << endl;
  oPopDriver << "            // all of the data records.  Note that the OdePred" << endl;
  oPopDriver << "            // evaluator only saves values after the last individuals'" << endl;
  oPopDriver << "            // last data record has been accessed." << endl;
  oPopDriver << "            for( int i=0, k=0; i<nPop; k+=NRecords[i++] )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               twoStageOrNonparamPredOut.resize( NRecords[i] );" << endl;
  oPopDriver << "               for( int j=0; j<NRecords[i]; j++)" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  scalarToDouble( dataForDisposal.data[i]->PRED[j], twoStageOrNonparamPredOut[j] );" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               predOut[ slice( k, NRecords[i], 1 ) ]  = twoStageOrNonparamPredOut;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            // The two-stage methods do not provide values for the eta" << endl;
  oPopDriver << "            // values that appear in the population model, so just set" << endl;
  oPopDriver << "            // these residuals all equal to zero." << endl;
  oPopDriver << "            parResOut    = 0.0;" << endl;
  oPopDriver << "            parResWtdOut = 0.0;" << endl;
  oPopDriver << endl;
  oPopDriver << "            valarray<double> iTwoStageOrNonparamPredOut;" << endl;
  oPopDriver << "            valarray<double> iTwoStageOrNonparamResOut; " << endl;
  oPopDriver << "            valarray<double> iTwoStageOrNonparamResWtdOut;" << endl;
  oPopDriver << "            valarray<double> iTwoStageOrNonparamResTruncatedOut; " << endl;
  oPopDriver << "            valarray<double> iTwoStageOrNonparamResWtdTruncatedOut;" << endl;
  oPopDriver << "            for( int i=0, j=0, k=0; i<nPop; j+=NObservs[i], k+=NRecords[i++] )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               yiTwoStageOrNonparam.resize        ( NObservs[i] );" << endl;
  oPopDriver << "               fiTwoStageOrNonparam.resize        ( NObservs[i] );" << endl;
  oPopDriver << "               iTwoStageOrNonparamPredOut.resize  ( NRecords[i] );" << endl;
  oPopDriver << "               iTwoStageOrNonparamResOut.resize   ( NRecords[i] );" << endl;
  oPopDriver << "               iTwoStageOrNonparamResWtdOut.resize( NRecords[i] );" << endl;
  oPopDriver << "               iTwoStageOrNonparamResTruncatedOut.resize   ( NObservs[i] );" << endl;
  oPopDriver << "               iTwoStageOrNonparamResWtdTruncatedOut.resize( NObservs[i] );" << endl;
  oPopDriver << "               yiTwoStageOrNonparam = y[ slice( j, NObservs[i], 1 ) ]; " << endl;
  oPopDriver << "               biTwoStageOrNonparam = bTwoStageOrNonparamOut[ slice( i*nBTwoStageOrNonparam, nBTwoStageOrNonparam, 1 ) ];" << endl;
  oPopDriver << "               indModelForTwoStageOrNonparam.selectIndividual( i );" << endl;
  oPopDriver << "               indModelForTwoStageOrNonparam.setIndPar( biTwoStageOrNonparam );" << endl;
  oPopDriver << "               try{" << endl;
  oPopDriver << "                  // Make sure each individual's data mean values has" << endl;
  oPopDriver << "                  // been calculated at the optimal parameter values." << endl;
  oPopDriver << "                  indModelForTwoStageOrNonparam.dataMean( fiTwoStageOrNonparam );" << endl;
  oPopDriver << endl;
  oPopDriver << "                  // Don't calculate the individual's parameter residuals" << endl;
  oPopDriver << "                  // or the individual's PRED values." << endl;
  oPopDriver << "                  valarray<double>* pVANull = 0;" << endl;
  oPopDriver << "                  indResiduals( indModelForTwoStageOrNonparam," << endl;
  oPopDriver << "                                yiTwoStageOrNonparam, " << endl;
  oPopDriver << "                                biTwoStageOrNonparam," << endl;
  oPopDriver << "                                pVANull," << endl;
  oPopDriver << "                               &iTwoStageOrNonparamResTruncatedOut," << endl;
  oPopDriver << "                               &iTwoStageOrNonparamResWtdTruncatedOut, " << endl;
  oPopDriver << "                                pVANull, " << endl;
  oPopDriver << "                                pVANull );" << endl;
  oPopDriver << endl;
  oPopDriver << "                  dataForDisposal.expand( i, iTwoStageOrNonparamResTruncatedOut,    iTwoStageOrNonparamResOut );" << endl;
  oPopDriver << "                  dataForDisposal.expand( i, iTwoStageOrNonparamResWtdTruncatedOut, iTwoStageOrNonparamResWtdOut );" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               catch( SpkException& e )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  char message[SpkError::maxMessageLen()];" << endl;
  oPopDriver << "                  snprintf( message, " << endl;
  oPopDriver << "                            SpkError::maxMessageLen()," << endl;
  oPopDriver << "                            \"Failed during the calculation of %i-th individual's residuals!\", i );" << endl;
  oPopDriver << "                  SpkError ee( SpkError::SPK_STATISTICS_ERR, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "                  e.push( ee );" << endl;
  oPopDriver << "                  errors.cat( e );" << endl;
  oPopDriver << "                  isStatSuccess &= false;" << endl;
  oPopDriver << "                  if ( !isPopOptAtMaxIter )" << endl;
  oPopDriver << "                     ret = OPT_OK_RESID_ERROR;" << endl;
  oPopDriver << "                  else" << endl;
  oPopDriver << "                     ret = OPT_MAX_ITER_RESID_ERROR;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               catch( const std::exception& stde )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  char message[SpkError::maxMessageLen()];" << endl;
  oPopDriver << "                  snprintf( message, " << endl;
  oPopDriver << "                            SpkError::maxMessageLen()," << endl;
  oPopDriver << "                           \"A standard exception occurred during the calculation of %i-th individual's residuals.\", i );" << endl;
  oPopDriver << "                  SpkError e( stde, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "                  errors.push( e );" << endl;
  oPopDriver << "                  isStatSuccess &= false;" << endl;
  oPopDriver << "                  if ( !isPopOptAtMaxIter )" << endl;
  oPopDriver << "                     ret = OPT_OK_RESID_ERROR;" << endl;
  oPopDriver << "                  else" << endl;
  oPopDriver << "                     ret = OPT_MAX_ITER_RESID_ERROR;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               catch( ... )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  char message[SpkError::maxMessageLen()];" << endl;
  oPopDriver << "                  snprintf( message, " << endl;
  oPopDriver << "                            SpkError::maxMessageLen()," << endl;
  oPopDriver << "                           \"An unknown exception occurred during the calculation of %i-th individual's residuals.\", i );" << endl;
  oPopDriver << "                  SpkError e( SpkError::SPK_UNKNOWN_ERR, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "                  errors.push( e );" << endl;
  oPopDriver << "                  isStatSuccess &= false;" << endl;
  oPopDriver << "                  if ( !isPopOptAtMaxIter )" << endl;
  oPopDriver << "                     ret = OPT_OK_RESID_ERROR;" << endl;
  oPopDriver << "                  else" << endl;
  oPopDriver << "                     ret = OPT_MAX_ITER_RESID_ERROR;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               iResOut      [ slice( k, NRecords[i], 1 ) ]  = iTwoStageOrNonparamResOut;" << endl;
  oPopDriver << "               iResWtdOut   [ slice( k, NRecords[i], 1 ) ]  = iTwoStageOrNonparamResWtdOut;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            // Set the IPRED values here so that they have values for" << endl;
  oPopDriver << "            // all of the data records.  Note that the OdePred" << endl;
  oPopDriver << "            // evaluator only saves values after the last individuals'" << endl;
  oPopDriver << "            // last data record has been accessed." << endl;
  oPopDriver << "            for( int i=0, k=0; i<nPop; k+=NRecords[i++] )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               iTwoStageOrNonparamPredOut.resize( NRecords[i] );" << endl;
  oPopDriver << "               for( int j=0; j<NRecords[i]; j++)" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  scalarToDouble( dataForDisposal.data[i]->PRED[j], iTwoStageOrNonparamPredOut[j] );" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               iPredOut[ slice( k, NRecords[i], 1 ) ]  = iTwoStageOrNonparamPredOut;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            // The two-stage methods do not provide values for the eta" << endl;
  oPopDriver << "            // values that appear in the population model, so just set" << endl;
  oPopDriver << "            // these residuals all equal to zero." << endl;
  oPopDriver << "            iParResOut    = 0.0;" << endl;
  oPopDriver << "            iParResWtdOut = 0.0;" << endl;
  oPopDriver << "            dataForDisposal.replaceIPred   ( iPredOut );" << endl;
  oPopDriver << "            dataForDisposal.replaceIRes    ( iResOut );" << endl;
  oPopDriver << "            dataForDisposal.replaceIWRes   ( iResWtdOut );" << endl;
  oPopDriver << "            dataForDisposal.replaceIEtaRes ( iParResOut );" << endl;
  oPopDriver << "            dataForDisposal.replaceIWEtaRes( iParResWtdOut );" << endl;
  oPopDriver << endl;
  oPopDriver << "            // Set these here since they were overwritten with the individuals' values." << endl;
  oPopDriver << "            dataForDisposal.replacePred   ( predOut );" << endl;
  oPopDriver << "            dataForDisposal.replaceRes    ( resOut );" << endl;
  oPopDriver << "            dataForDisposal.replaceWRes   ( resWtdOut );" << endl;
  oPopDriver << "            dataForDisposal.replaceEtaRes ( parResOut );" << endl;
  oPopDriver << "            dataForDisposal.replaceWEtaRes( parResWtdOut );" << endl;
  oPopDriver << "         }" << endl;
  oPopDriver << endl;
 
  // Statistics can be only computed when the parameter estimation has been done.
  oPopDriver << "STATISTICS:" << endl;
  oPopDriver << "         /*******************************************************************/" << endl;
  oPopDriver << "         /*                                                                 */" << endl;
  oPopDriver << "         /*   Statistics                                                    */" << endl;
  oPopDriver << "         /*                                                                 */" << endl;
  oPopDriver << "         /*******************************************************************/" << endl;
  oPopDriver << "         if( isStatRequested && isOptRequested && isOptSuccess && !isTwoStageMethod )" << endl;
  oPopDriver << "         {" << endl;
  oPopDriver << "            gettimeofday( &statBegin, NULL );" << endl;
  oPopDriver << "            try" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               // Set this so that no population level optimization" << endl;
  oPopDriver << "               // is performed." << endl;
  oPopDriver << "               popOpt.setNMaxIter( 0 );" << endl;
  oPopDriver << endl;
  oPopDriver << "               // Evaluate the Hessian of the parametric" << endl;
  oPopDriver << "               // population objective function at alpOut." << endl;
  oPopDriver << "               fitPopulation( modelForDisposal," << endl;
  oPopDriver << "                              modelForDisposalAD, " << endl;
  oPopDriver << "                              objective, " << endl;
  oPopDriver << "                              NObservs," << endl;
  oPopDriver << "                              y," << endl;
  oPopDriver << "                              popOpt," << endl;
  oPopDriver << "                              alpLow," << endl;
  oPopDriver << "                              alpUp," << endl;
  oPopDriver << "                              alpOut," << endl;
  oPopDriver << "                              alpStep," << endl;
  oPopDriver << "                              NULL," << endl;
  oPopDriver << "                              indOpt," << endl;
  oPopDriver << "                              bLow," << endl;
  oPopDriver << "                              bUp," << endl;
  oPopDriver << "                              bOut," << endl;
  oPopDriver << "                              bStep," << endl;
  oPopDriver << "                              NULL," << endl;
  oPopDriver << "                              NULL," << endl;
  oPopDriver << "                              NULL," << endl;
  oPopDriver << "                              &alpObj_alp_alpOut," << endl;
  oPopDriver << "                              0 );" << endl;
  oPopDriver << endl;
  oPopDriver << "               for( int i=0; i<nAlp; i++ )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  alpMask[i] = !( alpLow[i]==alpUp[i] || alpOut[i]==alpLow[i] || alpOut[i]==alpUp[i] );" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               model.getStandardParMask( alpMask, stdParMask );" << endl;
  oPopDriver << "               model.getStandardPar( stdPar );" << endl;
  oPopDriver << "               model.getStandardPar_popPar( stdPar_alp );" << endl;
  oPopDriver << "               popStatistics(    modelForDisposal, "       << endl;
  oPopDriver << "                                 modelAD, "                << endl;
  oPopDriver << "                                 objective,"               << endl;
  oPopDriver << "                                 NObservs,"                << endl;
  oPopDriver << "                                 y,"                       << endl;
  oPopDriver << "                                 alpOut, "                 << endl;
  oPopDriver << "                                 alpMask,"                 << endl;
  oPopDriver << "                                 alpObj_alp_alpOut, "      << endl;
  oPopDriver << "                                 bOut,"                    << endl;
  oPopDriver << "                                 bLow,"                    << endl;
  oPopDriver << "                                 bUp,"                     << endl;
  oPopDriver << "                                 bStep,"                   << endl;
  oPopDriver << "                                 covForm,"                 << endl;
  oPopDriver << "                                &alpCov, "                 << endl;
  oPopDriver << "                                 NULL, "                   << endl;
  oPopDriver << "                                 NULL, "                   << endl;
  oPopDriver << "                                 NULL, "                   << endl;
  oPopDriver << "                                 NULL );"                  << endl;
  oPopDriver << endl;
  oPopDriver << "               derParStatistics( alpMask,"                 << endl;
  oPopDriver << "                                 alpCov,"                  << endl;
  oPopDriver << "                                 stdParMask,"              << endl;
  oPopDriver << "                                 stdPar,"                  << endl;
  oPopDriver << "                                 stdPar_alp,"              << endl;
  oPopDriver << "                                 nDegOfFreedom,"           << endl;
  oPopDriver << "                                (isCovOut || isInvCovOut? &stdParCovOut        : NULL)," << endl;
  oPopDriver << "                                (isCovOut || isInvCovOut? &stdParInvCovOut     : NULL)," << endl;
  oPopDriver << "                                (isStdErrOut?             &stdParSEOut         : NULL)," << endl;
  oPopDriver << "                                (isCorrelationOut?        &stdParCorrelationOut: NULL)," << endl;
  oPopDriver << "                                (isCoefficientOut?        &stdParCoefficientOut: NULL)," << endl;
  oPopDriver << "                                (isConfidenceOut?         &stdParConfidenceOut : NULL) " << endl;
  oPopDriver << "                               );" << endl;
  oPopDriver << "               isStatSuccess &= true;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            catch( SpkException& e )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               char mess[ SpkError::maxMessageLen() ];" << endl;
  oPopDriver << "               snprintf( mess, " << endl;
  oPopDriver << "                         SpkError::maxMessageLen()," << endl;
  oPopDriver << "                        \"Statistics calculation failed.\" );" << endl;
  oPopDriver << "               e.push( SpkError::SPK_STATISTICS_ERR, mess, __LINE__, __FILE__ );" << endl;
  oPopDriver << "               errors.cat( e );" << endl;
  oPopDriver << "               isStatSuccess &= false;" << endl;
  oPopDriver << "               if ( !isPopOptAtMaxIter )" << endl;
  oPopDriver << "                  ret = OPT_OK_STAT_ERROR;" << endl;
  oPopDriver << "               else" << endl;
  oPopDriver << "                  ret = OPT_MAX_ITER_STAT_ERROR;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            catch( const std::exception& stde )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               char message[] = \"A standard exception occurred in the statistics calculation.\";" << endl;
  oPopDriver << "               SpkError e( stde, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "               errors.push( e );" << endl;
  oPopDriver << "               isStatSuccess &= false;" << endl;
  oPopDriver << "               if ( !isPopOptAtMaxIter )" << endl;
  oPopDriver << "                  ret = OPT_OK_STAT_ERROR;" << endl;
  oPopDriver << "               else" << endl;
  oPopDriver << "                  ret = OPT_MAX_ITER_STAT_ERROR;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            catch( ... )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               char message[] = \"An unknown exception occurred in the statistics calculation.\";" << endl;
  oPopDriver << "               SpkError e( SpkError::SPK_UNKNOWN_ERR, message, __LINE__, __FILE__ );" << endl;
  oPopDriver << "               errors.push( e );" << endl;
  oPopDriver << "               isStatSuccess &= false;" << endl;
  oPopDriver << "               if ( !isPopOptAtMaxIter )" << endl;
  oPopDriver << "                  ret = OPT_OK_STAT_ERROR;" << endl;
  oPopDriver << "               else" << endl;
  oPopDriver << "                  ret = OPT_MAX_ITER_STAT_ERROR;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            gettimeofday( &statEnd, NULL );" << endl;
  oPopDriver << "            statTimeSec = difftime( statEnd.tv_sec, statBegin.tv_sec );" << endl;
  oPopDriver << "         }" << endl;
  oPopDriver << endl;

  oPopDriver << "REPORT_GEN:" << endl;
  oPopDriver << "         /*******************************************************************/" << endl;
  oPopDriver << "         /*                                                                 */" << endl;
  oPopDriver << "         /*   ReportML Document                                             */" << endl;
  oPopDriver << "         /*                                                                 */" << endl;
  oPopDriver << "         /*******************************************************************/" << endl;
  oPopDriver << "         oResults.open( \"" << fResult_xml << "\", ios_base::app );" << endl;
  oPopDriver << "         if( !oResults.good() )" << endl;
  oPopDriver << "         {" << endl;
  oPopDriver << "            fprintf( stderr, \"Failed to open a file, %s, for writing output.\", \"";
  oPopDriver << fResult_xml << "\" );" << endl;
  oPopDriver << "            ret = FILE_ACCESS_ERROR;" << endl;
  oPopDriver << "            oResults << \"</spkreport>\" << endl;" << endl;
  oPopDriver << "            oResults.close();" << endl;
  oPopDriver << "            goto END;" << endl;
  oPopDriver << "         }" << endl;

  oPopDriver << "         {" << endl;
  oPopDriver << "            oResults << \"<?xml version=\\\"1.0\\\"?>\" << endl;" << endl;
  oPopDriver << "            oResults << \"<spkreport>\" << endl;" << endl;
  oPopDriver << "         }" << endl;
  oPopDriver << endl;

  oPopDriver << "         oResults << \"<error_list length=\\\"\" << errors.size() << \"\\\">\" << endl;" << endl;
  oPopDriver << "         if( !(haveCompleteData && isOptSuccess && isStatSuccess) )" << endl;
  oPopDriver << "         {" << endl;
  oPopDriver << "            // Print out ordinary-length error messages" << endl;
  oPopDriver << "            oResults << errors << endl;" << endl;
  oPopDriver << endl;
  oPopDriver << "            // Print out a long error message if exists." << endl;
  oPopDriver << "            char ch;" << endl;
  oPopDriver << "            ifstream iLongError( \"" << fSpkRuntimeLongError_tmp << "\" );" << endl;
  oPopDriver << "            while( iLongError.get(ch) )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               oResults << ch;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            iLongError.close();" << endl;
  oPopDriver << "         }" << endl;
  oPopDriver << "         oResults << \"</error_list>\" << endl;" << endl;
  oPopDriver << "         remove( \"" << fSpkRuntimeLongError_tmp << "\" );" << endl;
  oPopDriver << endl;

  // Print out <warning_list> even when it is empty.
  oPopDriver << "         WarningsManager::getAllWarnings( warningsOut );" << endl;
  oPopDriver << "         oResults << warningsOut;" << endl;
  oPopDriver << endl;

  oPopDriver << "         if( isSimRequested )" << endl;
  oPopDriver << "         {" << endl;
  oPopDriver << "            oResults << \"<simulation \";" << endl;
  oPopDriver << "            if( iSub == 0 )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               oResults << \"seed=\\\"\" << seed << \"\\\" \";" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            oResults << \"subproblem=\\\"\" << iSub+1 << \"\\\"/>\" << endl;" << endl;
  oPopDriver << "         }" << endl;
  oPopDriver << endl;

  oPopDriver << "         int nParForStats = NonmemPars::nTheta;" << endl;
  oPopDriver << "         int notSameCount;" << endl;
  oPopDriver << "         if( isOptRequested )" << endl;
  oPopDriver << "         {" << endl;
  oPopDriver << "            oResults << \"<pop_analysis_result>\" << endl;" << endl;
  oPopDriver << endl;

  oPopDriver << "            oResults << \"<pop_opt_result elapsedtime=\\\"\" << optTimeSec << \"\\\">\" << endl;" << endl;
  oPopDriver << "            oResults << \"<pop_obj_out>\" << endl;" << endl;
  oPopDriver << "            oResults << \"<value>\" << alpObjOut << \"</value>\" << endl;" << endl;
  oPopDriver << "            oResults << \"</pop_obj_out>\" << endl;" << endl;
  oPopDriver << endl;
  
  oPopDriver << "            ///////////////////////////////////////////////////////////////////" << endl;
  oPopDriver << "            //   NONMEM Specific" << endl;
  // theta in
  oPopDriver << "            oResults << \"<theta_in length=\\\"\" << NonmemPars::nTheta << \"\\\">\" << endl;" << endl;
  oPopDriver << "            for( int i=0; i<NonmemPars::nTheta; i++ )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               oResults << \"<value>\" << thetaIn[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            oResults << \"</theta_in>\" << endl;" << endl;
  // theta out
  oPopDriver << "            oResults << \"<theta_out length=\\\"\" << NonmemPars::nTheta << \"\\\">\" << endl;" << endl;
  oPopDriver << "            for( int i=0; i<NonmemPars::nTheta; i++ )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               oResults << \"<value>\" << thetaOut[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            oResults << \"</theta_out>\" << endl;" << endl;

  // sigma in
  oPopDriver << "            for(int ii=0, idx=0; ii<NonmemPars::nSigmaBlk; ii++)" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               oResults << \"<sigma_in dimension=\" << \"\\\"\" << NonmemPars::sigmaBlockDims[ii] << \"\\\"\";" << endl;
  oPopDriver << "               oResults << \" struct=\" << \"\\\"\";" << endl;
  oPopDriver << "               if( NonmemPars::sigmaBlockStruct[ii]==DIAGONAL )" << endl;
  oPopDriver << "                  oResults << \"diagonal\";" << endl;
  oPopDriver << "               else" << endl;
  oPopDriver << "                  oResults << \"block\";" << endl;
  oPopDriver << "               oResults << \"\\\"\" << \">\" << endl;" << endl;
  /*
  oPopDriver << "            for( int i=0; i<NonmemPars::sigmaOrder; i++ )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               oResults << \"<value>\" << sigmaIn[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "            }" << endl;
  */
  oPopDriver << "               if( NonmemPars::sigmaBlockStruct[ii]==DIAGONAL )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  for( int i=0; i<NonmemPars::sigmaBlockDims[ii]; i++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     oResults << \"<value>\" << sigmaIn[idx] << \"</value>\" << endl;" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               else // full" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  int n = NonmemPars::sigmaBlockDims[ii];" << endl;
  oPopDriver << "                  int m = (n*(n+1))/2;" << endl;
  oPopDriver << "                  valarray<double> full( n * n );" << endl;
  oPopDriver << "                  valarray<double> row_minimal( m );" << endl;
  oPopDriver << endl;
  oPopDriver << "                  // First make a full matrix out of the minimal representation" << endl;
  oPopDriver << "                  for( int j=0; j<n; j++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     for( int i=0; i<n-j; i++, idx++ ) // lower only" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        full[ (j*n)+(j+i) ] = sigmaIn[idx];" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << endl;
  oPopDriver << "                  // Copy the lower triangle to the upper and complete fullification" << endl;
  oPopDriver << "                  symmetrize( full, n, full );" << endl;
  oPopDriver << endl;
  oPopDriver << "                  // Read the lower triangle in the row-major order" << endl;
  oPopDriver << "                  for( int i=0, k=0; i<n; i++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     for( int j=0; j<i+1; j++, k++ )" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        row_minimal[k] = full[(i*n)+j];" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << endl;
  oPopDriver << "                  for( int i=0; i<m; i++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     oResults << \"<value>\" << row_minimal[ i ];" << endl;
  oPopDriver << "                     oResults << \"</value>\" << endl;" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               oResults << \"</sigma_in>\" << endl;" << endl;
  oPopDriver << "            }" << endl;

  // sigma out
  oPopDriver << "            notSameCount = 0;" << endl;
  oPopDriver << "            for(int ii=0, idx=0; ii<NonmemPars::nSigmaBlk; ii++)" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               if ( NonmemPars::sigmaBlockSameAsPrev[ii] )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  notSameCount--;" << endl;
  oPopDriver << "                  if( NonmemPars::sigmaBlockStruct[notSameCount]==DIAGONAL )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     idx -= NonmemPars::sigmaBlockDims[notSameCount];" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "                  else // full" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     int n = NonmemPars::sigmaBlockDims[notSameCount];" << endl;
  oPopDriver << "                     int m = (n*(n+1))/2;" << endl;
  oPopDriver << "                     idx -= m;" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "                  assert( ii != 0 );" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << endl;
  oPopDriver << "               oResults << \"<sigma_out dimension=\" << \"\\\"\" << NonmemPars::sigmaBlockDims[notSameCount] << \"\\\"\";" << endl;
  oPopDriver << "               oResults << \" struct=\" << \"\\\"\";" << endl;
  oPopDriver << "               if( NonmemPars::sigmaBlockStruct[notSameCount]==DIAGONAL )" << endl;
  oPopDriver << "                  oResults << \"diagonal\";" << endl;
  oPopDriver << "               else" << endl;
  oPopDriver << "                  oResults << \"block\";" << endl;
  oPopDriver << "               oResults << \"\\\"\" << \">\" << endl;" << endl;
  /*
  oPopDriver << "            for( int i=0; i<NonmemPars::sigmaOrder; i++ )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               oResults << \"<value>\" << sigmaOut[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            oResults << \"</sigma_out>\" << endl;" << endl;
  */
  oPopDriver << "               if( NonmemPars::sigmaBlockStruct[notSameCount]==DIAGONAL )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  for( int i=0; i<NonmemPars::sigmaBlockDims[notSameCount]; i++, idx++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     oResults << \"<value>\" << sigmaOut[idx] << \"</value>\" << endl;" << endl;
  oPopDriver << "                     nParForStats++;" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               else // full" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  int n = NonmemPars::sigmaBlockDims[notSameCount];" << endl;
  oPopDriver << "                  int m = (n*(n+1))/2;" << endl;
  oPopDriver << "                  valarray<double> full( n * n );" << endl;
  oPopDriver << "                  valarray<double> row_minimal( m );" << endl;
  oPopDriver << endl;
  oPopDriver << "                  // First make a full matrix out of the minimal representation" << endl;
  oPopDriver << "                  for( int j=0; j<n; j++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     for( int i=0; i<n-j; i++, idx++ ) // lower only" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        full[ (j*n)+(j+i) ] = sigmaOut[idx];" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << endl;
  oPopDriver << "                  // Copy the lower triangle to the upper and complete fullification" << endl;
  oPopDriver << "                  symmetrize( full, n, full );" << endl;
  oPopDriver << endl;
  oPopDriver << "                  // Read the lower triangle in the row-major order" << endl;
  oPopDriver << "                  for( int i=0, k=0; i<n; i++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     for( int j=0; j<i+1; j++, k++ )" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        row_minimal[k] = full[(i*n)+j];" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << endl;
  oPopDriver << "                  for( int i=0; i<m; i++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     oResults << \"<value>\" << row_minimal[ i ];" << endl;
  oPopDriver << "                     oResults << \"</value>\" << endl;" << endl;
  oPopDriver << "                     nParForStats++;" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               oResults << \"</sigma_out>\" << endl;" << endl;
  oPopDriver << endl;
  oPopDriver << "               notSameCount++;" << endl;
  oPopDriver << "            }" << endl;

  // omega in
  oPopDriver << "            for(int ii=0, idx=0; ii<NonmemPars::nOmegaBlk; ii++)" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               oResults << \"<omega_in dimension=\" << \"\\\"\" << NonmemPars::omegaBlockDims[ii] << \"\\\"\";" << endl;
  oPopDriver << "               oResults << \" struct=\" << \"\\\"\";" << endl;
  oPopDriver << "               if( NonmemPars::omegaBlockStruct[ii]==DIAGONAL )" << endl;
  oPopDriver << "                  oResults << \"diagonal\";" << endl;
  oPopDriver << "               else" << endl;
  oPopDriver << "                  oResults << \"block\";" << endl;
  oPopDriver << "               oResults << \"\\\"\" << \">\" << endl;" << endl;

  /*
  oPopDriver << "            for( int i=0; i<NonmemPars::omegaOrder; i++ )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               oResults << \"<value>\" << omegaIn[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "            }" << endl;
  */

  oPopDriver << "               if( NonmemPars::omegaBlockStruct[ii]==DIAGONAL )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  for( int i=0; i<NonmemPars::omegaBlockDims[ii]; i++, idx++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     oResults << \"<value>\" << omegaIn[idx] << \"</value>\" << endl;" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               else // full" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  int n = NonmemPars::omegaBlockDims[ii];" << endl;
  oPopDriver << "                  int m = (n*(n+1))/2;" << endl;
  oPopDriver << "                  valarray<double> full( n * n );" << endl;
  oPopDriver << "                  valarray<double> row_minimal( m );" << endl;
  oPopDriver << endl;
  oPopDriver << "                  // First make a full matrix out of the minimal representation" << endl;
  oPopDriver << "                  for( int j=0; j<n; j++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     for( int i=0; i<n-j; i++, idx++ ) // lower only" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        full[ (j*n)+(j+i) ] = omegaIn[idx];" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << endl;
  oPopDriver << "                  // Copy the lower triangle to the upper and complete fullification" << endl;
  oPopDriver << "                  symmetrize( full, n, full );" << endl;
  oPopDriver << endl;
  oPopDriver << "                  for( int i=0, k=0; i<n; i++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     for( int j=0; j<i+1; j++, k++ )" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        row_minimal[k] = full[i*n+j];" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << endl;
  oPopDriver << "                  for( int i=0; i<m; i++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     oResults << \"<value>\" << row_minimal[ i ];" << endl;
  oPopDriver << "                     oResults << \"</value>\" << endl;" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "               }" << endl;

  oPopDriver << "               oResults << \"</omega_in>\" << endl;" << endl;
  oPopDriver << "            }" << endl;

  // omega out
  oPopDriver << "            notSameCount = 0;" << endl;
  oPopDriver << "            for(int ii=0, idx=0; ii<NonmemPars::nOmegaBlk; ii++)" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               if ( NonmemPars::omegaBlockSameAsPrev[ii] )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  notSameCount--;" << endl;
  oPopDriver << "                  if( NonmemPars::omegaBlockStruct[notSameCount]==DIAGONAL )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     idx -= NonmemPars::omegaBlockDims[notSameCount];" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "                  else // full" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     int n = NonmemPars::omegaBlockDims[notSameCount];" << endl;
  oPopDriver << "                     int m = (n*(n+1))/2;" << endl;
  oPopDriver << "                     idx -= m;" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "                  assert( ii != 0 );" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               oResults << \"<omega_out dimension=\" << \"\\\"\" << NonmemPars::omegaBlockDims[notSameCount] << \"\\\"\";" << endl;
  oPopDriver << "               oResults << \" struct=\" << \"\\\"\";" << endl;
  oPopDriver << "               if( NonmemPars::omegaBlockStruct[notSameCount]==DIAGONAL )" << endl;
  oPopDriver << "                  oResults << \"diagonal\";" << endl;
  oPopDriver << "               else" << endl;
  oPopDriver << "                  oResults << \"block\";" << endl;
  oPopDriver << "               oResults << \"\\\"\" << \">\" << endl;" << endl;
  
  /*
  oPopDriver << "            for( int i=0; i<NonmemPars::omegaOrder; i++ )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               oResults << \"<value>\" << omegaOut[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "            }" << endl;
  */

  oPopDriver << "               if( NonmemPars::omegaBlockStruct[notSameCount]==DIAGONAL )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  for( int i=0; i<NonmemPars::omegaBlockDims[notSameCount]; i++, idx++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     oResults << \"<value>\" << omegaOut[idx] << \"</value>\" << endl;" << endl;
  oPopDriver << "                     nParForStats++;" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               else // full" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  int n = NonmemPars::omegaBlockDims[notSameCount];" << endl;
  oPopDriver << "                  int m = (n*(n+1))/2;" << endl;
  oPopDriver << "                  valarray<double> full( n * n );" << endl;
  oPopDriver << "                  valarray<double> row_minimal( m );" << endl;
  oPopDriver << endl;
  oPopDriver << "                  for( int j=0; j<n; j++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     for( int i=0; i<n-j; i++, idx++ )" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        full[j*n+(j+i)] = omegaOut[idx];  " << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "                  symmetrize( full, n, full );" << endl;
  oPopDriver << endl;
  oPopDriver << "                  for( int i=0, k=0; i<n; i++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     for( int j=0; j<i+1; j++, k++ )" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        row_minimal[k] = full[i*n+j];" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "                  for( int i=0; i<m; i++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     oResults << \"<value>\" << row_minimal[ i ];" << endl;
  oPopDriver << "                     oResults << \"</value>\" << endl;" << endl;
  oPopDriver << "                     nParForStats++;" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               oResults << \"</omega_out>\" << endl;" << endl;
  oPopDriver << "               //" << endl;
  oPopDriver << "               notSameCount++;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << endl;
  oPopDriver << "            ///////////////////////////////////////////////////////////////////" << endl;
  oPopDriver << "            //   Nonparametric method results" << endl;
  oPopDriver << "            if( isNonparamMethod )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               int nBMeasurePointOut = bWeightOut.size();" << endl;
  oPopDriver << "               assert( bMeasurePointOut.size() == nBTwoStageOrNonparam * nBMeasurePointOut );" << endl;
  oPopDriver << "               assert( bProbDensityOut .size() == nPop * nBMeasurePointOut );" << endl;
  oPopDriver << "               assert( bPostMeanOut    .size() == nBTwoStageOrNonparam * nPop );" << endl;
  oPopDriver << endl;
  oPopDriver << "               valarray<double> bMeasurePoint_jjj          ( nBTwoStageOrNonparam );" << endl;
  oPopDriver << "               valarray<double> thetaMeasurePoint_jjj      ( NonmemPars::nTheta );" << endl;
  oPopDriver << "               valarray<double> omegaMeasurePointMinRep_jjj( nSigmaParTwoStageOrNonparam );" << endl;
  oPopDriver << endl;
  oPopDriver << "               valarray<double> bPostMean_iii          ( nBTwoStageOrNonparam );" << endl;
  oPopDriver << "               valarray<double> thetaPostMean_iii      ( NonmemPars::nTheta );" << endl;
  oPopDriver << "               valarray<double> omegaPostMeanMinRep_iii( nSigmaParTwoStageOrNonparam );" << endl;
  oPopDriver << endl;
  oPopDriver << "               oResults << \"<nonparametric_result>\" << endl;" << endl;
  oPopDriver << endl;
  oPopDriver << "               oResults << \"<measure_point_in number=\\\"\" << nBMeasurePointIn << \"\\\">\" << endl;" << endl;
  oPopDriver << "               oResults << \"<theta_all_in rows=\\\"\" << nBMeasurePointIn" << endl;
  oPopDriver << "                        << \"\\\" columns=\\\"\" << NonmemPars::nTheta << \"\\\">\" << endl;" << endl;
  oPopDriver << "               for( int jjj=0; jjj<nBMeasurePointIn; jjj++ )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  bMeasurePoint_jjj = bMeasurePointIn[ slice( jjj*nBTwoStageOrNonparam, nBTwoStageOrNonparam, 1 ) ];" << endl;
  oPopDriver << "                  indModelForTwoStageOrNonparam.setIndPar( bMeasurePoint_jjj );" << endl;
  oPopDriver << "                  indModelForTwoStageOrNonparam.getTheta( thetaMeasurePoint_jjj );" << endl;
  oPopDriver << "                  for( int k=0; k<NonmemPars::nTheta; k++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     oResults << thetaMeasurePoint_jjj[k] << ( k < NonmemPars::nTheta - 1 ? \",\" : \"\" );" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "                  oResults << endl;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               oResults << \"</theta_all_in>\" << endl;" << endl;
  oPopDriver << endl;
  oPopDriver << "               // The population model's sigma value contains the" << endl;
  oPopDriver << "               // population mean of the individuals' omega values." << endl;
  oPopDriver << "               for(int ii=0, idx=0; ii<NonmemPars::nSigmaBlk; ii++)" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  // Save the starting index for this block. " << endl;
  oPopDriver << "                  int idx_ii = idx;" << endl;
  oPopDriver << endl;
  oPopDriver << "                  oResults << \"<omega_all_in dimension=\" << \"\\\"\" << NonmemPars::sigmaBlockDims[ii] << \"\\\"\";" << endl;
  oPopDriver << "                  oResults << \" struct=\" << \"\\\"\";" << endl;
  oPopDriver << "                  if( NonmemPars::sigmaBlockStruct[ii]==DIAGONAL )" << endl;
  oPopDriver << "                     oResults << \"diagonal\";" << endl;
  oPopDriver << "                  else" << endl;
  oPopDriver << "                     oResults << \"block\";" << endl;
  oPopDriver << "                  oResults << \"\\\"\";" << endl;
  oPopDriver << "                  oResults << \" rows=\" << \"\\\"\" << nBMeasurePointIn << \"\\\"\";" << endl;
  oPopDriver << "                  oResults << \" columns=\" << \"\\\"\" << NonmemPars::sigmaBlockDims[ii] << \"\\\"\";" << endl;
  oPopDriver << "                  oResults << \">\" << endl;" << endl;
  oPopDriver << endl;
  oPopDriver << "                  for( int jjj=0; jjj<nBMeasurePointIn; jjj++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     idx = idx_ii;" << endl;
  oPopDriver << endl;
  oPopDriver << "                     bMeasurePoint_jjj = bMeasurePointIn[ slice( jjj*nBTwoStageOrNonparam, nBTwoStageOrNonparam, 1 ) ];" << endl;
  oPopDriver << "                     indModelForTwoStageOrNonparam.setIndPar( bMeasurePoint_jjj );" << endl;
  oPopDriver << "                     indModelForTwoStageOrNonparam.getOmega( omegaMeasurePointMinRep_jjj );" << endl;
  oPopDriver << "   " << endl;
  oPopDriver << "                     if( NonmemPars::sigmaBlockStruct[ii]==DIAGONAL )" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        for( int i=0; i<NonmemPars::sigmaBlockDims[ii]; i++, idx++ )" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           oResults << omegaMeasurePointMinRep_jjj[idx] << ( i < NonmemPars::sigmaBlockDims[ii] - 1 ? \",\" : \"\" );" << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "                        oResults << endl;" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << "                     else // full" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        int n = NonmemPars::sigmaBlockDims[ii];" << endl;
  oPopDriver << "                        int m = (n*(n+1))/2;" << endl;
  oPopDriver << "                        valarray<double> full( n * n );" << endl;
  oPopDriver << "                        valarray<double> row_minimal( m );" << endl;
  oPopDriver << "      " << endl;
  oPopDriver << "                        // First make a full matrix out of the minimal representation" << endl;
  oPopDriver << "                        for( int j=0; j<n; j++ )" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           for( int i=0; i<n-j; i++, idx++ ) // lower only" << endl;
  oPopDriver << "                           {" << endl;
  oPopDriver << "                              full[ (j*n)+(j+i) ] = omegaMeasurePointMinRep_jjj[idx];" << endl;
  oPopDriver << "                           }" << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "      " << endl;
  oPopDriver << "                        // Copy the lower triangle to the upper and complete fullification" << endl;
  oPopDriver << "                        symmetrize( full, n, full );" << endl;
  oPopDriver << "      " << endl;
  oPopDriver << "                        // Read the lower triangle in the row-major order" << endl;
  oPopDriver << "                        for( int i=0, k=0; i<n; i++ )" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           for( int j=0; j<i+1; j++, k++ )" << endl;
  oPopDriver << "                           {" << endl;
  oPopDriver << "                              row_minimal[k] = full[(i*n)+j];" << endl;
  oPopDriver << "                           }" << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "      " << endl;
  oPopDriver << "                        for( int i=0; i<m; i++ )" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           oResults << row_minimal[ i ] << ( i < m - 1 ? \",\" : \"\" );" << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "                        oResults << endl;" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "                  oResults << \"</omega_all_in>\" << endl;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               oResults << \"</measure_point_in>\" << endl;" << endl;
  oPopDriver << endl;
  oPopDriver << "               oResults << \"<measure_point_out number=\\\"\" << nBMeasurePointOut << \"\\\">\" << endl;" << endl;
  oPopDriver << "               oResults << \"<theta_all_out rows=\\\"\" << nBMeasurePointOut" << endl;
  oPopDriver << "                        << \"\\\" columns=\\\"\" << NonmemPars::nTheta << \"\\\">\" << endl;" << endl;
  oPopDriver << "               for( int jjj=0; jjj<nBMeasurePointOut; jjj++ )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  bMeasurePoint_jjj = bMeasurePointOut[ slice( jjj*nBTwoStageOrNonparam, nBTwoStageOrNonparam, 1 ) ];" << endl;
  oPopDriver << "                  indModelForTwoStageOrNonparam.setIndPar( bMeasurePoint_jjj );" << endl;
  oPopDriver << "                  indModelForTwoStageOrNonparam.getTheta( thetaMeasurePoint_jjj );" << endl;
  oPopDriver << "                  for( int k=0; k<NonmemPars::nTheta; k++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     oResults << thetaMeasurePoint_jjj[k] << ( k < NonmemPars::nTheta - 1 ? \",\" : \"\" );" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "                  oResults << endl;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               oResults << \"</theta_all_out>\" << endl;" << endl;
  oPopDriver << endl;
  oPopDriver << "               // The population model's sigma value contains the" << endl;
  oPopDriver << "               // population mean of the individuals' omega values." << endl;
  oPopDriver << "               for(int ii=0, idx=0; ii<NonmemPars::nSigmaBlk; ii++)" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  // Save the starting index for this block. " << endl;
  oPopDriver << "                  int idx_ii = idx;" << endl;
  oPopDriver << endl;
  oPopDriver << "                  oResults << \"<omega_all_out dimension=\" << \"\\\"\" << NonmemPars::sigmaBlockDims[ii] << \"\\\"\";" << endl;
  oPopDriver << "                  oResults << \" struct=\" << \"\\\"\";" << endl;
  oPopDriver << "                  if( NonmemPars::sigmaBlockStruct[ii]==DIAGONAL )" << endl;
  oPopDriver << "                     oResults << \"diagonal\";" << endl;
  oPopDriver << "                  else" << endl;
  oPopDriver << "                     oResults << \"block\";" << endl;
  oPopDriver << "                  oResults << \"\\\"\";" << endl;
  oPopDriver << "                  oResults << \" rows=\" << \"\\\"\" << nBMeasurePointOut << \"\\\"\";" << endl;
  oPopDriver << "                  oResults << \" columns=\" << \"\\\"\" << NonmemPars::sigmaBlockDims[ii] << \"\\\"\";" << endl;
  oPopDriver << "                  oResults << \">\" << endl;" << endl;
  oPopDriver << endl;
  oPopDriver << "                  for( int jjj=0; jjj<nBMeasurePointOut; jjj++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     idx = idx_ii;" << endl;
  oPopDriver << endl;
  oPopDriver << "                     bMeasurePoint_jjj = bMeasurePointOut[ slice( jjj*nBTwoStageOrNonparam, nBTwoStageOrNonparam, 1 ) ];" << endl;
  oPopDriver << "                     indModelForTwoStageOrNonparam.setIndPar( bMeasurePoint_jjj );" << endl;
  oPopDriver << "                     indModelForTwoStageOrNonparam.getOmega( omegaMeasurePointMinRep_jjj );" << endl;
  oPopDriver << "   " << endl;
  oPopDriver << "                     if( NonmemPars::sigmaBlockStruct[ii]==DIAGONAL )" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        for( int i=0; i<NonmemPars::sigmaBlockDims[ii]; i++, idx++ )" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           oResults << omegaMeasurePointMinRep_jjj[idx] << ( i < NonmemPars::sigmaBlockDims[ii] - 1 ? \",\" : \"\" );" << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "                        oResults << endl;" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << "                     else // full" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        int n = NonmemPars::sigmaBlockDims[ii];" << endl;
  oPopDriver << "                        int m = (n*(n+1))/2;" << endl;
  oPopDriver << "                        valarray<double> full( n * n );" << endl;
  oPopDriver << "                        valarray<double> row_minimal( m );" << endl;
  oPopDriver << "      " << endl;
  oPopDriver << "                        // First make a full matrix out of the minimal representation" << endl;
  oPopDriver << "                        for( int j=0; j<n; j++ )" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           for( int i=0; i<n-j; i++, idx++ ) // lower only" << endl;
  oPopDriver << "                           {" << endl;
  oPopDriver << "                              full[ (j*n)+(j+i) ] = omegaMeasurePointMinRep_jjj[idx];" << endl;
  oPopDriver << "                           }" << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "      " << endl;
  oPopDriver << "                        // Copy the lower triangle to the upper and complete fullification" << endl;
  oPopDriver << "                        symmetrize( full, n, full );" << endl;
  oPopDriver << "      " << endl;
  oPopDriver << "                        // Read the lower triangle in the row-major order" << endl;
  oPopDriver << "                        for( int i=0, k=0; i<n; i++ )" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           for( int j=0; j<i+1; j++, k++ )" << endl;
  oPopDriver << "                           {" << endl;
  oPopDriver << "                              row_minimal[k] = full[(i*n)+j];" << endl;
  oPopDriver << "                           }" << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "      " << endl;
  oPopDriver << "                        for( int i=0; i<m; i++ )" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           oResults << row_minimal[ i ] << ( i < m - 1 ? \",\" : \"\" );" << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "                        oResults << endl;" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "                  oResults << \"</omega_all_out>\" << endl;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               oResults << \"</measure_point_out>\" << endl;" << endl;
  oPopDriver << endl;
  oPopDriver << "               oResults << \"<weight_all_out rows=\\\"\" << nBMeasurePointOut" << endl;
  oPopDriver << "                        << \"\\\" columns=\\\"1\\\">\" << endl;" << endl;
  oPopDriver << "               for( int jjj=0; jjj<nBMeasurePointOut; jjj++ )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  oResults << bWeightOut[jjj] << endl;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               oResults << \"</weight_all_out>\" << endl;" << endl;
  oPopDriver << "               oResults << \"<probability_density_all_out rows=\\\"\" << nBMeasurePointOut" << endl;
  oPopDriver << "                        << \"\\\" columns=\\\"\" << nPop << \"\\\">\" << endl;" << endl;
  oPopDriver << "               for( int jjj=0; jjj<nBMeasurePointOut; jjj++ )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  for( int i=0; i<nPop; i++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     // This XML block contains the transpose of the" << endl;
  oPopDriver << "                     // matrix returned by predNonparamMethod." << endl;
  oPopDriver << "                    oResults << bProbDensityOut[i + jjj * nPop] << ( i < nPop - 1 ? \",\" : \"\" );" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "                  oResults << endl;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               oResults << \"</probability_density_all_out>\" << endl;" << endl;
  oPopDriver << endl;
  oPopDriver << "               oResults << \"<posterior_mean_out number=\\\"\" << nPop << \"\\\">\" << endl;" << endl;
  oPopDriver << "               oResults << \"<theta_all_out rows=\\\"\" << nPop" << endl;
  oPopDriver << "                        << \"\\\" columns=\\\"\" << NonmemPars::nTheta << \"\\\">\" << endl;" << endl;
  oPopDriver << "               for( int iii=0; iii<nPop; iii++ )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  bPostMean_iii = bPostMeanOut[ slice( iii*nBTwoStageOrNonparam, nBTwoStageOrNonparam, 1 ) ];" << endl;
  oPopDriver << "                  indModelForTwoStageOrNonparam.setIndPar( bPostMean_iii );" << endl;
  oPopDriver << "                  indModelForTwoStageOrNonparam.getTheta( thetaPostMean_iii );" << endl;
  oPopDriver << "                  for( int k=0; k<NonmemPars::nTheta; k++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     oResults << thetaPostMean_iii[k] << ( k < NonmemPars::nTheta - 1 ? \",\" : \"\" );" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "                  oResults << endl;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               oResults << \"</theta_all_out>\" << endl;" << endl;
  oPopDriver << endl;
  oPopDriver << "               // The population model's sigma value contains the" << endl;
  oPopDriver << "               // population mean of the individuals' omega values." << endl;
  oPopDriver << "               for(int ii=0, idx=0; ii<NonmemPars::nSigmaBlk; ii++)" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  // Save the starting index for this block. " << endl;
  oPopDriver << "                  int idx_ii = idx;" << endl;
  oPopDriver << endl;
  oPopDriver << "                  oResults << \"<omega_all_out dimension=\" << \"\\\"\" << NonmemPars::sigmaBlockDims[ii] << \"\\\"\";" << endl;
  oPopDriver << "                  oResults << \" struct=\" << \"\\\"\";" << endl;
  oPopDriver << "                  if( NonmemPars::sigmaBlockStruct[ii]==DIAGONAL )" << endl;
  oPopDriver << "                     oResults << \"diagonal\";" << endl;
  oPopDriver << "                  else" << endl;
  oPopDriver << "                     oResults << \"block\";" << endl;
  oPopDriver << "                  oResults << \"\\\"\";" << endl;
  oPopDriver << "                  oResults << \" rows=\" << \"\\\"\" << nPop << \"\\\"\";" << endl;
  oPopDriver << "                  oResults << \" columns=\" << \"\\\"\" << NonmemPars::sigmaBlockDims[ii] << \"\\\"\";" << endl;
  oPopDriver << "                  oResults << \">\" << endl;" << endl;
  oPopDriver << endl;
  oPopDriver << "                  for( int iii=0; iii<nPop; iii++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     idx = idx_ii;" << endl;
  oPopDriver << endl;
  oPopDriver << "                     bPostMean_iii = bPostMeanOut[ slice( iii*nBTwoStageOrNonparam, nBTwoStageOrNonparam, 1 ) ];" << endl;
  oPopDriver << "                     indModelForTwoStageOrNonparam.setIndPar( bPostMean_iii );" << endl;
  oPopDriver << "                     indModelForTwoStageOrNonparam.getOmega( omegaPostMeanMinRep_iii );" << endl;
  oPopDriver << "                     if( NonmemPars::sigmaBlockStruct[ii]==DIAGONAL )" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        for( int i=0; i<NonmemPars::sigmaBlockDims[ii]; i++, idx++ )" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           oResults << omegaPostMeanMinRep_iii[idx] << ( i < NonmemPars::sigmaBlockDims[ii] - 1 ? \",\" : \"\" );" << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "                        oResults << endl;" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << "                     else // full" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        int n = NonmemPars::sigmaBlockDims[ii];" << endl;
  oPopDriver << "                        int m = (n*(n+1))/2;" << endl;
  oPopDriver << "                        valarray<double> full( n * n );" << endl;
  oPopDriver << "                        valarray<double> row_minimal( m );" << endl;
  oPopDriver << "      " << endl;
  oPopDriver << "                        // First make a full matrix out of the minimal representation" << endl;
  oPopDriver << "                        for( int j=0; j<n; j++ )" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           for( int i=0; i<n-j; i++, idx++ ) // lower only" << endl;
  oPopDriver << "                           {" << endl;
  oPopDriver << "                              full[ (j*n)+(j+i) ] = omegaPostMeanMinRep_iii[idx];" << endl;
  oPopDriver << "                           }" << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "      " << endl;
  oPopDriver << "                        // Copy the lower triangle to the upper and complete fullification" << endl;
  oPopDriver << "                        symmetrize( full, n, full );" << endl;
  oPopDriver << "      " << endl;
  oPopDriver << "                        // Read the lower triangle in the row-major order" << endl;
  oPopDriver << "                        for( int i=0, k=0; i<n; i++ )" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           for( int j=0; j<i+1; j++, k++ )" << endl;
  oPopDriver << "                           {" << endl;
  oPopDriver << "                              row_minimal[k] = full[(i*n)+j];" << endl;
  oPopDriver << "                           }" << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "      " << endl;
  oPopDriver << "                        for( int i=0; i<m; i++ )" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           oResults << row_minimal[ i ] << ( i < m - 1 ? \",\" : \"\" );" << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "                        oResults << endl;" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "                  oResults << \"</omega_all_out>\" << endl;" << endl;
  oPopDriver << "               }" << endl;
  oPopDriver << "               oResults << \"</posterior_mean_out>\" << endl;" << endl;
  oPopDriver << endl;
  oPopDriver << "               oResults << \"</nonparametric_result>\" << endl;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << endl;
  oPopDriver << "            ///////////////////////////////////////////////////////////////////" << endl;
  oPopDriver << "            oResults << \"</pop_opt_result>\" << endl;" << endl;
  oPopDriver << endl;
  
  oPopDriver << "            if( isStatRequested )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               oResults << \"<pop_stat_result elapsedtime=\\\"\" << statTimeSec << \"\\\">\" << endl;" << endl;
  oPopDriver << "               if( isCovOut )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  oResults << \"<pop_covariance_out struct=\\\"block\\\" dimension=\\\"\" << nAlp << \"\\\">\" << endl;" << endl;
  oPopDriver << "                  for( int i=0; i<nAlp; i++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     for( int j=0; j<=i; j++ )" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        oResults << \"   <value>\" << stdParCovOut[i+j*nAlp] << \"</value>\" << endl;" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "                  oResults << \"</pop_covariance_out>\" << endl;" << endl;
  oPopDriver << "               }" << endl;
  
  oPopDriver << "               if( isInvCovOut )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  oResults << \"<pop_inverse_covariance_out struct=\\\"block\\\" dimension=\\\"\" << nAlp << \"\\\">\" << endl;" << endl;
  oPopDriver << "                  for( int i=0; i<nAlp; i++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     for( int j=0; j<=i; j++ )" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        oResults << \"   <value>\" << stdParInvCovOut[i+j*nAlp] << \"</value>\" << endl;" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "                  oResults << \"</pop_inverse_covariance_out>\" << endl;" << endl;
  oPopDriver << "               }" << endl;
  
  oPopDriver << "               if( isStdErrOut )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  oResults << \"<pop_stderror_out length=\\\"\" << nParForStats << \"\\\">\" << endl;" << endl;
  oPopDriver << "                  int i=0;" << endl;
  oPopDriver << "                  for( i=0; i<NonmemPars::nTheta; i++)" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     oResults << \"   <value>\" << stdParSEOut[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "                  }" << endl;	      
  oPopDriver << "                  int notSameCount = 0;" << endl;
  oPopDriver << "                  for(int ii=0; ii<NonmemPars::nOmegaBlk; ii++)" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     if ( NonmemPars::omegaBlockSameAsPrev[ii] )" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        notSameCount--;" << endl;
  oPopDriver << "                        assert( ii != 0 );" << endl;
  oPopDriver << endl;
  oPopDriver << "                        if( NonmemPars::omegaBlockStruct[notSameCount]==DIAGONAL )" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           i -= NonmemPars::omegaBlockDims[notSameCount];" << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "                        else // full" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           int n = NonmemPars::omegaBlockDims[notSameCount];" << endl;
  oPopDriver << "                           int m = (n*(n+1))/2;" << endl;
  oPopDriver << "                           i -= m;" << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << "                     if( NonmemPars::omegaBlockStruct[notSameCount]==DIAGONAL )" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        for(int iii=0; iii<NonmemPars::omegaBlockDims[notSameCount]; iii++)" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           oResults << \"   <value>\" << stdParSEOut[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "                           i++;  " << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << "                     else // full" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        int n = NonmemPars::omegaBlockDims[notSameCount];" << endl;
  oPopDriver << "                        int m = (n*(n+1))/2;" << endl;
  oPopDriver << "                        for(int iii=0; iii<m; iii++)" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           oResults << \"   <value>\" << stdParSEOut[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "                           i++;  " << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << endl;
  oPopDriver << "                     notSameCount++;" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "                  notSameCount = 0;" << endl;
  oPopDriver << "                  for(int ii=0; ii<NonmemPars::nSigmaBlk; ii++)" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     if ( NonmemPars::sigmaBlockSameAsPrev[ii] )" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        notSameCount--;" << endl;
  oPopDriver << "                        assert( ii != 0 );" << endl;
  oPopDriver << "                        if( NonmemPars::sigmaBlockStruct[notSameCount]==DIAGONAL )" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           i -= NonmemPars::sigmaBlockDims[notSameCount];" << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "                        else // full" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           int n = NonmemPars::sigmaBlockDims[notSameCount];" << endl;
  oPopDriver << "                           int m = (n*(n+1))/2;" << endl;
  oPopDriver << "                           i -= m;" << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << "                     if( NonmemPars::sigmaBlockStruct[notSameCount]==DIAGONAL )" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        for(int iii=0; iii<NonmemPars::sigmaBlockDims[notSameCount]; iii++)" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           oResults << \"   <value>\" << stdParSEOut[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "                           i++;  " << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << "                     else // full" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        int n = NonmemPars::sigmaBlockDims[notSameCount];" << endl;
  oPopDriver << "                        int m = (n*(n+1))/2;" << endl;
  oPopDriver << "                        for(int iii=0; iii<m; iii++)" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           oResults << \"   <value>\" << stdParSEOut[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "                           i++;  " << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << endl;
  oPopDriver << "                     notSameCount++;" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "                  oResults << \"</pop_stderror_out>\" << endl;" << endl;
  oPopDriver << "               }" << endl;
  
  oPopDriver << "               if( isCorrelationOut )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  oResults << \"<pop_correlation_out struct=\\\"block\\\" dimension=\\\"\" << nAlp << \"\\\">\" << endl;" << endl;
  oPopDriver << "                  for( int i=0; i<nAlp; i++ )" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     for( int j=0; j<=i; j++ )" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        oResults << \"   <value>\" << stdParCorrelationOut[i+j*nAlp] << \"</value>\" << endl;" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << "                  }" << endl;   
  oPopDriver << "                  oResults << \"</pop_correlation_out>\" << endl;" << endl;
  oPopDriver << "               }" << endl;
  
  oPopDriver << "               if( isCoefficientOut )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  oResults << \"<pop_coefficient_out length=\\\"\" << nParForStats << \"\\\">\" << endl;" << endl;
  oPopDriver << "                  int i=0;" << endl;
  oPopDriver << "                  for( i=0; i<NonmemPars::nTheta; i++)" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     oResults << \"   <value>\" << stdParCoefficientOut[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "                  }" << endl;	      
  oPopDriver << "                  int notSameCount = 0;" << endl;
  oPopDriver << "                  for(int ii=0; ii<NonmemPars::nOmegaBlk; ii++)" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     if ( NonmemPars::omegaBlockSameAsPrev[ii] )" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        notSameCount--;" << endl;
  oPopDriver << "                        assert( ii != 0 );" << endl;
  oPopDriver << endl;
  oPopDriver << "                        if( NonmemPars::omegaBlockStruct[notSameCount]==DIAGONAL )" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           i -= NonmemPars::omegaBlockDims[notSameCount];" << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "                        else // full" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           int n = NonmemPars::omegaBlockDims[notSameCount];" << endl;
  oPopDriver << "                           int m = (n*(n+1))/2;" << endl;
  oPopDriver << "                           i -= m;" << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << "                     if( NonmemPars::omegaBlockStruct[notSameCount]==DIAGONAL )" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        for(int iii=0; iii<NonmemPars::omegaBlockDims[notSameCount]; iii++)" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           oResults << \"   <value>\" << stdParCoefficientOut[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "                           i++;  " << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << "                     else // full" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        int n = NonmemPars::omegaBlockDims[notSameCount];" << endl;
  oPopDriver << "                        int m = (n*(n+1))/2;" << endl;
  oPopDriver << "                        for(int iii=0; iii<m; iii++)" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           oResults << \"   <value>\" << stdParCoefficientOut[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "                           i++;  " << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << endl;
  oPopDriver << "                     notSameCount++;" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "                  notSameCount = 0;" << endl;
  oPopDriver << "                  for(int ii=0; ii<NonmemPars::nSigmaBlk; ii++)" << endl;
  oPopDriver << "                  {" << endl;
  oPopDriver << "                     if ( NonmemPars::sigmaBlockSameAsPrev[ii] )" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        notSameCount--;" << endl;
  oPopDriver << "                        assert( ii != 0 );" << endl;
  oPopDriver << "                        if( NonmemPars::sigmaBlockStruct[notSameCount]==DIAGONAL )" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           i -= NonmemPars::sigmaBlockDims[notSameCount];" << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "                        else // full" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           int n = NonmemPars::sigmaBlockDims[notSameCount];" << endl;
  oPopDriver << "                           int m = (n*(n+1))/2;" << endl;
  oPopDriver << "                           i -= m;" << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << "                     if( NonmemPars::sigmaBlockStruct[notSameCount]==DIAGONAL )" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        for(int iii=0; iii<NonmemPars::sigmaBlockDims[notSameCount]; iii++)" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           oResults << \"   <value>\" << stdParCoefficientOut[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "                           i++;  " << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << "                     else // full" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        int n = NonmemPars::sigmaBlockDims[notSameCount];" << endl;
  oPopDriver << "                        int m = (n*(n+1))/2;" << endl;
  oPopDriver << "                        for(int iii=0; iii<m; iii++)" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           oResults << \"   <value>\" << stdParCoefficientOut[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "                           i++;  " << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << endl;
  oPopDriver << "                     notSameCount++;" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << endl;
  oPopDriver << "                  oResults << \"</pop_coefficient_out>\" << endl;" << endl;
  oPopDriver << "               }" << endl;
  
  oPopDriver << "               if( isConfidenceOut )" << endl;
  oPopDriver << "               {" << endl;
  oPopDriver << "                  oResults << \"<pop_confidence_out length=\\\"\" << 2 * nParForStats << \"\\\">\" << endl;" << endl;
  oPopDriver << "                  int i=0;" << endl;
  oPopDriver << "                  for(int k=0; k < 2; k++)" << endl;
  oPopDriver << "                   {" << endl;
  oPopDriver << "                     for(int ii=0; ii < NonmemPars::nTheta; ii++)" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        oResults << \"   <value>\" << stdParConfidenceOut[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "                        i++;  " << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << "                     int notSameCount = 0;" << endl;
  oPopDriver << "                     for(int ii=0; ii < NonmemPars::nOmegaBlk; ii++)" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        if ( NonmemPars::omegaBlockSameAsPrev[ii] )" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           notSameCount--;" << endl;
  oPopDriver << "                           assert( ii != 0 );" << endl;
  oPopDriver << endl;
  oPopDriver << "                           if( NonmemPars::omegaBlockStruct[notSameCount]==DIAGONAL )" << endl;
  oPopDriver << "                           {" << endl;
  oPopDriver << "                              i -= NonmemPars::omegaBlockDims[notSameCount];" << endl;
  oPopDriver << "                           }" << endl;
  oPopDriver << "                           else // full" << endl;
  oPopDriver << "                           {" << endl;
  oPopDriver << "                              int n = NonmemPars::omegaBlockDims[notSameCount];" << endl;
  oPopDriver << "                              int m = (n*(n+1))/2;" << endl;
  oPopDriver << "                              i -= m;" << endl;
  oPopDriver << "                           }" << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "                        if( NonmemPars::omegaBlockStruct[notSameCount]==DIAGONAL )" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           for(int iii=0; iii < NonmemPars::omegaBlockDims[notSameCount]; iii++)" << endl;
  oPopDriver << "                           {" << endl;
  oPopDriver << "                              oResults << \"   <value>\" << stdParConfidenceOut[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "                              i++;  " << endl;
  oPopDriver << "                           }" << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "                        else // full" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           int n = NonmemPars::omegaBlockDims[notSameCount];" << endl;
  oPopDriver << "                           int m = (n*(n+1))/2;" << endl;
  oPopDriver << "                           for(int iii=0; iii < m; iii++)" << endl;
  oPopDriver << "                           {" << endl;
  oPopDriver << "                              oResults << \"   <value>\" << stdParConfidenceOut[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "                              i++;  " << endl;
  oPopDriver << "                           }" << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << endl;
  oPopDriver << "                        notSameCount++;" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << "                     notSameCount = 0;" << endl;
  oPopDriver << "                     for(int ii=0; ii<NonmemPars::nSigmaBlk; ii++)" << endl;
  oPopDriver << "                     {" << endl;
  oPopDriver << "                        if ( NonmemPars::sigmaBlockSameAsPrev[ii] )" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           notSameCount--;" << endl;
  oPopDriver << "                           assert( ii != 0 );" << endl;
  oPopDriver << "                           if( NonmemPars::sigmaBlockStruct[notSameCount]==DIAGONAL )" << endl;
  oPopDriver << "                           {" << endl;
  oPopDriver << "                              i -= NonmemPars::sigmaBlockDims[notSameCount];" << endl;
  oPopDriver << "                           }" << endl;
  oPopDriver << "                           else // full" << endl;
  oPopDriver << "                           {" << endl;
  oPopDriver << "                              int n = NonmemPars::sigmaBlockDims[notSameCount];" << endl;
  oPopDriver << "                              int m = (n*(n+1))/2;" << endl;
  oPopDriver << "                              i -= m;" << endl;
  oPopDriver << "                           }" << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "                        if( NonmemPars::sigmaBlockStruct[notSameCount]==DIAGONAL )" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           for(int iii=0; iii < NonmemPars::sigmaBlockDims[notSameCount]; iii++)" << endl;
  oPopDriver << "                           {" << endl;
  oPopDriver << "                              oResults << \"   <value>\" << stdParConfidenceOut[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "                              i++;  " << endl;
  oPopDriver << "                           }" << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << "                        else // full" << endl;
  oPopDriver << "                        {" << endl;
  oPopDriver << "                           int n = NonmemPars::sigmaBlockDims[notSameCount];" << endl;
  oPopDriver << "                           int m = (n*(n+1))/2;" << endl;
  oPopDriver << "                           for(int iii=0; iii < m; iii++)" << endl;
  oPopDriver << "                           {" << endl;
  oPopDriver << "                              oResults << \"   <value>\" << stdParConfidenceOut[i] << \"</value>\" << endl;" << endl;
  oPopDriver << "                              i++;  " << endl;
  oPopDriver << "                           }" << endl;
  oPopDriver << "                        }" << endl;
  oPopDriver << endl;
  oPopDriver << "                        notSameCount++;" << endl;
  oPopDriver << "                     }" << endl;
  oPopDriver << "                  }" << endl;
  oPopDriver << "                  oResults << \"</pop_confidence_out>\" << endl;" << endl;
  oPopDriver << "               }" << endl;
  
  oPopDriver << "               oResults << \"</pop_stat_result>\" << endl;" << endl;
  oPopDriver << endl;
  oPopDriver << "            }" << endl;
  
  oPopDriver << "            oResults << \"</pop_analysis_result>\" << endl;" << endl;
  oPopDriver << "         }" << endl;
  oPopDriver << endl;
  // Print out <presentation_data> if this is the last subproblem.
  oPopDriver << "         if( iSub == nRepeats-1 )" << endl;
  oPopDriver << "         {" << endl;
  oPopDriver << "            // Use the proper data set here." << endl;
  oPopDriver << "            if( !isTwoStageMethod && !isNonparamMethod )" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               oResults << set << endl;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "            else" << endl;
  oPopDriver << "            {" << endl;
  oPopDriver << "               oResults << dataForDisposal << endl;" << endl;
  oPopDriver << "            }" << endl;
  oPopDriver << "         }" << endl;
  oPopDriver << endl;
  oPopDriver << "         oResults << \"</spkreport>\" << endl;" << endl;
  oPopDriver << "         oResults.close();" << endl;
  oPopDriver << "      }" << endl;
  oPopDriver << endl;
  oPopDriver << "END:" << endl;
  oPopDriver << "      // The following statement is to trick g++ compiler, which" << endl;
  oPopDriver << "      // complains that a label must be followed by a statement." << endl;
  oPopDriver << "      int dummy = 0;" << endl;
  oPopDriver << "   }" << endl;
  oPopDriver << "   catch( const SpkException & e )" << endl;
  oPopDriver << "   {" << endl;
  oPopDriver << "      ofstream oResults;" << endl;
  oPopDriver << "      oResults.open( \"" << fResult_xml << "\", ios_base::app );" << endl;
  oPopDriver << "      if( !oResults.good() )" << endl;
  oPopDriver << "      {" << endl;
  oPopDriver << "         fprintf( stderr, \"Failed to open a file, %s, for writing output.\"," << endl;
  oPopDriver << "\"" << fResult_xml << "\" );" << endl;
  oPopDriver << "         ret = FILE_ACCESS_ERROR;" << endl;
  oPopDriver << "         if(nPvmTasks > 0)" << endl;
  oPopDriver << "            finish(ret);" << endl;
  oPopDriver << "         else" << endl;
  oPopDriver << "            cout << \"exit code: \" << ret << endl;" << endl;
  oPopDriver << "         fclose( stdout );" << endl;
  oPopDriver << "         fclose( stderr );" << endl;
  oPopDriver << "         return ret;" << endl;
  oPopDriver << "      }" << endl;
  oPopDriver << "      oResults << \"<?xml version=\\\"1.0\\\"?>\" << endl;" << endl;
  oPopDriver << "      oResults << \"<spkreport>\" << endl;" << endl;
  oPopDriver << "      oResults << \"<error_list length=\\\"\" << e.size() << \"\\\">\" << endl;" << endl;
  oPopDriver << "      oResults << e << endl;" << endl;
  oPopDriver << "      oResults << \"</error_list>\" << endl;" << endl;
  oPopDriver << "      oResults << \"</spkreport>\" << endl;" << endl;
  oPopDriver << "      oResults.close();" << endl;
  oPopDriver << "      ret = UNKNOWN_ERROR;" << endl;
  oPopDriver << "   }" << endl;
  oPopDriver << "   catch( const std::exception& stde )" << endl;
  oPopDriver << "   {" << endl;
  oPopDriver << "      ofstream oResults;" << endl;
  oPopDriver << "      oResults.open( \"" << fResult_xml << "\", ios_base::app );" << endl;
  oPopDriver << "      if( !oResults.good() )" << endl;
  oPopDriver << "      {" << endl;
  oPopDriver << "         fprintf( stderr, \"Failed to open a file, %s, for writing output.\"," << endl;
  oPopDriver << "\"" << fResult_xml << "\" );" << endl;
  oPopDriver << "         ret = FILE_ACCESS_ERROR;" << endl;
  oPopDriver << "         if(nPvmTasks > 0)" << endl;
  oPopDriver << "            finish(ret);" << endl;
  oPopDriver << "         else" << endl;
  oPopDriver << "            cout << \"exit code: \" << ret << endl;" << endl;
  oPopDriver << "         fclose( stdout );" << endl;
  oPopDriver << "         fclose( stderr );" << endl;
  oPopDriver << "         return ret;" << endl;
  oPopDriver << "      }" << endl;
  oPopDriver << "      oResults << \"<?xml version=\\\"1.0\\\"?>\" << endl;" << endl;
  oPopDriver << "      oResults << \"<spkreport>\" << endl;" << endl;
  oPopDriver << "      oResults << \"<error_list length=\\\"\" << 1 << \"\\\">\" << endl;" << endl;
  oPopDriver << "      SpkError e( stde, \"A standard exception occurred.\", __LINE__, __FILE__ );" << endl;
  oPopDriver << "      oResults << e << endl;" << endl;
  oPopDriver << "      oResults << \"</error_list>\" << endl;" << endl;
  oPopDriver << "      oResults << \"</spkreport>\" << endl;" << endl;
  oPopDriver << "      oResults.close();" << endl;
  oPopDriver << "      ret = UNKNOWN_ERROR;" << endl;
  oPopDriver << "   }" << endl;
  oPopDriver << "   catch( ... )" << endl;
  oPopDriver << "   {" << endl;
  oPopDriver << "      ofstream oResults;" << endl;
  oPopDriver << "      oResults.open( \"" << fResult_xml << "\", ios_base::app );" << endl;
  oPopDriver << "      if( !oResults.good() )" << endl;
  oPopDriver << "      {" << endl;
  oPopDriver << "         fprintf( stderr, \"Failed to open a file, %s, for writing output.\"," << endl;
  oPopDriver << "\"" << fResult_xml << "\" );" << endl;
  oPopDriver << "         ret = FILE_ACCESS_ERROR;" << endl;
  oPopDriver << "         if(nPvmTasks > 0)" << endl;
  oPopDriver << "            finish(ret);" << endl;
  oPopDriver << "         else" << endl;
  oPopDriver << "            cout << \"exit code: \" << ret << endl;" << endl;
  oPopDriver << "         fclose( stdout );" << endl;
  oPopDriver << "         fclose( stderr );" << endl;
  oPopDriver << "         return ret;" << endl;
  oPopDriver << "      }" << endl;
  oPopDriver << "      oResults << \"<?xml version=\\\"1.0\\\"?>\" << endl;" << endl;
  oPopDriver << "      oResults << \"<spkreport>\" << endl;" << endl;
  oPopDriver << "      oResults << \"<error_list length=\\\"\" << 1 << \"\\\">\" << endl;" << endl;
  oPopDriver << "      SpkError e( SpkError::SPK_UNKNOWN_ERR, \"An unknown exception occurred.\", __LINE__, __FILE__ );" << endl;
  oPopDriver << "      oResults << e << endl;" << endl;
  oPopDriver << "      oResults << \"</error_list>\" << endl;" << endl;
  oPopDriver << "      oResults << \"</spkreport>\" << endl;" << endl;
  oPopDriver << "      oResults.close();" << endl;
  oPopDriver << "      ret = UNKNOWN_ERROR;" << endl;
  oPopDriver << "   }" << endl;
  oPopDriver << endl;
  oPopDriver << "   if(nPvmTasks > 0)" << endl;
  oPopDriver << "      finish(ret);" << endl;
  oPopDriver << "   else" << endl;
  oPopDriver << "      cout << \"exit code: \" << ret << endl;" << endl;
  oPopDriver << "   fclose( stdout );" << endl;
  oPopDriver << "   fclose( stderr );" << endl;
  oPopDriver << "   return ret;" << endl;
  oPopDriver << "}" << endl;
  oPopDriver.close();
}
