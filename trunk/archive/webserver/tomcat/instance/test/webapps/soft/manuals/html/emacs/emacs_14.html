<HTML>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created on April 2, 2002 by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>GNU Emacs Manual: Search</TITLE>

<META NAME="description" CONTENT="GNU Emacs Manual: Search">
<META NAME="keywords" CONTENT="GNU Emacs Manual: Search">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="EN" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC91"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_13.html#SEC90"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC92"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_13.html#SEC77"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_15.html#SEC105"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> K. Searching and Replacement </H1>
<!--docid::SEC91::-->
<P>

  Like other editors, Emacs has commands for searching for occurrences of
a string.  The principal search command is unusual in that it is
<EM>incremental</EM>; it begins to search before you have finished typing the
search string.  There are also nonincremental search commands more like
those of other editors.
</P><P>

  Besides the usual <CODE>replace-string</CODE> command that finds all
occurrences of one string and replaces them with another, Emacs has a
more flexible replacement command called <CODE>query-replace</CODE>, which
asks interactively which occurrences to replace.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="emacs_14.html#SEC92">K.1 Incremental Search</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Search happens as you type the string.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="emacs_14.html#SEC94">K.2 Nonincremental Search</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Specify entire string and then search.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="emacs_14.html#SEC95">K.3 Word Search</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Search for sequence of words.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="emacs_14.html#SEC96">K.4 Regular Expression Search</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Search for match for a regexp.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="emacs_14.html#SEC97">K.5 Syntax of Regular Expressions</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Syntax of regular expressions.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="emacs_14.html#SEC98">K.6 Searching and Case</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">To ignore case while searching, or not.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="emacs_14.html#SEC99">K.7 Replacement Commands</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Search, and replace some or all matches.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="emacs_14.html#SEC104">K.8 Other Search-and-Loop Commands</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Operating on all matches for some regexp.</TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Incremental Search"></A>
<HR SIZE="6">
<A NAME="SEC92"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC91"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC93"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC91"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC91"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC94"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> K.1 Incremental Search </H2>
<!--docid::SEC92::-->
<P>

<A NAME="IDX436"></A>
  An incremental search begins searching as soon as you type the first
character of the search string.  As you type in the search string, Emacs
shows you where the string (as you have typed it so far) would be
found.  When you have typed enough characters to identify the place you
want, you can stop.  Depending on what you plan to do next, you may or
may not need to terminate the search explicitly with <KBD>RET</KBD>.
</P><P>

<DL COMPACT>
<DT><KBD>C-s</KBD>
<DD>Incremental search forward (<CODE>isearch-forward</CODE>).
<DT><KBD>C-r</KBD>
<DD>Incremental search backward (<CODE>isearch-backward</CODE>).
</DL>
<P>

<A NAME="IDX437"></A>
<A NAME="IDX438"></A>
  <KBD>C-s</KBD> starts a forward incremental search.  It reads characters
from the keyboard, and moves point past the next occurrence of those
characters.  If you type <KBD>C-s</KBD> and then <KBD>F</KBD>, that puts the
cursor after the first <SAMP>`F'</SAMP> (the first following the starting point, since
this is a forward search).  Then if you type an <KBD>O</KBD>, you will see
the cursor move just after the first <SAMP>`FO'</SAMP> (the <SAMP>`F'</SAMP> in that
<SAMP>`FO'</SAMP> may or may not be the first <SAMP>`F'</SAMP>).  After another
<KBD>O</KBD>, the cursor moves after the first <SAMP>`FOO'</SAMP> after the place
where you started the search.  At each step, the buffer text that
matches the search string is highlighted, if the terminal can do that;
the current search string is always displayed in the echo area.
</P><P>

  If you make a mistake in typing the search string, you can cancel
characters with <KBD>DEL</KBD>.  Each <KBD>DEL</KBD> cancels the last character of
search string.  This does not happen until Emacs is ready to read another
input character; first it must either find, or fail to find, the character
you want to erase.  If you do not want to wait for this to happen, use
<KBD>C-g</KBD> as described below.
</P><P>

  When you are satisfied with the place you have reached, you can type
<KBD>RET</KBD>, which stops searching, leaving the cursor where the search
brought it.  Also, any command not specially meaningful in searches
stops the searching and is then executed.  Thus, typing <KBD>C-a</KBD>
would exit the search and then move to the beginning of the line.
<KBD>RET</KBD> is necessary only if the next command you want to type is a
printing character, <KBD>DEL</KBD>, <KBD>RET</KBD>, or another character that is
special within searches (<KBD>C-q</KBD>, <KBD>C-w</KBD>, <KBD>C-r</KBD>, <KBD>C-s</KBD>,
<KBD>C-y</KBD>, <KBD>M-y</KBD>, <KBD>M-r</KBD>, <KBD>M-s</KBD>, and some other
meta-characters).
</P><P>

  Sometimes you search for <SAMP>`FOO'</SAMP> and find one, but not the one you
expected to find.  There was a second <SAMP>`FOO'</SAMP> that you forgot
about, before the one you were aiming for.  In this event, type
another <KBD>C-s</KBD> to move to the next occurrence of the search string.
You can repeat this any number of times.  If you overshoot, you can
cancel some <KBD>C-s</KBD> characters with <KBD>DEL</KBD>.
</P><P>

  After you exit a search, you can search for the same string again by
typing just <KBD>C-s C-s</KBD>: the first <KBD>C-s</KBD> is the key that invokes
incremental search, and the second <KBD>C-s</KBD> means "search again."
</P><P>

  To reuse earlier search strings, use the <EM>search ring</EM>.  The
commands <KBD>M-p</KBD> and <KBD>M-n</KBD> move through the ring to pick a search
string to reuse.  These commands leave the selected search ring element
in the minibuffer, where you can edit it.  Type <KBD>C-s</KBD> or <KBD>C-r</KBD>
to terminate editing the string and search for it.
</P><P>

  If your string is not found at all, the echo area says <SAMP>`Failing
I-Search'</SAMP>.  The cursor is after the place where Emacs found as much of your
string as it could.  Thus, if you search for <SAMP>`FOOT'</SAMP>, and there is no
<SAMP>`FOOT'</SAMP>, you might see the cursor after the <SAMP>`FOO'</SAMP> in <SAMP>`FOOL'</SAMP>.
At this point there are several things you can do.  If your string was
mistyped, you can rub some of it out and correct it.  If you like the place
you have found, you can type <KBD>RET</KBD> or some other Emacs command to
remain there.  Or you can type <KBD>C-g</KBD>, which
removes from the search string the characters that could not be found (the
<SAMP>`T'</SAMP> in <SAMP>`FOOT'</SAMP>), leaving those that were found (the <SAMP>`FOO'</SAMP> in
<SAMP>`FOOT'</SAMP>).  A second <KBD>C-g</KBD> at that point cancels the search
entirely, returning point to where it was when the search started.
</P><P>

  An upper-case letter in the search string makes the search
case-sensitive.  If you delete the upper-case character from the search
string, it ceases to have this effect.  See section <A HREF="emacs_14.html#SEC98">K.6 Searching and Case</A>.
</P><P>

  To search for a newline, type <KBD>C-j</KBD>.  To search for another
control character, such as control-S or carriage return, you must quote
it by typing <KBD>C-q</KBD> first.  This function of <KBD>C-q</KBD> is analogous
to its use for insertion (see section <A HREF="emacs_7.html#SEC20">D.1 Inserting Text</A>): it causes the
following character to be treated the way any "ordinary" character is
treated in the same context.  You can also specify a character by its
octal code: enter <KBD>C-q</KBD> followed by a sequence of octal digits.
</P><P>

<A NAME="IDX439"></A>
<A NAME="IDX440"></A>
  To search for non-ASCII characters, you must use an input method
(see section <A HREF="emacs_20.html#SEC217">Q.4 Input Methods</A>).  If an input method is enabled in the
current buffer when you start the search, you can use it while you
type the search string also.  Emacs indicates that by including the
input method mnemonic in its prompt, like this:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>I-search [<VAR>im</VAR>]:
</pre></td></tr></table></P><P>

<A NAME="IDX441"></A>
<A NAME="IDX442"></A>
where <VAR>im</VAR> is the mnemonic of the active input method.  You can
toggle (enable or disable) the input method while you type the search
string with <KBD>C-\</KBD> (<CODE>isearch-toggle-input-method</CODE>).  You can
turn on a certain (non-default) input method with <KBD>C-^</KBD>
(<CODE>isearch-toggle-specified-input-method</CODE>), which prompts for the
name of the input method.  The input method you enable during
incremental search remains enabled in the current buffer afterwards.
</P><P>

  If a search is failing and you ask to repeat it by typing another
<KBD>C-s</KBD>, it starts again from the beginning of the buffer.
Repeating a failing reverse search with <KBD>C-r</KBD> starts again from
the end.  This is called <EM>wrapping around</EM>, and <SAMP>`Wrapped'</SAMP>
appears in the search prompt once this has happened.  If you keep on
going past the original starting point of the search, it changes to
<SAMP>`Overwrapped'</SAMP>, which means that you are revisiting matches that
you have already seen.
</P><P>

<A NAME="IDX443"></A>
  The <KBD>C-g</KBD> "quit" character does special things during searches;
just what it does depends on the status of the search.  If the search has
found what you specified and is waiting for input, <KBD>C-g</KBD> cancels the
entire search.  The cursor moves back to where you started the search.  If
<KBD>C-g</KBD> is typed when there are characters in the search string that have
not been found--because Emacs is still searching for them, or because it
has failed to find them--then the search string characters which have not
been found are discarded from the search string.  With them gone, the
search is now successful and waiting for more input, so a second <KBD>C-g</KBD>
will cancel the entire search.
</P><P>

  You can change to searching backwards with <KBD>C-r</KBD>.  If a search fails
because the place you started was too late in the file, you should do this.
Repeated <KBD>C-r</KBD> keeps looking for more occurrences backwards.  A
<KBD>C-s</KBD> starts going forwards again.  <KBD>C-r</KBD> in a search can be canceled
with <KBD>DEL</KBD>.
</P><P>

<A NAME="IDX444"></A>
<A NAME="IDX445"></A>
  If you know initially that you want to search backwards, you can use
<KBD>C-r</KBD> instead of <KBD>C-s</KBD> to start the search, because <KBD>C-r</KBD> as
a key runs a command (<CODE>isearch-backward</CODE>) to search backward.  A
backward search finds matches that are entirely before the starting
point, just as a forward search finds matches that begin after it.
</P><P>

  The characters <KBD>C-y</KBD> and <KBD>C-w</KBD> can be used in incremental
search to grab text from the buffer into the search string.  This makes
it convenient to search for another occurrence of text at point.
<KBD>C-w</KBD> copies the word after point as part of the search string,
advancing point over that word.  Another <KBD>C-s</KBD> to repeat the search
will then search for a string including that word.  <KBD>C-y</KBD> is similar
to <KBD>C-w</KBD> but copies all the rest of the current line into the search
string.  Both <KBD>C-y</KBD> and <KBD>C-w</KBD> convert the text they copy to
lower case if the search is currently not case-sensitive; this is so the
search remains case-insensitive.
</P><P>

  The character <KBD>M-y</KBD> copies text from the kill ring into the search
string.  It uses the same text that <KBD>C-y</KBD> as a command would yank.
<KBD>Mouse-2</KBD> in the echo area does the same.
See section <A HREF="emacs_11.html#SEC63">H.8 Yanking</A>.
</P><P>

  When you exit the incremental search, it sets the mark to where point
<EM>was</EM>, before the search.  That is convenient for moving back
there.  In Transient Mark mode, incremental search sets the mark without
activating it, and does so only if the mark is not already active.
</P><P>

<A NAME="IDX446"></A>
<A NAME="IDX447"></A>
  When you pause for a little while during incremental search, it
highlights all other possible matches for the search string.  This
makes it easier to anticipate where you can get to by typing <KBD>C-s</KBD>
or <KBD>C-r</KBD> to repeat the search.  The short delay before highlighting
other matches helps indicate which match is the current one.
If you don't like this feature, you can turn it off by setting
<CODE>isearch-lazy-highlight</CODE> to <CODE>nil</CODE>.
</P><P>

<A NAME="IDX448"></A>
<A NAME="IDX449"></A>
  You can control how this highlighting looks by customizing the faces
<CODE>isearch</CODE> (used for the current match) and
<CODE>isearch-lazy-highlight-face</CODE> (for all the other matches).
</P><P>

<A NAME="IDX450"></A>
  To customize the special characters that incremental search understands,
alter their bindings in the keymap <CODE>isearch-mode-map</CODE>.  For a list
of bindings, look at the documentation of <CODE>isearch-mode</CODE> with
<KBD>C-h f isearch-mode <KBD>RET</KBD></KBD>.
</P><P>

<HR SIZE="6">
<A NAME="SEC93"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC92"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC94"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC91"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC91"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_15.html#SEC105"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> K.1.1 Slow Terminal Incremental Search </H3>
<!--docid::SEC93::-->
<P>

  Incremental search on a slow terminal uses a modified style of display
that is designed to take less time.  Instead of redisplaying the buffer at
each place the search gets to, it creates a new single-line window and uses
that to display the line that the search has found.  The single-line window
comes into play as soon as point moves outside of the text that is already
on the screen.
</P><P>

  When you terminate the search, the single-line window is removed.
Emacs then redisplays the window in which the search was done, to show
its new position of point.
</P><P>

<A NAME="IDX451"></A>
  The slow terminal style of display is used when the terminal baud rate is
less than or equal to the value of the variable <CODE>search-slow-speed</CODE>,
initially 1200.  See <CODE>baud-rate</CODE> in <A HREF="emacs_13.html#SEC89">J.12 Customization of Display</A>.
</P><P>

<A NAME="IDX452"></A>
  The number of lines to use in slow terminal search display is controlled
by the variable <CODE>search-slow-window-lines</CODE>.  Its normal value is 1.
</P><P>

<A NAME="Nonincremental Search"></A>
<HR SIZE="6">
<A NAME="SEC94"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC93"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC95"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC92"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC91"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_15.html#SEC105"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> K.2 Nonincremental Search </H2>
<!--docid::SEC94::-->
<P>

  Emacs also has conventional nonincremental search commands, which require
you to type the entire search string before searching begins.
</P><P>

<DL COMPACT>
<DT><KBD>C-s <KBD>RET</KBD> <VAR>string</VAR> <KBD>RET</KBD></KBD>
<DD>Search for <VAR>string</VAR>.
<DT><KBD>C-r <KBD>RET</KBD> <VAR>string</VAR> <KBD>RET</KBD></KBD>
<DD>Search backward for <VAR>string</VAR>.
</DL>
<P>

  To do a nonincremental search, first type <KBD>C-s <KBD>RET</KBD></KBD>.  This
enters the minibuffer to read the search string; terminate the string
with <KBD>RET</KBD>, and then the search takes place.  If the string is not
found, the search command signals an error.
</P><P>

  When you type <KBD>C-s <KBD>RET</KBD></KBD>, the <KBD>C-s</KBD> invokes incremental
search as usual.  That command is specially programmed to invoke
nonincremental search, <CODE>search-forward</CODE>, if the string you
specify is empty.  (Such an empty argument would otherwise be
useless.)  But it does not call <CODE>search-forward</CODE> right away.  First
it checks the next input character to see if is <KBD>C-w</KBD>,
which specifies a word search.
See section <A HREF="emacs_14.html#SEC95">K.3 Word Search</A>.
<KBD>C-r <KBD>RET</KBD></KBD> does likewise, for a reverse incremental search.
</P><P>

<A NAME="IDX453"></A>
<A NAME="IDX454"></A>
  Forward and backward nonincremental searches are implemented by the
commands <CODE>search-forward</CODE> and <CODE>search-backward</CODE>.  These
commands may be bound to keys in the usual manner.  The feature that you
can get to them via the incremental search commands exists for
historical reasons, and to avoid the need to find key sequences
for them.
</P><P>

<A NAME="Word Search"></A>
<HR SIZE="6">
<A NAME="SEC95"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC94"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC96"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC91"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC91"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_15.html#SEC105"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> K.3 Word Search </H2>
<!--docid::SEC95::-->
<P>

  Word search searches for a sequence of words without regard to how the
words are separated.  More precisely, you type a string of many words,
using single spaces to separate them, and the string can be found even
if there are multiple spaces, newlines, or other punctuation characters
between these words.
</P><P>

  Word search is useful for editing a printed document made with a text
formatter.  If you edit while looking at the printed, formatted version,
you can't tell where the line breaks are in the source file.  With word
search, you can search without having to know them.
</P><P>

<DL COMPACT>
<DT><KBD>C-s <KBD>RET</KBD> C-w <VAR>words</VAR> <KBD>RET</KBD></KBD>
<DD>Search for <VAR>words</VAR>, ignoring details of punctuation.
<DT><KBD>C-r <KBD>RET</KBD> C-w <VAR>words</VAR> <KBD>RET</KBD></KBD>
<DD>Search backward for <VAR>words</VAR>, ignoring details of punctuation.
</DL>
<P>

  Word search is a special case of nonincremental search and is invoked
with <KBD>C-s <KBD>RET</KBD> C-w</KBD>.  This is followed by the search string,
which must always be terminated with <KBD>RET</KBD>.  Being nonincremental,
this search does not start until the argument is terminated.  It works
by constructing a regular expression and searching for that; see
<A HREF="emacs_14.html#SEC96">K.4 Regular Expression Search</A>.
</P><P>

  Use <KBD>C-r <KBD>RET</KBD> C-w</KBD> to do backward word search.
</P><P>

<A NAME="IDX455"></A>
<A NAME="IDX456"></A>
  Forward and backward word searches are implemented by the commands
<CODE>word-search-forward</CODE> and <CODE>word-search-backward</CODE>.  These
commands may be bound to keys in the usual manner.  They are available
via the incremental search commands both for historical reasons and
to avoid the need to find suitable key sequences for them.
</P><P>

<A NAME="Regexp Search"></A>
<HR SIZE="6">
<A NAME="SEC96"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC95"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC97"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC91"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC91"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_15.html#SEC105"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> K.4 Regular Expression Search </H2>
<!--docid::SEC96::-->
<P>

  A <EM>regular expression</EM> (<EM>regexp</EM>, for short) is a pattern
that denotes a class of alternative strings to match, possibly
infinitely many.  GNU Emacs provides both incremental and
nonincremental ways to search for a match for a regexp.
</P><P>

<A NAME="IDX457"></A>
<A NAME="IDX458"></A>
<A NAME="IDX459"></A>
<A NAME="IDX460"></A>
  Incremental search for a regexp is done by typing <KBD>C-M-s</KBD>
(<CODE>isearch-forward-regexp</CODE>), or by invoking <KBD>C-s</KBD> with a
prefix argument (whose value does not matter).  This command reads a
search string incrementally just like <KBD>C-s</KBD>, but it treats the
search string as a regexp rather than looking for an exact match
against the text in the buffer.  Each time you add text to the search
string, you make the regexp longer, and the new regexp is searched
for.  To search backward for a regexp, use <KBD>C-M-r</KBD>
(<CODE>isearch-backward-regexp</CODE>), or <KBD>C-r</KBD> with a prefix argument.
</P><P>

  All of the control characters that do special things within an
ordinary incremental search have the same function in incremental regexp
search.  Typing <KBD>C-s</KBD> or <KBD>C-r</KBD> immediately after starting the
search retrieves the last incremental search regexp used; that is to
say, incremental regexp and non-regexp searches have independent
defaults.  They also have separate search rings that you can access with
<KBD>M-p</KBD> and <KBD>M-n</KBD>.
</P><P>

  If you type <KBD>SPC</KBD> in incremental regexp search, it matches any
sequence of whitespace characters, including newlines.  If you want
to match just a space, type <KBD>C-q <KBD>SPC</KBD></KBD>.
</P><P>

  Note that adding characters to the regexp in an incremental regexp
search can make the cursor move back and start again.  For example, if
you have searched for <SAMP>`foo'</SAMP> and you add <SAMP>`\|bar'</SAMP>, the cursor
backs up in case the first <SAMP>`bar'</SAMP> precedes the first <SAMP>`foo'</SAMP>.
</P><P>

<A NAME="IDX461"></A>
<A NAME="IDX462"></A>
  Nonincremental search for a regexp is done by the functions
<CODE>re-search-forward</CODE> and <CODE>re-search-backward</CODE>.  You can invoke
these with <KBD>M-x</KBD>, or bind them to keys, or invoke them by way of
incremental regexp search with <KBD>C-M-s <KBD>RET</KBD></KBD> and <KBD>C-M-r
<KBD>RET</KBD></KBD>.
</P><P>

  If you use the incremental regexp search commands with a prefix
argument, they perform ordinary string search, like
<CODE>isearch-forward</CODE> and <CODE>isearch-backward</CODE>.  See section <A HREF="emacs_14.html#SEC92">K.1 Incremental Search</A>.
</P><P>

<A NAME="Regexps"></A>
<HR SIZE="6">
<A NAME="SEC97"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC96"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC98"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC91"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC91"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_15.html#SEC105"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> K.5 Syntax of Regular Expressions </H2>
<!--docid::SEC97::-->
<P>

  Regular expressions have a syntax in which a few characters are
special constructs and the rest are <EM>ordinary</EM>.  An ordinary
character is a simple regular expression which matches that same
character and nothing else.  The special characters are <SAMP>`$'</SAMP>,
<SAMP>`^'</SAMP>, <SAMP>`.'</SAMP>, <SAMP>`*'</SAMP>, <SAMP>`+'</SAMP>, <SAMP>`?'</SAMP>, <SAMP>`['</SAMP>, <SAMP>`]'</SAMP> and
<SAMP>`\'</SAMP>.  Any other character appearing in a regular expression is
ordinary, unless a <SAMP>`\'</SAMP> precedes it.  (When you use regular
expressions in a Lisp program, each <SAMP>`\'</SAMP> must be doubled, see the
example near the end of this section.)
</P><P>

  For example, <SAMP>`f'</SAMP> is not a special character, so it is ordinary, and
therefore <SAMP>`f'</SAMP> is a regular expression that matches the string
<SAMP>`f'</SAMP> and no other string.  (It does <EM>not</EM> match the string
<SAMP>`ff'</SAMP>.)  Likewise, <SAMP>`o'</SAMP> is a regular expression that matches
only <SAMP>`o'</SAMP>.  (When case distinctions are being ignored, these regexps
also match <SAMP>`F'</SAMP> and <SAMP>`O'</SAMP>, but we consider this a generalization
of "the same string," rather than an exception.)
</P><P>

  Any two regular expressions <VAR>a</VAR> and <VAR>b</VAR> can be concatenated.  The
result is a regular expression which matches a string if <VAR>a</VAR> matches
some amount of the beginning of that string and <VAR>b</VAR> matches the rest of
the string.</P><P>

  As a simple example, we can concatenate the regular expressions <SAMP>`f'</SAMP>
and <SAMP>`o'</SAMP> to get the regular expression <SAMP>`fo'</SAMP>, which matches only
the string <SAMP>`fo'</SAMP>.  Still trivial.  To do something nontrivial, you
need to use one of the special characters.  Here is a list of them.
</P><P>

<DL COMPACT>
<DT><KBD>. (Period)</KBD>
<DD>is a special character that matches any single character except a newline.
Using concatenation, we can make regular expressions like <SAMP>`a.b'</SAMP>, which
matches any three-character string that begins with <SAMP>`a'</SAMP> and ends with
<SAMP>`b'</SAMP>.<P>

<DT><KBD>*</KBD>
<DD>is not a construct by itself; it is a postfix operator that means to
match the preceding regular expression repetitively as many times as
possible.  Thus, <SAMP>`o*'</SAMP> matches any number of <SAMP>`o'</SAMP>s (including no
<SAMP>`o'</SAMP>s).
<P>

<SAMP>`*'</SAMP> always applies to the <EM>smallest</EM> possible preceding
expression.  Thus, <SAMP>`fo*'</SAMP> has a repeating <SAMP>`o'</SAMP>, not a repeating
<SAMP>`fo'</SAMP>.  It matches <SAMP>`f'</SAMP>, <SAMP>`fo'</SAMP>, <SAMP>`foo'</SAMP>, and so on.
</P><P>

The matcher processes a <SAMP>`*'</SAMP> construct by matching, immediately,
as many repetitions as can be found.  Then it continues with the rest
of the pattern.  If that fails, backtracking occurs, discarding some
of the matches of the <SAMP>`*'</SAMP>-modified construct in case that makes
it possible to match the rest of the pattern.  For example, in matching
<SAMP>`ca*ar'</SAMP> against the string <SAMP>`caaar'</SAMP>, the <SAMP>`a*'</SAMP> first
tries to match all three <SAMP>`a'</SAMP>s; but the rest of the pattern is
<SAMP>`ar'</SAMP> and there is only <SAMP>`r'</SAMP> left to match, so this try fails.
The next alternative is for <SAMP>`a*'</SAMP> to match only two <SAMP>`a'</SAMP>s.
With this choice, the rest of the regexp matches successfully.</P><P>

<DT><KBD>+</KBD>
<DD>is a postfix operator, similar to <SAMP>`*'</SAMP> except that it must match
the preceding expression at least once.  So, for example, <SAMP>`ca+r'</SAMP>
matches the strings <SAMP>`car'</SAMP> and <SAMP>`caaaar'</SAMP> but not the string
<SAMP>`cr'</SAMP>, whereas <SAMP>`ca*r'</SAMP> matches all three strings.
<P>

<DT><KBD>?</KBD>
<DD>is a postfix operator, similar to <SAMP>`*'</SAMP> except that it can match the
preceding expression either once or not at all.  For example,
<SAMP>`ca?r'</SAMP> matches <SAMP>`car'</SAMP> or <SAMP>`cr'</SAMP>; nothing else.
<P>

<DT><KBD>*?, +?, ??</KBD>
<DD><A NAME="IDX463"></A>
are non-greedy variants of the operators above.  The normal operators
<SAMP>`*'</SAMP>, <SAMP>`+'</SAMP>, <SAMP>`?'</SAMP> are <EM>greedy</EM> in that they match as
much as they can, as long as the overall regexp can still match.  With
a following <SAMP>`?'</SAMP>, they are non-greedy: they will match as little
as possible.
<P>

Thus, both <SAMP>`ab*'</SAMP> and <SAMP>`ab*?'</SAMP> can match the string <SAMP>`a'</SAMP>
and the string <SAMP>`abbbb'</SAMP>; but if you try to match them both against
the text <SAMP>`abbb'</SAMP>, <SAMP>`ab*'</SAMP> will match it all (the longest valid
match), while <SAMP>`ab*?'</SAMP>  will match just <SAMP>`a'</SAMP> (the shortest
valid match).
</P><P>

<DT><KBD>\{<VAR>n</VAR>\}</KBD>
<DD>is a postfix operator that specifies repetition <VAR>n</VAR> times--that
is, the preceding regular expression must match exactly <VAR>n</VAR> times
in a row.  For example, <SAMP>`x\{4\}'</SAMP> matches the string <SAMP>`xxxx'</SAMP>
and nothing else.
<P>

<DT><KBD>\{<VAR>n</VAR>,<VAR>m</VAR>\}</KBD>
<DD>is a postfix operator that specifies repetition between <VAR>n</VAR> and
<VAR>m</VAR> times--that is, the preceding regular expression must match
at least <VAR>n</VAR> times, but no more than <VAR>m</VAR> times.  If <VAR>m</VAR> is
omitted, then there is no upper limit, but the preceding regular
expression must match at least <VAR>n</VAR> times.<BR> <SAMP>`\{0,1\}'</SAMP> is
equivalent to <SAMP>`?'</SAMP>. <BR> <SAMP>`\{0,\}'</SAMP> is equivalent to
<SAMP>`*'</SAMP>. <BR> <SAMP>`\{1,\}'</SAMP> is equivalent to <SAMP>`+'</SAMP>.
<P>

<DT><KBD>[ <small>...</small> ]</KBD>
<DD>is a <EM>character set</EM>, which begins with <SAMP>`['</SAMP> and is terminated
by <SAMP>`]'</SAMP>.  In the simplest case, the characters between the two
brackets are what this set can match.
<P>

Thus, <SAMP>`[ad]'</SAMP> matches either one <SAMP>`a'</SAMP> or one <SAMP>`d'</SAMP>, and
<SAMP>`[ad]*'</SAMP> matches any string composed of just <SAMP>`a'</SAMP>s and <SAMP>`d'</SAMP>s
(including the empty string), from which it follows that <SAMP>`c[ad]*r'</SAMP>
matches <SAMP>`cr'</SAMP>, <SAMP>`car'</SAMP>, <SAMP>`cdr'</SAMP>, <SAMP>`caddaar'</SAMP>, etc.
</P><P>

You can also include character ranges in a character set, by writing the
starting and ending characters with a <SAMP>`-'</SAMP> between them.  Thus,
<SAMP>`[a-z]'</SAMP> matches any lower-case ASCII letter.  Ranges may be
intermixed freely with individual characters, as in <SAMP>`[a-z$%.]'</SAMP>,
which matches any lower-case ASCII letter or <SAMP>`$'</SAMP>, <SAMP>`%'</SAMP> or
period.
</P><P>

Note that the usual regexp special characters are not special inside a
character set.  A completely different set of special characters exists
inside character sets: <SAMP>`]'</SAMP>, <SAMP>`-'</SAMP> and <SAMP>`^'</SAMP>.
</P><P>

To include a <SAMP>`]'</SAMP> in a character set, you must make it the first
character.  For example, <SAMP>`[]a]'</SAMP> matches <SAMP>`]'</SAMP> or <SAMP>`a'</SAMP>.  To
include a <SAMP>`-'</SAMP>, write <SAMP>`-'</SAMP> as the first or last character of the
set, or put it after a range.  Thus, <SAMP>`[]-]'</SAMP> matches both <SAMP>`]'</SAMP>
and <SAMP>`-'</SAMP>.
</P><P>

To include <SAMP>`^'</SAMP> in a set, put it anywhere but at the beginning of
the set.  (At the beginning, it complements the set--see below.)
</P><P>

When you use a range in case-insensitive search, you should write both
ends of the range in upper case, or both in lower case, or both should
be non-letters.  The behavior of a mixed-case range such as <SAMP>`A-z'</SAMP>
is somewhat ill-defined, and it may change in future Emacs versions.
</P><P>

<DT><KBD>[^ <small>...</small> ]</KBD>
<DD><SAMP>`[^'</SAMP> begins a <EM>complemented character set</EM>, which matches any
character except the ones specified.  Thus, <SAMP>`[^a-z0-9A-Z]'</SAMP> matches
all characters <EM>except</EM> ASCII letters and digits.
<P>

<SAMP>`^'</SAMP> is not special in a character set unless it is the first
character.  The character following the <SAMP>`^'</SAMP> is treated as if it
were first (in other words, <SAMP>`-'</SAMP> and <SAMP>`]'</SAMP> are not special there).
</P><P>

A complemented character set can match a newline, unless newline is
mentioned as one of the characters not to match.  This is in contrast to
the handling of regexps in programs such as <CODE>grep</CODE>.
</P><P>

<DT><KBD>^</KBD>
<DD>is a special character that matches the empty string, but only at the
beginning of a line in the text being matched.  Otherwise it fails to
match anything.  Thus, <SAMP>`^foo'</SAMP> matches a <SAMP>`foo'</SAMP> that occurs at
the beginning of a line.
<P>

<DT><KBD>$</KBD>
<DD>is similar to <SAMP>`^'</SAMP> but matches only at the end of a line.  Thus,
<SAMP>`x+$'</SAMP> matches a string of one <SAMP>`x'</SAMP> or more at the end of a line.
<P>

<DT><KBD>\</KBD>
<DD>has two functions: it quotes the special characters (including
<SAMP>`\'</SAMP>), and it introduces additional special constructs.
<P>

Because <SAMP>`\'</SAMP> quotes special characters, <SAMP>`\$'</SAMP> is a regular
expression that matches only <SAMP>`$'</SAMP>, and <SAMP>`\['</SAMP> is a regular
expression that matches only <SAMP>`['</SAMP>, and so on.
</DL>
<P>

Note: for historical compatibility, special characters are treated as
ordinary ones if they are in contexts where their special meanings make no
sense.  For example, <SAMP>`*foo'</SAMP> treats <SAMP>`*'</SAMP> as ordinary since there is
no preceding expression on which the <SAMP>`*'</SAMP> can act.  It is poor practice
to depend on this behavior; it is better to quote the special character anyway,
regardless of where it appears.</P><P>

For the most part, <SAMP>`\'</SAMP> followed by any character matches only that
character.  However, there are several exceptions: two-character
sequences starting with <SAMP>`\'</SAMP> that have special meanings.  The second
character in the sequence is always an ordinary character when used on
its own.  Here is a table of <SAMP>`\'</SAMP> constructs.
</P><P>

<DL COMPACT>
<DT><KBD>\|</KBD>
<DD>specifies an alternative.  Two regular expressions <VAR>a</VAR> and <VAR>b</VAR>
with <SAMP>`\|'</SAMP> in between form an expression that matches some text if
either <VAR>a</VAR> matches it or <VAR>b</VAR> matches it.  It works by trying to
match <VAR>a</VAR>, and if that fails, by trying to match <VAR>b</VAR>.
<P>

Thus, <SAMP>`foo\|bar'</SAMP> matches either <SAMP>`foo'</SAMP> or <SAMP>`bar'</SAMP>
but no other string.</P><P>

<SAMP>`\|'</SAMP> applies to the largest possible surrounding expressions.  Only a
surrounding <SAMP>`\( <small>...</small> \)'</SAMP> grouping can limit the grouping power of
<SAMP>`\|'</SAMP>.</P><P>

Full backtracking capability exists to handle multiple uses of <SAMP>`\|'</SAMP>.
</P><P>

<DT><KBD>\( <small>...</small> \)</KBD>
<DD>is a grouping construct that serves three purposes:
<P>

<OL>
<LI>
To enclose a set of <SAMP>`\|'</SAMP> alternatives for other operations.
Thus, <SAMP>`\(foo\|bar\)x'</SAMP> matches either <SAMP>`foox'</SAMP> or <SAMP>`barx'</SAMP>.
<P>

<LI>
To enclose a complicated expression for the postfix operators <SAMP>`*'</SAMP>,
<SAMP>`+'</SAMP> and <SAMP>`?'</SAMP> to operate on.  Thus, <SAMP>`ba\(na\)*'</SAMP> matches
<SAMP>`bananana'</SAMP>, etc., with any (zero or more) number of <SAMP>`na'</SAMP>
strings.<P>

<LI>
To record a matched substring for future reference.
</OL>
<P>

This last application is not a consequence of the idea of a
parenthetical grouping; it is a separate feature that is assigned as a
second meaning to the same <SAMP>`\( <small>...</small> \)'</SAMP> construct.  In practice
there is usually no conflict between the two meanings; when there is
a conflict, you can use a "shy" group.
</P><P>

<DT><KBD>\(?: <small>...</small> \)</KBD>
<DD><A NAME="IDX464"></A>
specifies a "shy" group that does not record the matched substring;
you can't refer back to it with <SAMP>`\<VAR>d</VAR>'</SAMP>.  This is useful
in mechanically combining regular expressions, so that you
can add groups for syntactic purposes without interfering with
the numbering of the groups that were written by the user.
<P>

<DT><KBD>\<VAR>d</VAR></KBD>
<DD>matches the same text that matched the <VAR>d</VAR>th occurrence of a
<SAMP>`\( <small>...</small> \)'</SAMP> construct.
<P>

After the end of a <SAMP>`\( <small>...</small> \)'</SAMP> construct, the matcher remembers
the beginning and end of the text matched by that construct.  Then,
later on in the regular expression, you can use <SAMP>`\'</SAMP> followed by the
digit <VAR>d</VAR> to mean "match the same text matched the <VAR>d</VAR>th time
by the <SAMP>`\( <small>...</small> \)'</SAMP> construct."
</P><P>

The strings matching the first nine <SAMP>`\( <small>...</small> \)'</SAMP> constructs
appearing in a regular expression are assigned numbers 1 through 9 in
the order that the open-parentheses appear in the regular expression.
So you can use <SAMP>`\1'</SAMP> through <SAMP>`\9'</SAMP> to refer to the text matched
by the corresponding <SAMP>`\( <small>...</small> \)'</SAMP> constructs.
</P><P>

For example, <SAMP>`\(.*\)\1'</SAMP> matches any newline-free string that is
composed of two identical halves.  The <SAMP>`\(.*\)'</SAMP> matches the first
half, which may be anything, but the <SAMP>`\1'</SAMP> that follows must match
the same exact text.
</P><P>

If a particular <SAMP>`\( <small>...</small> \)'</SAMP> construct matches more than once
(which can easily happen if it is followed by <SAMP>`*'</SAMP>), only the last
match is recorded.
</P><P>

<DT><KBD>\`</KBD>
<DD>matches the empty string, but only at the beginning
of the buffer or string being matched against.
<P>

<DT><KBD>\'</KBD>
<DD>matches the empty string, but only at the end of
the buffer or string being matched against.
<P>

<DT><KBD>\=</KBD>
<DD>matches the empty string, but only at point.
<P>

<DT><KBD>\b</KBD>
<DD>matches the empty string, but only at the beginning or
end of a word.  Thus, <SAMP>`\bfoo\b'</SAMP> matches any occurrence of
<SAMP>`foo'</SAMP> as a separate word.  <SAMP>`\bballs?\b'</SAMP> matches
<SAMP>`ball'</SAMP> or <SAMP>`balls'</SAMP> as a separate word.<P>

<SAMP>`\b'</SAMP> matches at the beginning or end of the buffer
regardless of what text appears next to it.
</P><P>

<DT><KBD>\B</KBD>
<DD>matches the empty string, but <EM>not</EM> at the beginning or
end of a word.
<P>

<DT><KBD>\&#60;</KBD>
<DD>matches the empty string, but only at the beginning of a word.
<SAMP>`\&#60;'</SAMP> matches at the beginning of the buffer only if a
word-constituent character follows.
<P>

<DT><KBD>\&#62;</KBD>
<DD>matches the empty string, but only at the end of a word.  <SAMP>`\&#62;'</SAMP>
matches at the end of the buffer only if the contents end with a
word-constituent character.
<P>

<DT><KBD>\w</KBD>
<DD>matches any word-constituent character.  The syntax table
determines which characters these are.  See section <A HREF="emacs_33.html#SEC504">AD.6 The Syntax Table</A>.
<P>

<DT><KBD>\W</KBD>
<DD>matches any character that is not a word-constituent.
<P>

<DT><KBD>\s<VAR>c</VAR></KBD>
<DD>matches any character whose syntax is <VAR>c</VAR>.  Here <VAR>c</VAR> is a
character that designates a particular syntax class: thus, <SAMP>`w'</SAMP>
for word constituent, <SAMP>`-'</SAMP> or <SAMP>` '</SAMP> for whitespace, <SAMP>`.'</SAMP>
for ordinary punctuation, etc.  See section <A HREF="emacs_33.html#SEC504">AD.6 The Syntax Table</A>.
<P>

<DT><KBD>\S<VAR>c</VAR></KBD>
<DD>matches any character whose syntax is not <VAR>c</VAR>.
<P>

<A NAME="IDX465"></A>
<A NAME="IDX466"></A>
<A NAME="IDX467"></A>
<DT><KBD>\c<VAR>c</VAR></KBD>
<DD>matches any character that belongs to the category <VAR>c</VAR>.  For
example, <SAMP>`\cc'</SAMP> matches Chinese characters, <SAMP>`\cg'</SAMP> matches
Greek characters, etc.  For the description of the known categories,
type <KBD>M-x describe-categories <KBD>RET</KBD></KBD>.
<P>

<DT><KBD>\C<VAR>c</VAR></KBD>
<DD>matches any character that does <EM>not</EM> belong to category
<VAR>c</VAR>.
</DL>
<P>

  The constructs that pertain to words and syntax are controlled by the
setting of the syntax table (see section <A HREF="emacs_33.html#SEC504">AD.6 The Syntax Table</A>).
</P><P>

  Here is a complicated regexp, stored in <CODE>sentence-end</CODE> and used
by Emacs to recognize the end of a sentence together with any
whitespace that follows.  We show its Lisp syntax to distinguish the
spaces from the tab characters.  In Lisp syntax, the string constant
begins and ends with a double-quote.  <SAMP>`\"'</SAMP> stands for a
double-quote as part of the regexp, <SAMP>`\\'</SAMP> for a backslash as part
of the regexp, <SAMP>`\t'</SAMP> for a tab, and <SAMP>`\n'</SAMP> for a newline.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>"[.?!][]\"')]*\\($\\| $\\|\t\\|  \\)[ \t\n]*"
</pre></td></tr></table></P><P>

This contains four parts in succession: a character set matching
period, <SAMP>`?'</SAMP>, or <SAMP>`!'</SAMP>; a character set matching
close-brackets, quotes, or parentheses, repeated zero or more times; a
set of alternatives within backslash-parentheses that matches either
end-of-line, a space at the end of a line, a tab, or two spaces; and a
character set matching whitespace characters, repeated any number of
times.
</P><P>

  To enter the same regexp interactively, you would type <KBD>TAB</KBD> to
enter a tab, and <KBD>C-j</KBD> to enter a newline.  (When typed
interactively, <KBD>C-j</KBD> should be preceded by a <KBD>C-q</KBD>, to prevent
Emacs from running the command bound to a newline.)  You would also type
single backslashes as themselves, instead of doubling them for Lisp
syntax.
</P><P>

<A NAME="Search Case"></A>
<HR SIZE="6">
<A NAME="SEC98"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC97"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC99"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC91"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC91"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_15.html#SEC105"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> K.6 Searching and Case </H2>
<!--docid::SEC98::-->
<P>

  Incremental searches in Emacs normally ignore the case of the text
they are searching through, if you specify the text in lower case.
Thus, if you specify searching for <SAMP>`foo'</SAMP>, then <SAMP>`Foo'</SAMP> and
<SAMP>`foo'</SAMP> are also considered a match.  Regexps, and in particular
character sets, are included: <SAMP>`[ab]'</SAMP> would match <SAMP>`a'</SAMP> or
<SAMP>`A'</SAMP> or <SAMP>`b'</SAMP> or <SAMP>`B'</SAMP>.</P><P>

  An upper-case letter anywhere in the incremental search string makes
the search case-sensitive.  Thus, searching for <SAMP>`Foo'</SAMP> does not find
<SAMP>`foo'</SAMP> or <SAMP>`FOO'</SAMP>.  This applies to regular expression search as
well as to string search.  The effect ceases if you delete the
upper-case letter from the search string.
</P><P>

  Typing <KBD>M-c</KBD> within an incremental search toggles the case
sensitivity of that search.  The effect does not extend beyond the
current incremental search to the next one, but it does override the
effect of including an upper-case letter in the current search.
</P><P>

<A NAME="IDX468"></A>
  If you set the variable <CODE>case-fold-search</CODE> to <CODE>nil</CODE>, then
all letters must match exactly, including case.  This is a per-buffer
variable; altering the variable affects only the current buffer, but
there is a default value which you can change as well.  See section <A HREF="emacs_33.html#SEC485">AD.2.4 Local Variables</A>.
This variable applies to nonincremental searches also, including those
performed by the replace commands (see section <A HREF="emacs_14.html#SEC99">K.7 Replacement Commands</A>) and the minibuffer
history matching commands (see section <A HREF="emacs_8.html#SEC39">E.4 Minibuffer History</A>).
</P><P>

<A NAME="Replace"></A>
<HR SIZE="6">
<A NAME="SEC99"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC98"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC100"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC91"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC91"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC104"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> K.7 Replacement Commands </H2>
<!--docid::SEC99::-->
<P>

  Global search-and-replace operations are not needed often in Emacs,
but they are available.  In addition to the simple <KBD>M-x
replace-string</KBD> command which is like that found in most editors,
there is a <KBD>M-x query-replace</KBD> command which finds each occurrence
of the pattern and asks you whether to replace it.
</P><P>

  The replace commands normally operate on the text from point to the
end of the buffer; however, in Transient Mark mode, when the mark is
active, they operate on the region.  The replace commands all replace
one string (or regexp) with one replacement string.  It is possible to
perform several replacements in parallel using the command
<CODE>expand-region-abbrevs</CODE> (see section <A HREF="emacs_27.html#SEC353">X.3 Controlling Abbrev Expansion</A>).
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="emacs_14.html#SEC100">K.7.1 Unconditional Replacement</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Replacing all matches for a string.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="emacs_14.html#SEC101">K.7.2 Regexp Replacement</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">Replacing all matches for a regexp.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="emacs_14.html#SEC102">K.7.3 Replace Commands and Case</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">How replacements preserve case of letters.</TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="emacs_14.html#SEC103">K.7.4 Query Replace</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP">How to use querying.</TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Unconditional Replace"></A>
<HR SIZE="6">
<A NAME="SEC100"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC99"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC101"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC98"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC99"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC104"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> K.7.1 Unconditional Replacement </H3>
<!--docid::SEC100::-->
<P>

<DL COMPACT>
<DT><KBD>M-x replace-string <KBD>RET</KBD> <VAR>string</VAR> <KBD>RET</KBD> <VAR>newstring</VAR> <KBD>RET</KBD></KBD>
<DD>Replace every occurrence of <VAR>string</VAR> with <VAR>newstring</VAR>.
<DT><KBD>M-x replace-regexp <KBD>RET</KBD> <VAR>regexp</VAR> <KBD>RET</KBD> <VAR>newstring</VAR> <KBD>RET</KBD></KBD>
<DD>Replace every match for <VAR>regexp</VAR> with <VAR>newstring</VAR>.
</DL>
<P>

  To replace every instance of <SAMP>`foo'</SAMP> after point with <SAMP>`bar'</SAMP>,
use the command <KBD>M-x replace-string</KBD> with the two arguments
<SAMP>`foo'</SAMP> and <SAMP>`bar'</SAMP>.  Replacement happens only in the text after
point, so if you want to cover the whole buffer you must go to the
beginning first.  All occurrences up to the end of the buffer are
replaced; to limit replacement to part of the buffer, narrow to that
part of the buffer before doing the replacement (see section <A HREF="emacs_32.html#SEC462">AC.22 Narrowing</A>).
In Transient Mark mode, when the region is active, replacement is
limited to the region (see section <A HREF="emacs_11.html#SEC54">H.2 Transient Mark Mode</A>).
</P><P>

  When <CODE>replace-string</CODE> exits, it leaves point at the last
occurrence replaced.  It sets the mark to the prior position of point
(where the <CODE>replace-string</CODE> command was issued); use <KBD>C-u
C-<KBD>SPC</KBD></KBD> to move back there.
</P><P>

  A numeric argument restricts replacement to matches that are surrounded
by word boundaries.  The argument's value doesn't matter.
</P><P>

<A NAME="Regexp Replace"></A>
<HR SIZE="6">
<A NAME="SEC101"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC100"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC102"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC98"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC99"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC104"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> K.7.2 Regexp Replacement </H3>
<!--docid::SEC101::-->
<P>

  The <KBD>M-x replace-string</KBD> command replaces exact matches for a
single string.  The similar command <KBD>M-x replace-regexp</KBD> replaces
any match for a specified pattern.
</P><P>

  In <CODE>replace-regexp</CODE>, the <VAR>newstring</VAR> need not be constant: it
can refer to all or part of what is matched by the <VAR>regexp</VAR>.
<SAMP>`\&#38;'</SAMP> in <VAR>newstring</VAR> stands for the entire match being replaced.
<SAMP>`\<VAR>d</VAR>'</SAMP> in <VAR>newstring</VAR>, where <VAR>d</VAR> is a digit, stands for
whatever matched the <VAR>d</VAR>th parenthesized grouping in <VAR>regexp</VAR>.
To include a <SAMP>`\'</SAMP> in the text to replace with, you must enter
<SAMP>`\\'</SAMP>.  For example,
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>M-x replace-regexp <KBD>RET</KBD> c[ad]+r <KBD>RET</KBD> \&#38;-safe <KBD>RET</KBD>
</pre></td></tr></table></P><P>

replaces (for example) <SAMP>`cadr'</SAMP> with <SAMP>`cadr-safe'</SAMP> and <SAMP>`cddr'</SAMP>
with <SAMP>`cddr-safe'</SAMP>.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>M-x replace-regexp <KBD>RET</KBD> \(c[ad]+r\)-safe <KBD>RET</KBD> \1 <KBD>RET</KBD>
</pre></td></tr></table></P><P>

performs the inverse transformation.
</P><P>

<A NAME="Replacement and Case"></A>
<HR SIZE="6">
<A NAME="SEC102"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC101"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC103"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC98"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC99"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC104"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> K.7.3 Replace Commands and Case </H3>
<!--docid::SEC102::-->
<P>

  If the first argument of a replace command is all lower case, the
command ignores case while searching for occurrences to
replace--provided <CODE>case-fold-search</CODE> is non-<CODE>nil</CODE>.  If
<CODE>case-fold-search</CODE> is set to <CODE>nil</CODE>, case is always significant
in all searches.
</P><P>

<A NAME="IDX469"></A>
  In addition, when the <VAR>newstring</VAR> argument is all or partly lower
case, replacement commands try to preserve the case pattern of each
occurrence.  Thus, the command
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>M-x replace-string <KBD>RET</KBD> foo <KBD>RET</KBD> bar <KBD>RET</KBD>
</pre></td></tr></table></P><P>

replaces a lower case <SAMP>`foo'</SAMP> with a lower case <SAMP>`bar'</SAMP>, an
all-caps <SAMP>`FOO'</SAMP> with <SAMP>`BAR'</SAMP>, and a capitalized <SAMP>`Foo'</SAMP> with
<SAMP>`Bar'</SAMP>.  (These three alternatives--lower case, all caps, and
capitalized, are the only ones that <CODE>replace-string</CODE> can
distinguish.)
</P><P>

  If upper-case letters are used in the replacement string, they remain
upper case every time that text is inserted.  If upper-case letters are
used in the first argument, the second argument is always substituted
exactly as given, with no case conversion.  Likewise, if either
<CODE>case-replace</CODE> or <CODE>case-fold-search</CODE> is set to <CODE>nil</CODE>,
replacement is done without case conversion.
</P><P>

<A NAME="Query Replace"></A>
<HR SIZE="6">
<A NAME="SEC103"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC102"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC104"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC98"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC99"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC104"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> K.7.4 Query Replace </H3>
<!--docid::SEC103::-->
<P>

<DL COMPACT>
<DT><KBD>M-% <VAR>string</VAR> <KBD>RET</KBD> <VAR>newstring</VAR> <KBD>RET</KBD></KBD>
<DD><DT><KBD>M-x query-replace <KBD>RET</KBD> <VAR>string</VAR> <KBD>RET</KBD> <VAR>newstring</VAR> <KBD>RET</KBD></KBD>
<DD>Replace some occurrences of <VAR>string</VAR> with <VAR>newstring</VAR>.
<DT><KBD>C-M-% <VAR>regexp</VAR> <KBD>RET</KBD> <VAR>newstring</VAR> <KBD>RET</KBD></KBD>
<DD><DT><KBD>M-x query-replace-regexp <KBD>RET</KBD> <VAR>regexp</VAR> <KBD>RET</KBD> <VAR>newstring</VAR> <KBD>RET</KBD></KBD>
<DD>Replace some matches for <VAR>regexp</VAR> with <VAR>newstring</VAR>.
</DL>
<P>

<A NAME="IDX470"></A>
<A NAME="IDX471"></A>
  If you want to change only some of the occurrences of <SAMP>`foo'</SAMP> to
<SAMP>`bar'</SAMP>, not all of them, then you cannot use an ordinary
<CODE>replace-string</CODE>.  Instead, use <KBD>M-%</KBD> (<CODE>query-replace</CODE>).
This command finds occurrences of <SAMP>`foo'</SAMP> one by one, displays each
occurrence and asks you whether to replace it.  Aside from querying,
<CODE>query-replace</CODE> works just like <CODE>replace-string</CODE>.  It
preserves case, like <CODE>replace-string</CODE>, provided
<CODE>case-replace</CODE> is non-<CODE>nil</CODE>, as it normally is.  A numeric
argument means consider only occurrences that are bounded by
word-delimiter characters.
</P><P>

<A NAME="IDX472"></A>
<A NAME="IDX473"></A>
  <KBD>C-M-%</KBD> performs regexp search and replace (<CODE>query-replace-regexp</CODE>).
</P><P>

  The characters you can type when you are shown a match for the string
or regexp are:
</P><P>

<DL COMPACT>
<DT><KBD><KBD>SPC</KBD></KBD>
<DD>to replace the occurrence with <VAR>newstring</VAR>.
<P>

<DT><KBD><KBD>DEL</KBD></KBD>
<DD>to skip to the next occurrence without replacing this one.
<P>

<DT><KBD>, (Comma)</KBD>
<DD>to replace this occurrence and display the result.  You are then asked
for another input character to say what to do next.  Since the
replacement has already been made, <KBD>DEL</KBD> and <KBD>SPC</KBD> are
equivalent in this situation; both move to the next occurrence.
<P>

You can type <KBD>C-r</KBD> at this point (see below) to alter the replaced
text.  You can also type <KBD>C-x u</KBD> to undo the replacement; this exits
the <CODE>query-replace</CODE>, so if you want to do further replacement you
must use <KBD>C-x <KBD>ESC</KBD> <KBD>ESC</KBD> <KBD>RET</KBD></KBD> to restart
(see section <A HREF="emacs_8.html#SEC40">E.5 Repeating Minibuffer Commands</A>).
</P><P>

<DT><KBD><KBD>RET</KBD></KBD>
<DD>to exit without doing any more replacements.
<P>

<DT><KBD>. (Period)</KBD>
<DD>to replace this occurrence and then exit without searching for more
occurrences.
<P>

<DT><KBD>!</KBD>
<DD>to replace all remaining occurrences without asking again.
<P>

<DT><KBD>^</KBD>
<DD>to go back to the position of the previous occurrence (or what used to
be an occurrence), in case you changed it by mistake.  This works by
popping the mark ring.  Only one <KBD>^</KBD> in a row is meaningful, because
only one previous replacement position is kept during <CODE>query-replace</CODE>.
<P>

<DT><KBD>C-r</KBD>
<DD>to enter a recursive editing level, in case the occurrence needs to be
edited rather than just replaced with <VAR>newstring</VAR>.  When you are
done, exit the recursive editing level with <KBD>C-M-c</KBD> to proceed to
the next occurrence.  See section <A HREF="emacs_32.html#SEC466">AC.26 Recursive Editing Levels</A>.
<P>

<DT><KBD>C-w</KBD>
<DD>to delete the occurrence, and then enter a recursive editing level as in
<KBD>C-r</KBD>.  Use the recursive edit to insert text to replace the deleted
occurrence of <VAR>string</VAR>.  When done, exit the recursive editing level
with <KBD>C-M-c</KBD> to proceed to the next occurrence.
<P>

<DT><KBD>e</KBD>
<DD>to edit the replacement string in the minibuffer.  When you exit the
minibuffer by typing <KBD>RET</KBD>, the minibuffer contents replace the
current occurrence of the pattern.  They also become the new
replacement string for any further occurrences.
<P>

<DT><KBD>C-l</KBD>
<DD>to redisplay the screen.  Then you must type another character to
specify what to do with this occurrence.
<P>

<DT><KBD>C-h</KBD>
<DD>to display a message summarizing these options.  Then you must type
another character to specify what to do with this occurrence.
</DL>
<P>

  Some other characters are aliases for the ones listed above: <KBD>y</KBD>,
<KBD>n</KBD> and <KBD>q</KBD> are equivalent to <KBD>SPC</KBD>, <KBD>DEL</KBD> and
<KBD>RET</KBD>.
</P><P>

  Aside from this, any other character exits the <CODE>query-replace</CODE>,
and is then reread as part of a key sequence.  Thus, if you type
<KBD>C-k</KBD>, it exits the <CODE>query-replace</CODE> and then kills to end of
line.
</P><P>

  To restart a <CODE>query-replace</CODE> once it is exited, use <KBD>C-x
<KBD>ESC</KBD> <KBD>ESC</KBD></KBD>, which repeats the <CODE>query-replace</CODE> because it
used the minibuffer to read its arguments.  See section <A HREF="emacs_8.html#SEC40">C-x ESC ESC</A>.
</P><P>

  See also <A HREF="emacs_31.html#SEC405">AB.9 Transforming File Names in Dired</A>, for Dired commands to rename,
copy, or link files by replacing regexp matches in file names.
</P><P>

<A NAME="Other Repeating Search"></A>
<HR SIZE="6">
<A NAME="SEC104"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC103"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_15.html#SEC105"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC99"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC91"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_15.html#SEC105"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> K.8 Other Search-and-Loop Commands </H2>
<!--docid::SEC104::-->
<P>

  Here are some other commands that find matches for a regular
expression.  They all ignore case in matching, if the pattern contains
no upper-case letters and <CODE>case-fold-search</CODE> is non-<CODE>nil</CODE>.
Aside from <CODE>occur</CODE>, all operate on the text from point to the end
of the buffer, or on the active region in Transient Mark mode.
</P><P>

<A NAME="IDX474"></A>
<A NAME="IDX475"></A>
<A NAME="IDX476"></A>
<A NAME="IDX477"></A>
<A NAME="IDX478"></A>
<A NAME="IDX479"></A>
<A NAME="IDX480"></A>
</P><P>

<DL COMPACT>
<DT><KBD>M-x occur <KBD>RET</KBD> <VAR>regexp</VAR> <KBD>RET</KBD></KBD>
<DD>Display a list showing each line in the buffer that contains a match
for <VAR>regexp</VAR>.  To limit the search to part of the buffer, narrow
to that part (see section <A HREF="emacs_32.html#SEC462">AC.22 Narrowing</A>).  A numeric argument <VAR>n</VAR>
specifies that <VAR>n</VAR> lines of context are to be displayed before and
after each matching line.
<P>

<A NAME="IDX481"></A>
The buffer <SAMP>`*Occur*'</SAMP> containing the output serves as a menu for
finding the occurrences in their original context.  Click <KBD>Mouse-2</KBD>
on an occurrence listed in <SAMP>`*Occur*'</SAMP>, or position point there and
type <KBD>RET</KBD>; this switches to the buffer that was searched and
moves point to the original of the chosen occurrence.
</P><P>

<DT><KBD>M-x list-matching-lines</KBD>
<DD>Synonym for <KBD>M-x occur</KBD>.
<P>

<DT><KBD>M-x how-many <KBD>RET</KBD> <VAR>regexp</VAR> <KBD>RET</KBD></KBD>
<DD>Print the number of matches for <VAR>regexp</VAR> that exist in the buffer
after point.  In Transient Mark mode, if the region is active, the
command operates on the region instead.
<P>

<DT><KBD>M-x flush-lines <KBD>RET</KBD> <VAR>regexp</VAR> <KBD>RET</KBD></KBD>
<DD>Delete each line that contains a match for <VAR>regexp</VAR>, operating on
the text after point.  In Transient Mark mode, if the region is
active, the command operates on the region instead.
<P>

<DT><KBD>M-x keep-lines <KBD>RET</KBD> <VAR>regexp</VAR> <KBD>RET</KBD></KBD>
<DD>Delete each line that <EM>does not</EM> contain a match for
<VAR>regexp</VAR>, operating on the text after point.  In Transient Mark
mode, if the region is active, the command operates on the region
instead.
</DL>
<P>

  You can also search multiple files under control of a tags table
(see section <A HREF="emacs_26.html#SEC340">W.2.6 Searching and Replacing with Tags Tables</A>) or through Dired <KBD>A</KBD> command
(see section <A HREF="emacs_31.html#SEC403">AB.7 Operating on Files</A>), or ask the <CODE>grep</CODE> program to do it
(see section <A HREF="emacs_25.html#SEC318">V.2 Searching with Grep under Emacs</A>).
<A NAME="Fixit"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_14.html#SEC99"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_15.html#SEC105"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[Index]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="emacs_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated
on <I>April 2, 2002</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
