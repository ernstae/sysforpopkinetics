<html><head>
<title>Optimizing The Map Bayesian Objective Function</title>
<meta name="description" id="description" content="Optimizing The Map Bayesian Objective Function">
<meta name="keywords" id="keywords" content=" map bayesian optimization mapopt individual ">
<style type='text/css'>
BODY { color : black }
BODY { background-color : white }
</style>
<script type='text/javascript' language='JavaScript' src='_mapopt_htm.js'>
</script>
</head>
<body>
<table><tr>
<td>
<a href="http://depts.washington.edu/rfpk" target="_top"><img border="0" src="_image.gif"></a>
</td>
<td>
<select onchange='choose_across0(this)'>
<option>Index-&gt;</option>
<option>contents</option>
<option>reference</option>
<option>index</option>
<option>search</option>
<option>external</option>
</select>
</td>
<td>
<select onchange='choose_up0(this)'>
<option>Up-&gt;</option>
<option>main</option>
<option>individual</option>
<option>mapOpt</option>
</select>
</td>
<td><a href="mapobjdiff.htm" target="_top">Prev</a>
</td><td><a href="maptilde.htm" target="_top">Next</a>
</td><td>
<select onchange='choose_down2(this)'>
<option>main-&gt;</option>
<option>Notes</option>
<option>SpkModel</option>
<option>individual</option>
<option>population</option>
<option>statistical</option>
<option>simulation</option>
<option>general</option>
<option>glossary</option>
</select>
</td>
<td>
<select onchange='choose_down1(this)'>
<option>individual-&gt;</option>
<option>fitIndividual</option>
<option>mapObj</option>
<option>mapObjFuncOb</option>
<option>mapObj_bFuncOb</option>
<option>mapObjDiff</option>
<option>mapOpt</option>
<option>mapTilde</option>
<option>indResiduals</option>
<option>indStatistics</option>
<option>indStatistics_Deprecated</option>
<option>indStatistics_AllElemActive_Deprecated</option>
</select>
</td>
<td>mapOpt</td>
<td>
<select onchange='choose_current0(this)'>
<option>Headings-&gt;</option>
<option>Description</option>
<option>Reference</option>
<option>Return Value</option>
<option>Note</option>
<option>Arguments</option>
<option>---..optInfo.epsilon</option>
<option>---..optInfo.nMaxIter</option>
<option>---..optInfo.traceLevel</option>
<option>---..optInfo.nIterCompleted</option>
<option>---..optInfo.isTooManyIter</option>
<option>---..optInfo.saveStateAtEndOfOpt</option>
<option>---..optInfo.throwExcepIfMaxIter</option>
<option>---..optInfo.isWarmStartPossible</option>
<option>---..optInfo.isWarmStart</option>
<option>---..optInfo.stateInfo</option>
<option>Example</option>
</select>
</td>
</tr></table><br>
<center><b><big><big>Optimizing The Map Bayesian Objective Function</big></big></b></center>
<table><tr><td align='left'  valign='top'>
<b>Prototype:</b> </td><td align='left'  valign='top'>

<code><font color="blue"><span style='white-space: nowrap'>void&nbsp;mapOpt(&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;SpkModel&lt;double&gt;&nbsp;&nbsp;&nbsp;&amp;&nbsp;</span></font></code><i><span style='white-space: nowrap'>model</span></i><code><font color="blue"><span style='white-space: nowrap'>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;DoubleMatrix&nbsp;&amp;&nbsp;</span></font></code><i><span style='white-space: nowrap'>dvecY</span></i><code><font color="blue"><span style='white-space: nowrap'>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;Optimizer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&nbsp;</span></font></code><i><span style='white-space: nowrap'>optInfo</span></i><code><font color="blue"><span style='white-space: nowrap'>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;DoubleMatrix&nbsp;&amp;&nbsp;</span></font></code><i><span style='white-space: nowrap'>dvecBLow</span></i><code><font color="blue"><span style='white-space: nowrap'>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;DoubleMatrix&nbsp;&amp;&nbsp;</span></font></code><i><span style='white-space: nowrap'>dvecBUp</span></i><code><font color="blue"><span style='white-space: nowrap'>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;DoubleMatrix&nbsp;&amp;&nbsp;</span></font></code><i><span style='white-space: nowrap'>dvecBIn</span></i><code><font color="blue"><span style='white-space: nowrap'>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;DoubleMatrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;</span></font></code><i><span style='white-space: nowrap'>pdvecBOut</span></i><code><font color="blue"><span style='white-space: nowrap'>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;DoubleMatrix&nbsp;&amp;&nbsp;</span></font></code><i><span style='white-space: nowrap'>dvecBStep</span></i><code><font color="blue"><span style='white-space: nowrap'>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;</span></font></code><i><span style='white-space: nowrap'>pdMapObjOut</span></i><code><font color="blue"><span style='white-space: nowrap'>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;DoubleMatrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;</span></font></code><i><span style='white-space: nowrap'>pdrowMapObj_bOut</span></i><code><font color="blue"><span style='white-space: nowrap'>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;DoubleMatrix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;</span></font></code><i><span style='white-space: nowrap'>pdmatMapObj_b_bOut</span></i><code><font color="blue"><span style='white-space: nowrap'>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></font></code><i><span style='white-space: nowrap'>withD</span></i><code><font color="blue"><span style='white-space: nowrap'>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></font></code><i><span style='white-space: nowrap'>isFo</span></i><code><font color="blue"><span style='white-space: nowrap'>&nbsp;=&nbsp;false,<br>
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;DoubleMatrix*&nbsp;</span></font></code><i><span style='white-space: nowrap'>pdvecN</span></i><code><font color="blue"><span style='white-space: nowrap'>&nbsp;=&nbsp;NULL,<br>
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;DoubleMatrix*&nbsp;</span></font></code><i><span style='white-space: nowrap'>pdvecBMean</span></i><code><font color="blue"><span style='white-space: nowrap'>&nbsp;=&nbsp;NULL<br>
)</span></font></code>

</td></tr>
</table>
<table><tr><td align='left'  valign='top'>
<b>See also: </b> </td><td align='left'  valign='top'>

<a href="optimizer.htm" target="_top">Optimizer Class</a>  </td></tr><tr><td align='left'  valign='top'>

</td><td align='left'  valign='top'>

<a href="mapobj.htm" target="_top">Map Bayesian Objective Function</a>     </td></tr><tr><td align='left'  valign='top'>

</td><td align='left'  valign='top'>

<a href="mapobjdiff.htm" target="_top">Central Differences of Map Bayesian Objective Function and its Derivatives</a> </td></tr><tr><td align='left'  valign='top'>

</td><td align='left'  valign='top'>

<a href="mapopt.htm" target="_top">Optimizing The Map Bayesian Objective Function</a>     </td></tr><tr><td align='left'  valign='top'>

</td></tr>
</table>
<br>
<center><i>Copyright (C) 2002, University of Washington, Resource Facility for Population Kinetics. All Rights Reserved.

</i>
</center><code><span style='white-space: nowrap'><br>
</span></code><b><big><a name="Description" id="Description">Description</a></big></b>
<br>
Minimizes the map Bayesian objective function.  
<code><span style='white-space: nowrap'><br>
<br>
</span></code>To be specific, this function solves the problem 
<code><span style='white-space: nowrap'><br>
&nbsp;&nbsp;&nbsp;&nbsp;minimize&nbsp;<i>MapObj</i>(<i>b</i>)&nbsp;with&nbsp;respect&nbsp;to&nbsp;<i>b</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;subject&nbsp;to&nbsp;<i>bLow</i>&nbsp;<u>&lt;</u>&nbsp;<i>b</i>&nbsp;<u>&lt;</u>&nbsp;<i>bUp</i><br>
</span></code>where the function <code><span style='white-space: nowrap'><i>MapObj</i>(<i>b</i>)</span></code> is defined by
<code><span style='white-space: nowrap'><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>T</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1<br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>MapObj</i>(<i>b</i>)&nbsp;=&nbsp;-&nbsp;logdet[&nbsp;2&nbsp;pi&nbsp;<i>R</i>(<i>b</i>)&nbsp;]&nbsp;+&nbsp;-&nbsp;[<i>y</i>&nbsp;-&nbsp;<i>f</i>(<i>b</i>)]&nbsp;&nbsp;<i>R</i>(<i>b</i>)&nbsp;&nbsp;&nbsp;[<i>y</i>&nbsp;-&nbsp;<i>f</i>(<i>b</i>)]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>T</i>&nbsp;&nbsp;-1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;-&nbsp;#<i>logdet</i>[&nbsp;2&nbsp;#<i>pi</i>&nbsp;<i>D</i>&nbsp;]&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;-&nbsp;[<i>bMean</i>&nbsp;-&nbsp;<i>b</i>]&nbsp;&nbsp;<i>D</i>&nbsp;&nbsp;[<i>bMean</i>&nbsp;-&nbsp;<i>b</i>]&nbsp;&nbsp;.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<br>
</span></code>Note that this objective function allows a nonzero mean value
<code><span style='white-space: nowrap'><i>bMean</i></span></code> to be specified for the parameter <code><span style='white-space: nowrap'><i>b</i></span></code>.
<code><span style='white-space: nowrap'><br>
<br>
</span></code>(The equation above uses
<a href="glossary.htm#Individual Notation" target="_top"><span style='white-space: nowrap'>individual&nbsp;notation</span></a>
.)

<br>
<br>
<b><big><a name="Reference" id="Reference">Reference</a></big></b>
<br>
B. M. Bell, <i>Approximating The Marginal Likelihood Estimate 
For Models With Random Parameters</i>, Applied Mathematics and Computation, 
Accepted 1999. 

<br>
<br>
<b><big><a name="Return Value" id="Return Value">Return Value</a></big></b>
<br>
Upon a successful completion, the function sets
the given output value place holders to point to the result values 
(ones that are requested).  The case that too-many-iter occurred during 
the optimization process is not a successful completion. 
<code><span style='white-space: nowrap'><br>
<br>
</span></code>If an error is detected or failure occurs during the evaluation, a SpkException object is
thrown.  The state at which an exception is thrown is defined in
<a href="glossary.htm#Exception Handling Policy" target="_top"><span style='white-space: nowrap'>Exception&nbsp;Handling&nbsp;Policy</span></a>
.

<br>
<br>
<b><big><a name="Note" id="Note">Note</a></big></b>
<br>
The length of the random population parameter vector <code><span style='white-space: nowrap'><i>b</i></span></code> is 
specified by the number of rows in the argument <i>dvecBIn</i>, 
which is a column vector containing the initial value for <code><span style='white-space: nowrap'><i>b</i></span></code>.

<br>
<br>
<b><big><a name="Arguments" id="Arguments">Arguments</a></big></b>

<code><font color="blue"><span style='white-space: nowrap'><br>
</span></font></code><i><span style='white-space: nowrap'>model</span></i><code><font color="blue"><span style='white-space: nowrap'><br>
</span></font></code>is a pointer to a SpkModel object that is a function of <code><span style='white-space: nowrap'><i>b</i></span></code> if <i>withD</i> is <code><span style='white-space: nowrap'><i>false</i></span></code>
(refer <a href="glossary.htm#Model Functions Depend on only b" target="_top"><span style='white-space: nowrap'>Model&nbsp;Functions&nbsp;Depend&nbsp;on&nbsp;only&nbsp;b</span></a>
)
or a function of <code><span style='white-space: nowrap'><i>alp</i></span></code> and <code><span style='white-space: nowrap'><i>b</i></span></code> if <i>withD</i> is <code><span style='white-space: nowrap'><i>true</i></span></code>
(refer <a href="glossary.htm#Model Functions Depend on only b" target="_top"><span style='white-space: nowrap'>Model&nbsp;Functions&nbsp;Depend&nbsp;on&nbsp;alp&nbsp;and&nbsp;b</span></a>
).
for details.

<code><font color="blue"><span style='white-space: nowrap'><br>
<br>
</span></font></code><i><span style='white-space: nowrap'>dvecY</span></i><code><font color="blue"><span style='white-space: nowrap'><br>
</span></font></code>The <code><font color="blue">DoubleMatrix</font></code> <i>dvecY</i> contains the column vector 
<code><span style='white-space: nowrap'><i>y</i></span></code>, which specifies the data.

<code><font color="blue"><span style='white-space: nowrap'><br>
<br>
</span></font></code><i><span style='white-space: nowrap'>optInfo</span></i><code><font color="blue"><span style='white-space: nowrap'><br>
</span></font></code>This <a href="optimizer.htm" target="_top"><span style='white-space: nowrap'>Optimizer</span></a>
 object contains the information 
that controls the individual level optimization process.
<code><span style='white-space: nowrap'><br>
<br>
</span></code>It has attributes for holding the optimization state information 
that is required to perform a warm start, i.e., to start the
optimization process using a previous set of optimization state
information.
If a warm start is being performed, then before this function is 
called the optimization state information must be set.
This information may have been set during a previous call to this
function, or the information may be set directly using the
Optimizer class member function, setStateInfo().
Note that the upper and lower bounds for <code><span style='white-space: nowrap'><i>b</i></span></code> must be the 
same as they were during the earlier call to this function.
<code><span style='white-space: nowrap'><br>
<br>
</span></code>Most of the optimizer information is accessible directly via public
get functions, e.g., the value epsilon is returned by the Optimizer 
class function <code><font color="blue">getEpsilon()</font></code>.  
The following subsections specify how this function uses 
some of the elements of the Optimizer object that are accessed 
directly using get functions.

<br>
<br>
<b><a name="Arguments.optInfo.epsilon" id="Arguments.optInfo.epsilon">optInfo.epsilon</a></b>
<br>
This real number is used to specify the convergence criteria
for the optimizer.
It must be greater than <code><span style='white-space: nowrap'>0.0</span></code>.
<code><span style='white-space: nowrap'><br>
<br>
</span></code>A individual parameter value <code><span style='white-space: nowrap'><i>bOut</i></span></code> is accepted as an estimate for 
<code><span style='white-space: nowrap'><i>bHat</i></span></code> if 
<code><span style='white-space: nowrap'><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>abs</i>(&nbsp;<i>bOut</i>&nbsp;-&nbsp;<i>bHat</i>&nbsp;)&nbsp;<u>&lt;</u>&nbsp;<i>epsilon</i>&nbsp;(&nbsp;<i>bUp</i>&nbsp;-&nbsp;<i>bLow</i>&nbsp;)&nbsp;&nbsp;,<br>
</span></code>where <code><span style='white-space: nowrap'><i>abs</i></span></code> is the element-by-element absolute value function
and <code><span style='white-space: nowrap'><i>bHat</i></span></code> is a local minimizer of <code><span style='white-space: nowrap'><i>MapObj</i>(<i>b</i>)</span></code>.
Since <code><span style='white-space: nowrap'><i>bHat</i></span></code> is unknown, this function estimates the left hand
side of this inequality in a way that is a good approximation when 
the Hessian of the objective function is positive definite.
<code><span style='white-space: nowrap'><br>
<br>
</span></code>Note that if <i>nMaxIter</i> is set to zero, then <code><span style='white-space: nowrap'><i>bIn</i></span></code> is 
accepted as the estimate for <code><span style='white-space: nowrap'><i>bHat</i></span></code>.

<br>
<br>
<b><a name="Arguments.optInfo.nMaxIter" id="Arguments.optInfo.nMaxIter">optInfo.nMaxIter</a></b>
<br>
This integer must be greater than or equal to zero.
It specifies the maximum number of 
iterations to attempt before giving up on convergence.
If it is equal to zero, then the initial
value for <code><span style='white-space: nowrap'><i>b</i></span></code> is accepted as the final value, and any requested output
values are evaluated at that final value.

<br>
<br>
<b><a name="Arguments.optInfo.traceLevel" id="Arguments.optInfo.traceLevel">optInfo.traceLevel</a></b>
<br>
This integer scalar specifies the amount of tracing.
Larger values of <i>traceLevel</i> entail more tracing, 
with <code><span style='white-space: nowrap'>4</span></code> being the highest level of tracing.
If <code><span style='white-space: nowrap'><i>level</i>&nbsp;<u>&gt;</u>&nbsp;1</span></code>, trace values are directed to standard output 
(stdout).  
<code><span style='white-space: nowrap'><br>
<br>
</span></code>Tracing is done using a scaled version of the
objective function.  For this scaled version the elements of
the parameter vector are constrained to the interval <code><span style='white-space: nowrap'>[0,&nbsp;1]</span></code>. 
<code><span style='white-space: nowrap'><br>
<br>
</span></code>If <i>traceLevel</i> is equal to <code><span style='white-space: nowrap'>4</span></code>, then the tracing 
will include the gradient of the objective and a finite difference 
approximation for that gradient.
These two gradients can be compared as a check on the consistency 
of the objective function and its gradient.
<code><span style='white-space: nowrap'><br>
<br>
</span></code>For more details on the tracing see the description of the level 
parameter for the optimizer <code><font color="blue">QuasiNewton01Box</font></code>.

<br>
<br>
<b><a name="Arguments.optInfo.nIterCompleted" id="Arguments.optInfo.nIterCompleted">optInfo.nIterCompleted</a></b>
<br>
This integer scalar holds the number of iteration that have been 
completed in the optimizer.

<br>
<br>
<b><a name="Arguments.optInfo.isTooManyIter" id="Arguments.optInfo.isTooManyIter">optInfo.isTooManyIter</a></b>
<br>
This flag indicates whether the too-many-iteration failure has occurred.  

<br>
<br>
<b><a name="Arguments.optInfo.saveStateAtEndOfOpt" id="Arguments.optInfo.saveStateAtEndOfOpt">optInfo.saveStateAtEndOfOpt</a></b>
<br>
This flag indicates if the state information required for a warm start
should be saved at the end of the optimization process.
This state information will not be saved if the optimization process
results in an exception being thrown by <code><font color="blue">quasiNewtonAnyBox</font></code>.

<br>
<br>
<b><a name="Arguments.optInfo.throwExcepIfMaxIter" id="Arguments.optInfo.throwExcepIfMaxIter">optInfo.throwExcepIfMaxIter</a></b>
<br>
This flag indicates if the optimizer should throw an exception when
the maximum number of iterations is exhausted.
If this parameter is true, then when
the maximum number of iterations is exhausted, an exception will
be thrown and the output values for this function will not be set.
Otherwise, the calling program will
need to check the parameter isTooManyIter to see if the 
maximum number of iterations was exhausted.

<br>
<br>
<b><a name="Arguments.optInfo.isWarmStartPossible" id="Arguments.optInfo.isWarmStartPossible">optInfo.isWarmStartPossible</a></b>
<br>
This flag indicates whether it is possible to perform a warm start 
using the current optimizer state information.

<br>
<br>
<b><a name="Arguments.optInfo.isWarmStart" id="Arguments.optInfo.isWarmStart">optInfo.isWarmStart</a></b>
<br>
This flag indicates whether the optimization should run a warm start.  

<br>
<br>
<b><a name="Arguments.optInfo.stateInfo" id="Arguments.optInfo.stateInfo">optInfo.stateInfo</a></b>
<br>
This <code><font color="blue">StateInfo</font></code> struct contains the optimization state information
required to perform a warm start.
Each of its elements is accessed using the Optimizer class member
functions, <code><font color="blue">getStateInfo()</font></code> and <code><font color="blue">setStateInfo()</font></code>.

<code><font color="blue"><span style='white-space: nowrap'><br>
<br>
</span></font></code><i><span style='white-space: nowrap'>dvecBLow</span></i><code><font color="blue"><span style='white-space: nowrap'><br>
</span></font></code>The <code><font color="blue">DoubleMatrix</font></code> <i>dvecBLow</i> contains the column vector 
<code><span style='white-space: nowrap'><i>bLow</i></span></code>, which specifies the lower limit for the parameter vector 
<code><span style='white-space: nowrap'><i>b</i></span></code> during the optimization procedure.
The length of <i>dvecBLow</i> is equal to the length of 
the random population parameter vector <code><span style='white-space: nowrap'><i>b</i></span></code>.

<code><font color="blue"><span style='white-space: nowrap'><br>
<br>
</span></font></code><i><span style='white-space: nowrap'>dvecBUp</span></i><code><font color="blue"><span style='white-space: nowrap'><br>
</span></font></code>The <code><font color="blue">DoubleMatrix</font></code> <i>dvecBUp</i> contains the column vector 
<code><span style='white-space: nowrap'><i>bUp</i></span></code>, which specifies the upper limit for the parameter vector 
<code><span style='white-space: nowrap'><i>b</i></span></code> during the optimization procedure.
The length of <i>dvecBUp</i> is equal to the length of 
the random population parameter vector <code><span style='white-space: nowrap'><i>b</i></span></code>.

<code><font color="blue"><span style='white-space: nowrap'><br>
<br>
</span></font></code><i><span style='white-space: nowrap'>dvecBIn</span></i><code><font color="blue"><span style='white-space: nowrap'><br>
</span></font></code>The <code><font color="blue">DoubleMatrix</font></code> <i>dvecBIn</i> contains the column vector 
<code><span style='white-space: nowrap'><i>bIn</i></span></code>, which specifies the initial value for the parameter vector 
<code><span style='white-space: nowrap'><i>b</i></span></code>.
The <a href="glossary.htm#Ordering Of Vectors" target="_top"><span style='white-space: nowrap'>order&nbsp;condition</span></a>
,
<code><span style='white-space: nowrap'><i>bLow</i>&nbsp;<u>&lt;</u>&nbsp;<i>bIn</i>&nbsp;<u>&lt;</u>&nbsp;<i>bUp</i></span></code>, is assumed to hold.
Note that the length of <i>dvecBIn</i> specifies the length of 
the random population parameter vector <code><span style='white-space: nowrap'><i>b</i></span></code>.

<code><font color="blue"><span style='white-space: nowrap'><br>
<br>
</span></font></code><i><span style='white-space: nowrap'>pdvecBOut</span></i><code><font color="blue"><span style='white-space: nowrap'><br>
</span></font></code>If <i>pdvecBOut</i> is not <code><font color="blue">NULL</font></code>, then the <code><font color="blue">DoubleMatrix</font></code> 
pointed to by <i>pdvecBOut</i> must be declared in the function that 
calls this function, and it must have the same dimensions as <i>dvecBIn</i>.
If <i>pdvecBOut</i> is not <code><font color="blue">NULL</font></code>, 
and if this function completed the optimization successfully, 
then the <code><font color="blue">DoubleMatrix</font></code> pointed to by <i>pdvecBOut</i> will contain 
the column vector <code><span style='white-space: nowrap'><i>bOut</i></span></code>, which is the estimate for the true minimizer 
of the objective function.
Otherwise, this function will not attempt to change the contents of the 
<code><font color="blue">DoubleMatrix</font></code> pointed to by <i>pdvecBOut</i>.

<code><font color="blue"><span style='white-space: nowrap'><br>
<br>
</span></font></code><i><span style='white-space: nowrap'>dvecBStep</span></i><code><font color="blue"><span style='white-space: nowrap'><br>
</span></font></code>The <code><font color="blue">DoubleMatrix</font></code> <i>dvecBStep</i> contains the column vector 
<code><span style='white-space: nowrap'><i>bStep</i></span></code>, which specifies the step size used for approximating
the derivative of <code><span style='white-space: nowrap'><i>MapObj</i>_<i>b</i>(<i>b</i>)</span></code>.
This is not used if <i>pdmatMapObj_b_bOut</i> is equal to zero.
The length of <i>dvecBStep</i> is equal to the length of 
the random population parameter vector <code><span style='white-space: nowrap'><i>b</i></span></code>.

<code><font color="blue"><span style='white-space: nowrap'><br>
<br>
</span></font></code><i><span style='white-space: nowrap'>pdMapObjOut</span></i><code><font color="blue"><span style='white-space: nowrap'><br>
</span></font></code>If <i>pdMapObjOut</i> is not <code><font color="blue">NULL</font></code>, then the <code><font color="blue">double</font></code> 
value pointed to by <i>pdMapObjOut</i> must be declared in the 
function that calls this function.
If <i>pdMapObjOut</i> is not <code><font color="blue">NULL</font></code>, 
and if this function completed the optimization successfully, 
then the <code><font color="blue">double</font></code> value pointed to by <i>pdMapObjOut</i> will 
be equal to <code><span style='white-space: nowrap'><i>MapObj</i>(<i>bOut</i>)</span></code>, which is the value of the objective 
function evaluated at <code><span style='white-space: nowrap'><i>bOut</i></span></code>.
Otherwise, this function will not attempt to change the contents of the 
<code><font color="blue">DoubleMatrix</font></code> pointed to by <i>pdMapObjOut</i>.

<code><font color="blue"><span style='white-space: nowrap'><br>
<br>
</span></font></code><i><span style='white-space: nowrap'>pdrowMapObj_bOut</span></i><code><font color="blue"><span style='white-space: nowrap'><br>
</span></font></code>If <i>pdrowMapObj_bOut</i> is not <code><font color="blue">NULL</font></code>, then the 
<code><font color="blue">DoubleMatrix</font></code> pointed to by <i>pdrowMapObj_bOut</i> 
must be declared in the function that calls this function, and it 
must be a row vector that is the same length as
the random population parameter vector <code><span style='white-space: nowrap'><i>b</i></span></code>.
If <i>pdrowMapObj_bOut</i> is not <code><font color="blue">NULL</font></code>, 
and if this function completed the optimization successfully, 
then the <code><font color="blue">DoubleMatrix</font></code> pointed to by <i>pdrowMapObj_bOut</i> 
will contain the row vector <code><span style='white-space: nowrap'><i>MapObj</i>_<i>b</i>(<i>bOut</i>)</span></code>, which is
the derivative of the objective function evaluated at <code><span style='white-space: nowrap'><i>bOut</i></span></code>. 
Otherwise, this function will not attempt to change the contents of the 
<code><font color="blue">DoubleMatrix</font></code> pointed to by <i>pdrowMapObj_bOut</i>.

<code><font color="blue"><span style='white-space: nowrap'><br>
<br>
</span></font></code><i><span style='white-space: nowrap'>pdmatMapObj_b_bOut</span></i><code><font color="blue"><span style='white-space: nowrap'><br>
</span></font></code>If <i>pdmatMapObj_b_bOut</i> is not <code><font color="blue">NULL</font></code>, then the 
<code><font color="blue">DoubleMatrix</font></code> pointed to by <i>pdmatMapObj_b_bOut</i> 
must be declared in the function that calls this function, and it 
must have the same number of rows and columns as the length of
the random population parameter vector <code><span style='white-space: nowrap'><i>b</i></span></code>.
If <i>pdmatMapObj_b_bOut</i> is not <code><font color="blue">NULL</font></code>, 
and if this function completed the optimization successfully, 
then the <code><font color="blue">DoubleMatrix</font></code> pointed to by 
<i>pdmatMapObj_b_bOut</i> will contain the matrix 
<code><span style='white-space: nowrap'><i>MapObj</i>_<i>b</i>_<i>b</i>(<i>bOut</i>)</span></code>, which is an approximation for the
second derivative of the objective function evaluated at <code><span style='white-space: nowrap'><i>bOut</i></span></code>.  
Otherwise, this function will not attempt to change the contents of the 
<code><font color="blue">DoubleMatrix</font></code> pointed to by <i>pdmatMapObj_b_bOut</i>.
The approximation for the second derivative is formed using central
differences of the function <code><span style='white-space: nowrap'><i>MapObj</i>_<i>b</i>(<i>b</i>)</span></code> with
step sizes specified by <i>dvecBStep</i>.

<code><font color="blue"><span style='white-space: nowrap'><br>
<br>
</span></font></code><i><span style='white-space: nowrap'>withD</span></i><code><font color="blue"><span style='white-space: nowrap'><br>
</span></font></code>When <i>withD</i> is specified <code><span style='white-space: nowrap'><i>false</i></span></code>,
the system assumes that the prior distribution is provided by the user.
In such a case, <i>withD</i> is a function of <code><span style='white-space: nowrap'><i>alp</i></span></code> and <code><span style='white-space: nowrap'><i>b</i></span></code>
(refer <a href="glossary.htm#Model Functions Depend on only b" target="_top"><span style='white-space: nowrap'>Model&nbsp;Functions&nbsp;Depend&nbsp;on&nbsp;alp&nbsp;and&nbsp;b</span></a>
).
Otherwise, <i>model</i> is a function of only <code><span style='white-space: nowrap'><i>b</i></span></code>
(refer <a href="glossary.htm#Model Functions Depend on only b" target="_top"><span style='white-space: nowrap'>Model&nbsp;Functions&nbsp;Depend&nbsp;on&nbsp;only&nbsp;b</span></a>
)

<code><font color="blue"><span style='white-space: nowrap'><br>
<br>
</span></font></code><i><span style='white-space: nowrap'>isFO</span></i><code><font color="blue"><span style='white-space: nowrap'><br>
</span></font></code>If <i>isFO</i> is <code><span style='white-space: nowrap'><i>false</i></span></code>, then the Modified First Order will be chosen for approximation.
If <code><span style='white-space: nowrap'><i>true</i></span></code> is given, other approximations are assumed.


<code><font color="blue"><span style='white-space: nowrap'><br>
<br>
</span></font></code><i><span style='white-space: nowrap'>pdvecN</span></i><code><font color="blue"><span style='white-space: nowrap'>(null&nbsp;by&nbsp;default)<br>
</span></font></code>If <i>isFO</i> is specified as <code><span style='white-space: nowrap'><i>true</i></span></code>, <i>pdvecN</i> points to a DoubleMatrix 
object that contains the column vector <code><span style='white-space: nowrap'><i>N</i></span></code>.  The <i>i</i>-th element of <code><span style='white-space: nowrap'><i>N</i></span></code>
specifies the number of elements of <code><span style='white-space: nowrap'><i>y</i></span></code> that correspond to the <i>i</i>-th individual.
If <i>isFO</i> is specified as <code><span style='white-space: nowrap'><i>false</i></span></code>, set <i>N</i> to null.

<code><font color="blue"><span style='white-space: nowrap'><br>
<br>
</span></font></code><i><span style='white-space: nowrap'>pdvecBMean</span></i><code><font color="blue"><span style='white-space: nowrap'>(null&nbsp;by&nbsp;default)<br>
</span></font></code>If the pointer <i>pdvecBMean</i> is not equal to null, then it points to a DoubleMatrix 
object that contains the column vector <code><span style='white-space: nowrap'><i>bMean</i></span></code>.  The <i>j</i>-th element of <code><span style='white-space: nowrap'><i>bMean</i></span></code>
specifies the mean value for the <i>j</i>-th element of <code><span style='white-space: nowrap'><i>b</i></span></code>.
If the mean values for all of the elements of <code><span style='white-space: nowrap'><i>b</i></span></code> are equal to zero, 
set <i>pdvecBMean</i> to null.


<br>
<br>
<b><big><a name="Example" id="Example">Example</a></big></b>


<br>
Suppose that
<code><span style='white-space: nowrap'><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;exp[<i>b</i>(1)]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;1&nbsp;&nbsp;0&nbsp;\<br>
<i>R</i>(<i>b</i>)&nbsp;=&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;<i>D</i>&nbsp;&nbsp;=&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exp[<i>b</i>(1)]&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&nbsp;0&nbsp;.5&nbsp;/<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;<i>b</i>(2)&nbsp;\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;2&nbsp;\<br>
<i>f</i>(<i>b</i>)&nbsp;=&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;<i>y</i>&nbsp;=&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;|<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&nbsp;<i>b</i>(2)&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&nbsp;2&nbsp;/<br>
</span></code>It follows that
<code><span style='white-space: nowrap'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
<i>MapObj</i>(<i>b</i>)&nbsp;=&nbsp;log{2&nbsp;pi&nbsp;exp[<i>b</i>(1)]}&nbsp;+&nbsp;[2&nbsp;-&nbsp;<i>b</i>(2)]^2&nbsp;exp[-<i>b</i>(1)]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;log(2&nbsp;pi)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;(1/2)&nbsp;<i>b</i>(1)^2&nbsp;+&nbsp;&nbsp;<i>b</i>(2)^2<br>
</span></code>The gradient of <code><span style='white-space: nowrap'><i>MapObj</i>(<i>b</i>)</span></code> is equal to
<code><span style='white-space: nowrap'><br>
&nbsp;&nbsp;/&nbsp;1&nbsp;-&nbsp;[2&nbsp;-&nbsp;<i>b</i>(2)]^2&nbsp;exp[-<i>b</i>(1)]&nbsp;+&nbsp;<i>b</i>(1)&nbsp;\<br>
&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>
&nbsp;&nbsp;\&nbsp;-2&nbsp;[2&nbsp;-&nbsp;<i>b</i>(2)]&nbsp;exp[-<i>b</i>(1)]&nbsp;+&nbsp;2&nbsp;<i>b</i>(2)&nbsp;&nbsp;/<br>
</span></code>The first order necessary condition for a minimum is 
that the gradient is zero. This is true when
<code><span style='white-space: nowrap'><i>b</i>(1)&nbsp;=&nbsp;0</span></code> and <code><span style='white-space: nowrap'><i>b</i>(2)&nbsp;=&nbsp;1</span></code>.
<code><span style='white-space: nowrap'><br>
<br>
</span></code>Taking the derivative of the gradient above,
<code><span style='white-space: nowrap'><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;[2-<i>b</i>(2)]^2exp[-<i>b</i>(1)]+1&nbsp;&nbsp;&nbsp;2[2-<i>b</i>(2)]exp[-<i>b</i>(1)]&nbsp;\<br>
<i>MapObj</i>_<i>b</i>_<i>b</i>(<i>b</i>)&nbsp;=&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&nbsp;&nbsp;2[2-<i>b</i>(2)]exp[-<i>b</i>(1)]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2exp[-<i>b</i>(1)]&nbsp;+&nbsp;2&nbsp;&nbsp;&nbsp;/<br>
</span></code>substituting in 
<code><span style='white-space: nowrap'><i>b</i>(1)&nbsp;=&nbsp;0</span></code> and <code><span style='white-space: nowrap'><i>b</i>(2)&nbsp;=&nbsp;1</span></code>, we obtain
<code><span style='white-space: nowrap'><br>
&nbsp;&nbsp;/&nbsp;2&nbsp;&nbsp;2&nbsp;\<br>
&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;.<br>
&nbsp;&nbsp;\&nbsp;2&nbsp;&nbsp;4&nbsp;/<br>
</span></code><code><span style='white-space: nowrap'><br>
<br>
</span></code>If you compile, link, and run the following program:
<code><font color="blue">
<span style='white-space: nowrap'><br>
<br>
#include&nbsp;&quot;mapOpt.h&quot;<br>
#include&nbsp;&quot;SpkModel.h&quot;<br>
#include&nbsp;&quot;DoubleMatrix.h&quot;<br>
#include&nbsp;&quot;pi.h&quot;<br>
#include&nbsp;&quot;allZero.h&quot;<br>
#include&nbsp;&quot;Optimizer.h&quot;<br>
#include&nbsp;&lt;iostream&gt;<br>
#include&nbsp;&lt;iomanip&gt;<br>
#include&nbsp;&lt;string&gt;<br>
#include&nbsp;&lt;cmath&gt;<br>
#include&nbsp;&lt;cstdlib&gt;<br>
<br>
static&nbsp;DoubleMatrix&nbsp;funF(&nbsp;&nbsp;const&nbsp;DoubleMatrix&nbsp;&amp;dvecB&nbsp;);<br>
static&nbsp;DoubleMatrix&nbsp;funF_b(const&nbsp;DoubleMatrix&nbsp;&amp;dvecFb,&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;DoubleMatrix&nbsp;&amp;dvecB&nbsp;);<br>
static&nbsp;DoubleMatrix&nbsp;funR(&nbsp;&nbsp;const&nbsp;DoubleMatrix&nbsp;&amp;dvecB&nbsp;);<br>
static&nbsp;DoubleMatrix&nbsp;funR_b(const&nbsp;DoubleMatrix&nbsp;&amp;dmatRb,&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;DoubleMatrix&nbsp;&amp;dvecB&nbsp;);<br>
<br>
class&nbsp;IndModel&nbsp;:&nbsp;public&nbsp;SpkModel&lt;double&gt;<br>
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;DoubleMatrix&nbsp;_b;<br>
public:<br>
&nbsp;&nbsp;&nbsp;&nbsp;IndModel(){}<br>
&nbsp;&nbsp;&nbsp;&nbsp;~IndModel(){}<br>
protected:<br>
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;doSetIndPar(const&nbsp;valarray&lt;double&gt;&amp;&nbsp;b)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_b&nbsp;=&nbsp;DoubleMatrix(&nbsp;b,&nbsp;1&nbsp;);<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;doDataMean(&nbsp;valarray&lt;double&gt;&amp;&nbsp;ret&nbsp;)&nbsp;const<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;funF(_b).toValarray();<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;doDataMean_indPar(&nbsp;valarray&lt;double&gt;&amp;&nbsp;ret&nbsp;)&nbsp;const<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doDataMean(ret);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;funF_b(ret,&nbsp;_b).toValarray();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;!allZero(ret);<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;doDataVariance(&nbsp;valarray&lt;double&gt;&amp;&nbsp;ret&nbsp;)&nbsp;const<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;funR(_b).toValarray();<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;doDataVariance_indPar(&nbsp;valarray&lt;double&gt;&amp;&nbsp;ret&nbsp;)&nbsp;const<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doDataVariance(ret);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;funR_b(ret,&nbsp;_b).toValarray();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;!allZero(ret);<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;doIndParVariance(&nbsp;valarray&lt;double&gt;&amp;&nbsp;ret&nbsp;)&nbsp;const<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DoubleMatrix&nbsp;dmatD(&nbsp;2,&nbsp;2&nbsp;);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double*&nbsp;pdDData&nbsp;=&nbsp;dmatD.data();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pdDData[0]&nbsp;=&nbsp;1.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pdDData[1]&nbsp;=&nbsp;0.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pdDData[2]&nbsp;=&nbsp;0.0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pdDData[3]&nbsp;=&nbsp;0.5;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;re&nbsp;=&nbsp;dmatD.toValarray();<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
};<br>
<br>
//--------------------------------------------------------------<br>
//<br>
//&nbsp;Function:&nbsp;main<br>
//<br>
//--------------------------------------------------------------<br>
<br>
int&nbsp;main()<br>
{<br>
&nbsp;&nbsp;//------------------------------------------------------------<br>
&nbsp;&nbsp;//&nbsp;Preliminaries.<br>
&nbsp;&nbsp;//------------------------------------------------------------<br>
<br>
&nbsp;&nbsp;using&nbsp;namespace&nbsp;std;<br>
<br>
<br>
&nbsp;&nbsp;//------------------------------------------------------------<br>
&nbsp;&nbsp;//&nbsp;Quantities&nbsp;related&nbsp;to&nbsp;the&nbsp;user-provided&nbsp;model.<br>
&nbsp;&nbsp;//------------------------------------------------------------<br>
<br>
&nbsp;&nbsp;IndModel&nbsp;model;<br>
<br>
<br>
&nbsp;&nbsp;//------------------------------------------------------------<br>
&nbsp;&nbsp;//&nbsp;Quantities&nbsp;related&nbsp;to&nbsp;the&nbsp;data&nbsp;vector,&nbsp;y.<br>
&nbsp;&nbsp;//------------------------------------------------------------<br>
<br>
&nbsp;&nbsp;int&nbsp;nY&nbsp;=&nbsp;2;<br>
&nbsp;&nbsp;DoubleMatrix&nbsp;dvecY(&nbsp;nY,&nbsp;1&nbsp;);<br>
&nbsp;&nbsp;dvecY.fill(&nbsp;2.0&nbsp;);<br>
<br>
<br>
&nbsp;&nbsp;//------------------------------------------------------------<br>
&nbsp;&nbsp;//&nbsp;Quantities&nbsp;related&nbsp;to&nbsp;the&nbsp;objective&nbsp;function&nbsp;parameter,&nbsp;b.<br>
&nbsp;&nbsp;//------------------------------------------------------------<br>
<br>
&nbsp;&nbsp;int&nbsp;nObjPars&nbsp;=&nbsp;2;<br>
<br>
&nbsp;&nbsp;DoubleMatrix&nbsp;dvecBLow&nbsp;(&nbsp;nObjPars,&nbsp;1&nbsp;);<br>
&nbsp;&nbsp;DoubleMatrix&nbsp;dvecBUp&nbsp;&nbsp;(&nbsp;nObjPars,&nbsp;1&nbsp;);<br>
&nbsp;&nbsp;DoubleMatrix&nbsp;dvecBIn&nbsp;&nbsp;(&nbsp;nObjPars,&nbsp;1&nbsp;);<br>
&nbsp;&nbsp;DoubleMatrix&nbsp;dvecBOut&nbsp;(&nbsp;nObjPars,&nbsp;1&nbsp;);<br>
&nbsp;&nbsp;DoubleMatrix&nbsp;dvecBStep(&nbsp;nObjPars,&nbsp;1&nbsp;);<br>
<br>
&nbsp;&nbsp;dvecBLow&nbsp;.fill(&nbsp;-4.0&nbsp;);<br>
&nbsp;&nbsp;dvecBUp&nbsp;&nbsp;.fill(&nbsp;&nbsp;4.0&nbsp;);<br>
&nbsp;&nbsp;dvecBIn&nbsp;&nbsp;.fill(&nbsp;&nbsp;2.0&nbsp;);<br>
&nbsp;&nbsp;dvecBStep.fill(&nbsp;&nbsp;0.001&nbsp;);<br>
<br>
<br>
&nbsp;&nbsp;//------------------------------------------------------------<br>
&nbsp;&nbsp;//&nbsp;Quantities&nbsp;related&nbsp;to&nbsp;the&nbsp;objective&nbsp;function,&nbsp;MapObj(b).<br>
&nbsp;&nbsp;//------------------------------------------------------------<br>
<br>
&nbsp;&nbsp;double&nbsp;dMapObjOut;<br>
<br>
&nbsp;&nbsp;DoubleMatrix&nbsp;drowMapObj_bOut&nbsp;&nbsp;(&nbsp;1,&nbsp;nObjPars&nbsp;);<br>
&nbsp;&nbsp;DoubleMatrix&nbsp;dmatMapObj_b_bOut(&nbsp;nObjPars,&nbsp;nObjPars&nbsp;);<br>
<br>
<br>
&nbsp;&nbsp;//------------------------------------------------------------<br>
&nbsp;&nbsp;//&nbsp;Remaining&nbsp;inputs&nbsp;to&nbsp;mapOpt.<br>
&nbsp;&nbsp;//------------------------------------------------------------<br>
<br>
&nbsp;&nbsp;double&nbsp;epsilon&nbsp;&nbsp;=&nbsp;1.e-3;&nbsp;<br>
&nbsp;&nbsp;int&nbsp;nMaxIter&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;40;&nbsp;<br>
&nbsp;&nbsp;double&nbsp;fOut&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;0.0;&nbsp;<br>
&nbsp;&nbsp;int&nbsp;level&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;0;<br>
&nbsp;&nbsp;Optimizer&nbsp;optInfo(epsilon,&nbsp;nMaxIter,&nbsp;level);<br>
&nbsp;&nbsp;void*&nbsp;pFvalInfo&nbsp;=&nbsp;0;<br>
&nbsp;&nbsp;bool&nbsp;withD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;true;<br>
&nbsp;&nbsp;bool&nbsp;isFO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;false;<br>
&nbsp;&nbsp;DoubleMatrix&nbsp;*&nbsp;pdvecN&nbsp;=&nbsp;NULL;<br>
&nbsp;&nbsp;DoubleMatrix&nbsp;*&nbsp;pdvecBMean&nbsp;=&nbsp;NULL;<br>
<br>
<br>
&nbsp;&nbsp;//------------------------------------------------------------<br>
&nbsp;&nbsp;//&nbsp;Optimize&nbsp;MapObj(b).<br>
&nbsp;&nbsp;//------------------------------------------------------------<br>
<br>
&nbsp;&nbsp;//&nbsp;try&nbsp;mapOpt(...)&nbsp;which&nbsp;may&nbsp;throw&nbsp;an&nbsp;exception.<br>
&nbsp;&nbsp;bool&nbsp;ok&nbsp;=&nbsp;true;<br>
&nbsp;&nbsp;try{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapOpt(model,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dvecY,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;optInfo,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dvecBLow,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dvecBUp,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dvecBIn,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;dvecBOut,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dvecBStep,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;dMapObjOut,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;drowMapObj_bOut,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;dmatMapObj_b_bOut,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;withD,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isFO<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pdvecN,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pdvecBMean<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;catch(&nbsp;...&nbsp;)<br>
&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;cerr&nbsp;&lt;&lt;&nbsp;&quot;mapOpt&nbsp;failed&quot;&nbsp;&lt;&lt;&nbsp;endl;<br>
&nbsp;&nbsp;&nbsp;&nbsp;abort();<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;//------------------------------------------------------------<br>
&nbsp;&nbsp;//&nbsp;Print&nbsp;the&nbsp;results.<br>
&nbsp;&nbsp;//------------------------------------------------------------<br>
<br>
&nbsp;&nbsp;double&nbsp;dMapObjKnown&nbsp;=&nbsp;2.0&nbsp;*&nbsp;log(&nbsp;2.0&nbsp;*&nbsp;PI&nbsp;)&nbsp;-&nbsp;0.5&nbsp;*&nbsp;log(&nbsp;2.0&nbsp;)&nbsp;+&nbsp;2.0;<br>
<br>
&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;setiosflags(ios::scientific)&nbsp;&lt;&lt;&nbsp;setprecision(15);<br>
<br>
&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;&quot;ok&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;(&nbsp;ok&nbsp;?&nbsp;&quot;True&quot;&nbsp;:&nbsp;&quot;False&quot;&nbsp;)&nbsp;&lt;&lt;&nbsp;endl;<br>
<br>
&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;&quot;bOut&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;endl;<br>
&nbsp;&nbsp;dvecBOut.print();<br>
&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;&quot;MapObjOut&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;dMapObjOut&nbsp;&lt;&lt;&nbsp;endl;<br>
&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;&quot;MapObj&nbsp;(known)&nbsp;=&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;dMapObjKnown&nbsp;&lt;&lt;&nbsp;endl;<br>
&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;&quot;MapObj_bOut&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;endl;<br>
&nbsp;&nbsp;drowMapObj_bOut.print();<br>
&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;&quot;MapObj_b_bOut&nbsp;&nbsp;=&nbsp;&quot;&nbsp;&lt;&lt;&nbsp;endl;<br>
&nbsp;&nbsp;dmatMapObj_b_bOut.print();<br>
<br>
&nbsp;&nbsp;return&nbsp;ok&nbsp;?&nbsp;EXIT_SUCCESS&nbsp;:&nbsp;EXIT_FAILURE;<br>
}<br>
<br>
<br>
//--------------------------------------------------------------<br>
//<br>
//&nbsp;Function:&nbsp;funR<br>
//<br>
//<br>
//&nbsp;Calculates&nbsp;the&nbsp;covariance&nbsp;of&nbsp;the&nbsp;measurement&nbsp;error:<br>
//<br>
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;exp[b(1)]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;\&nbsp;<br>
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R(b)&nbsp;=&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;.<br>
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exp[b(1)]&nbsp;/&nbsp;<br>
//<br>
//--------------------------------------------------------------<br>
<br>
static&nbsp;DoubleMatrix&nbsp;funR(&nbsp;const&nbsp;DoubleMatrix&nbsp;&amp;dvecB&nbsp;)<br>
{<br>
&nbsp;&nbsp;DoubleMatrix&nbsp;dmatR(&nbsp;2,&nbsp;2&nbsp;);<br>
&nbsp;&nbsp;double&nbsp;*pdRData&nbsp;=&nbsp;dmatR.data();<br>
&nbsp;&nbsp;const&nbsp;double&nbsp;*pdBData&nbsp;=&nbsp;dvecB.data();<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;pdRData[0]&nbsp;=&nbsp;exp(&nbsp;pdBData[0]&nbsp;);<br>
&nbsp;&nbsp;pdRData[1]&nbsp;=&nbsp;0.0;<br>
&nbsp;&nbsp;pdRData[2]&nbsp;=&nbsp;0.0;<br>
&nbsp;&nbsp;pdRData[3]&nbsp;=&nbsp;exp(&nbsp;pdBData[0]&nbsp;);<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;return&nbsp;dmatR;<br>
}<br>
<br>
<br>
//--------------------------------------------------------------<br>
//<br>
//&nbsp;Function:&nbsp;funR_b<br>
//<br>
//<br>
//&nbsp;Calculates&nbsp;the&nbsp;derivative&nbsp;of&nbsp;the&nbsp;measurement&nbsp;covariance<br>
//&nbsp;with&nbsp;respect&nbsp;to&nbsp;b:<br>
//<br>
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;exp[b(1)]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;\&nbsp;<br>
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R_b(b)&nbsp;=&nbsp;|&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;.<br>
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;|&nbsp;<br>
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&nbsp;&nbsp;exp[b(1)]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;/&nbsp;<br>
//<br>
//--------------------------------------------------------------<br>
<br>
static&nbsp;DoubleMatrix&nbsp;funR_b(&nbsp;const&nbsp;DoubleMatrix&nbsp;&amp;dmatR,&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;DoubleMatrix&nbsp;&amp;dvecB&nbsp;)<br>
{<br>
&nbsp;&nbsp;DoubleMatrix&nbsp;dmatR_b(&nbsp;dmatR.nr()*dmatR.nc(),&nbsp;dvecB.nr()&nbsp;);<br>
&nbsp;&nbsp;double&nbsp;*pdR_bData&nbsp;=&nbsp;dmatR_b.data();<br>
&nbsp;&nbsp;const&nbsp;double&nbsp;*pdBData&nbsp;&nbsp;&nbsp;=&nbsp;dvecB.data();<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;dmatR_b.fill(0.0);<br>
&nbsp;&nbsp;pdR_bData[0]&nbsp;=&nbsp;exp(&nbsp;pdBData[0]&nbsp;);<br>
&nbsp;&nbsp;pdR_bData[3]&nbsp;=&nbsp;exp(&nbsp;pdBData[0]&nbsp;);<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;return&nbsp;dmatR_b;<br>
}<br>
<br>
<br>
//--------------------------------------------------------------<br>
//<br>
//&nbsp;Function:&nbsp;funF<br>
//<br>
//<br>
//&nbsp;Calculates&nbsp;the&nbsp;model&nbsp;for&nbsp;the&nbsp;mean&nbsp;of&nbsp;the&nbsp;measurements:<br>
//<br>
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;b(2)&nbsp;\&nbsp;<br>
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f(b)&nbsp;=&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;.<br>
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&nbsp;b(2)&nbsp;/<br>
//<br>
//--------------------------------------------------------------<br>
<br>
static&nbsp;DoubleMatrix&nbsp;funF(&nbsp;const&nbsp;DoubleMatrix&nbsp;&amp;dvecB&nbsp;)<br>
{<br>
&nbsp;&nbsp;DoubleMatrix&nbsp;dvecF(2,1);<br>
&nbsp;&nbsp;double&nbsp;*pdFData&nbsp;=&nbsp;dvecF.data();<br>
&nbsp;&nbsp;const&nbsp;double&nbsp;*pdBData&nbsp;=&nbsp;dvecB.data();<br>
<br>
&nbsp;&nbsp;pdFData[0]&nbsp;=&nbsp;pdBData[1];<br>
&nbsp;&nbsp;pdFData[1]&nbsp;=&nbsp;pdBData[1];<br>
<br>
&nbsp;&nbsp;return&nbsp;dvecF;<br>
}<br>
<br>
<br>
//--------------------------------------------------------------<br>
//<br>
//&nbsp;Function:&nbsp;funF_b<br>
//<br>
//<br>
//&nbsp;Calculates&nbsp;the&nbsp;derivative&nbsp;of&nbsp;the&nbsp;model&nbsp;for&nbsp;the&nbsp;mean&nbsp;of&nbsp;the&nbsp;<br>
//&nbsp;measurements&nbsp;with&nbsp;respect&nbsp;to&nbsp;b:<br>
//<br>
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;0&nbsp;&nbsp;&nbsp;1&nbsp;\&nbsp;<br>
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f_b(b)&nbsp;=&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;.<br>
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\&nbsp;0&nbsp;&nbsp;&nbsp;1&nbsp;/<br>
//<br>
//--------------------------------------------------------------<br>
<br>
static&nbsp;DoubleMatrix&nbsp;funF_b(&nbsp;const&nbsp;DoubleMatrix&nbsp;&amp;dvecF,&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;DoubleMatrix&nbsp;&amp;dvecB&nbsp;)<br>
{<br>
&nbsp;&nbsp;DoubleMatrix&nbsp;dmatF_b(2,2);<br>
&nbsp;&nbsp;double&nbsp;*pdF_bData&nbsp;=&nbsp;dmatF_b.data();<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;pdF_bData[0]&nbsp;=&nbsp;0.0;<br>
&nbsp;&nbsp;pdF_bData[1]&nbsp;=&nbsp;0.0;<br>
&nbsp;&nbsp;pdF_bData[2]&nbsp;=&nbsp;1.0;<br>
&nbsp;&nbsp;pdF_bData[3]&nbsp;=&nbsp;1.0;<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;return&nbsp;dmatF_b;<br>
}<br>
&nbsp;&nbsp;<br>
</span>
</font></code>
then it will display the following when it is run:
<code><font color="blue">
<span style='white-space: nowrap'><br>
<br>
ok&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;True<br>
bOut&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=<br>
[&nbsp;2.260754053295955e-006&nbsp;]<br>
[&nbsp;9.999994638370806e-001&nbsp;]<br>
MapObjOut&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;5.329180542541980e+000<br>
MapObj&nbsp;(known)&nbsp;=&nbsp;5.329180542538718e+000<br>
MapObj_bOut&nbsp;&nbsp;&nbsp;&nbsp;=<br>
[&nbsp;3.449181849135563e-006&nbsp;2.376853741825613e-006&nbsp;]<br>
MapObj_b_bOut&nbsp;&nbsp;=<br>
[&nbsp;1.999998978238548e+000&nbsp;1.999996550820227e+000&nbsp;]<br>
[&nbsp;1.999996884152977e+000&nbsp;3.999995478496610e+000&nbsp;]<br>
</span>
</font></code>

<hr>Input File: ../../spk/mapOpt.cpp

</body>
</html>
