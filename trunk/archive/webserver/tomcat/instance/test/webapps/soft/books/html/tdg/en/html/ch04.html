<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
  <head>
    <meta name="generator" content=
    "HTML Tidy for Linux/x86 (vers 1st March 2002), see www.w3.org">
    <meta http-equiv="Content-Type" content=
    "text/html; charset=ISO-8859-1">

    <title>Publishing DocBook Documents</title>
    <link rel="stylesheet" href="defguide.css" type="text/css">
    <meta name="generator" content=
    "DocBook XSL Stylesheets V1.59.0">
    <link rel="home" href="docbook.html" title="DocBook">
    <link rel="up" href="part1.html" title=
    "Part&#160;I.&#160;Introduction">
    <link rel="previous" href="ch03.html" title=
    "Parsing DocBook Documents">
    <link rel="next" href="ch05.html" title="Customizing DocBook">
  </head>

  <body>
    <div class="navheader">
      <table border="0" cellpadding="0" cellspacing="0" width=
      "100%" summary="Navigation table">
        <tr>
          <td align="left">&#160;<a title="DocBook" href=
          "docbook.html"><img src="figures/nav-home.png" alt="Home"
          border="0"></a>&#160;<a title="Parsing DocBook Documents"
          href="ch03.html"><img src="figures/nav-prev.png" alt=
          "Prev" border="0"></a>&#160;<a title=
          "Part&#160;I.&#160;Introduction" href="part1.html"><img
          src="figures/nav-up.png" alt="Up" border="0"></a>&#160;<a
          title="Customizing DocBook" href="ch05.html"><img src=
          "figures/nav-next.png" alt="Next" border="0"></a></td>

          <td align="right"><i>DocBook: The Definitive Guide</i>
          Version 2.0.8 <span class="alpha-version">(<a href=
          "co01.html"><em>Alpha</em></a>)</span></td>
        </tr>
      </table>
    </div>

    <div class="chapter" lang="en">
      <div class="titlepage">
        <div>
          <a name="ch-publish"></a>

          <div class="component-title">
            <h1 class="label">4</h1>

            <h1 class="title">Publishing DocBook Documents</h1>
          </div>
        </div>

        <div>
          <p class="releaseinfo">$Revision: 1.7 $</p>
        </div>

        <div>
          <p class="pubdate">$Date: 2002/12/29 20:24:04 $</p>
        </div>
        <hr class="component-separator">
      </div>

      <p><a class="indexterm" name="publishDocBookch04"></a> <a
      class="indexterm" name="DocBookpublishch04"></a> <a class=
      "indexterm" name="d0e9147"></a> <a class="indexterm" name=
      "d0e9153"></a> Creating and editing SGML/XML documents is
      usually only half the battle. After you've composed your
      document, you'll want to publish it. Publishing, for our
      purposes, means either print or web publishing. For SGML and
      XML documents, this is usually accomplished with some kind of
      <i>stylesheet</i>. In the (not too distant) future, you may
      be able to publish an XML document on the Web by simply
      putting it online with a stylesheet, but for now you'll
      probably have to translate your document into HTML.</p>

      <p><a class="indexterm" name="d0e9182"></a> <a class=
      "indexterm" name="d0e9188"></a> <a class="indexterm" name=
      "d0e9192"></a> There are many ways, using both free and
      commercial tools, to publish SGML documents. In this chapter,
      we're going to survey a number of possibilities, and then
      look at just one solution in detail: <a href=
      "http://www.jclark.com/jade/" target="_top">Jade</a> and the
      <a href="http://nwalsh.com/docbook/dsssl/" target=
      "_top">Modular DocBook Stylesheets.</a> We used jade to
      produce this book and to produce the online versions on the
      CD-ROM; it is also being deployed in other projects such as
      <a href="http://www.sgmltools.org/" target=
      "_top"><tt>&lt;SGML&gt;&amp;tools;</tt>,</a> which originated
      with the Linux Documentation Project.</p>

      <p>For a brief survey of other tools, see <a href="appd.html"
      title="Resources">Appendix&#160;D</a>.</p>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <h2 class="title" style="clear: both"><a name=
            "d0e9217"></a>A Survey of Stylesheet Languages</h2>
          </div>
        </div>

        <p><a class="indexterm" name="d0e9222"></a> <a class=
        "indexterm" name="d0e9228"></a> Over the years, a number of
        attempts have been made to produce a standard stylesheet
        language and, failing that, a large number of proprietary
        languages have been developed.</p>

        <div class="variablelist">
          <dl>
            <dt><span class="term">FOSIs</span></dt>

            <dd>
              <p><a class="indexterm" name="d0e9241"></a> <a class=
              "indexterm" name="d0e9245"></a> <a class="indexterm"
              name="d0e9251"></a> First, the U.S. Department of
              Defense, in an attempt to standardize stylesheets
              across military branches, created the <i>Output
              Specification</i>, which is defined in
              MIL-PRF-28001C, <i>Markup Requirements and Generic
              Style Specification for Electronic Printed Output and
              Exchange of Text</i>.<sup>[<a name="d0e9264" href=
              "#ftn.d0e9264">14</a>]</sup></p>

              <p><a class="indexterm" name="d0e9274"></a> <a class=
              "indexterm" name="d0e9278"></a> Commonly called FOSIs
              (for Formatting Output Specification Instances), they
              are supported by a few products including ADEPT
              Publisher by <a href="http://www.arbortext.com/"
              target="_top">Arbortext</a> and DL Composer by <a
              href="http://www.datalogics.com/" target=
              "_top">Datalogics</a>.</p>
            </dd>

            <dt><span class="term">DSSSL</span></dt>

            <dd>
              <p><a class="indexterm" name="d0e9294"></a> <a class=
              "indexterm" name="d0e9298"></a> <a class="indexterm"
              name="d0e9304"></a> <a class="indexterm" name=
              "d0e9310"></a> Next, the International Organization
              for Standardization (ISO) created DSSSL, the Document
              Style Semantics and Specification Language. Subsets
              of DSSSL are supported by Jade and a few other tools,
              but it never achieved widespread support.</p>
            </dd>

            <dt><span class="term">CSS</span></dt>

            <dd>
              <p><a class="indexterm" name="d0e9331"></a> <a class=
              "indexterm" name="d0e9335"></a> <a class="indexterm"
              name="d0e9341"></a> The W3C CSS Working Group created
              CSS as a style attachment language for HTML, and,
              more recently, XML.</p>
            </dd>

            <dt><span class="term">XSL</span></dt>

            <dd>
              <p><a class="indexterm" name="d0e9365"></a> <a class=
              "indexterm" name="d0e9369"></a> <a class="indexterm"
              name="d0e9375"></a> Most recently, the XML effort has
              identified a standard Extensible Style Language (XSL)
              as a requirement. The W3C XSL Working Group is
              currently pursuing that effort.</p>
            </dd>
          </dl>
        </div>

        <div class="section" lang="en">
          <div class="titlepage">
            <div>
              <h3 class="title"><a name="d0e9393"></a>Stylesheet
              Examples</h3>
            </div>
          </div>

          <p><a class="indexterm" name="stylsheetsch04"></a> By way
          of comparison, here's an example of each of the standard
          style languages. In each case, the stylesheet fragment
          shown contains the rules that reasonably formatted the
          following paragraph:</p>
<pre class="screen">
&lt;para&gt;
This is an example paragraph. It should be presented in a
reasonable body font. &lt;emphasis&gt;Emphasized&lt;/emphasis&gt; words
should be printed in italics. A single level of 
&lt;emphasis&gt;Nested &lt;emphasis&gt;emphasis&lt;/emphasis&gt; should also
be supported.&lt;/emphasis&gt;
&lt;/para&gt;
</pre>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name="d0e9406"></a>FOSI
                stylesheet</h4>
              </div>
            </div>

            <p><a class="indexterm" name="d0e9413"></a> <a class=
            "indexterm" name="d0e9419"></a> <a class="indexterm"
            name="d0e9425"></a> <a class="indexterm" name=
            "d0e9429"></a> FOSIs are SGML documents. The element in
            the FOSI that controls the presentation of specific
            elements is the <tt class="sgmltag-element">e-i-c</tt>
            (element in context) element. A sample FOSI fragment is
            shown in <a href="ch04.html#ex-fosi" title=
            "Example&#160;4.1.&#160;A Fragment of a FOSI Stylesheet">Example&#160;4.1</a>.</p>

            <div class="example">
              <a name="ex-fosi"></a>

              <p class="title"><b>Example&#160;4.1.&#160;A Fragment
              of a FOSI Stylesheet</b></p>
<pre class="programlisting">
&lt;e-i-c gi="para"&gt;
  &lt;charlist&gt;
    &lt;textbrk startln="1" endln="1"&gt;
  &lt;/charlist&gt;
&lt;/e-i-c&gt;

&lt;e-i-c gi="emphasis"&gt;
  &lt;charlist inherit="1"&gt;
    &lt;font posture="italic"&gt;
  &lt;/charlist&gt;
&lt;/e-i-c&gt;

&lt;e-i-c gi="emphasis" context="emphasis"&gt;
  &lt;charlist inherit="1"&gt;
    &lt;font posture="upright"&gt;
  &lt;/charlist&gt;
&lt;/e-i-c&gt;
</pre>
            </div>
          </div>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name="d0e9458"></a>DSSSL
                stylesheet</h4>
              </div>
            </div>

            <p><a class="indexterm" name="d0e9465"></a> <a class=
            "indexterm" name="d0e9473"></a> DSSSL stylesheets are
            written in a Scheme-like language (see <a href=
            "ch04.html#scheme" title="Scheme">the section called
            &#8220;Scheme&#8221;</a> later in this chapter). It is
            the <tt>element</tt> function that controls the
            presentation of individual elements. See the example in
            <a href="ch04.html#ex-dsssl" title=
            "Example&#160;4.2.&#160;A Fragment of a DSSSL Stylesheet">Example&#160;4.2</a>.</p>

            <div class="example">
              <a name="ex-dsssl"></a>

              <p class="title"><b>Example&#160;4.2.&#160;A Fragment
              of a DSSSL Stylesheet</b></p>
<pre class="programlisting">
(element para
  (make paragraph
    (process-children)))

(element emphasis
  (make sequence
    font-posture: 'italic
    (process-children)))

(element (emphasis emphasis)
  (make sequence
    font-posture: 'upright
    (process-children)))
</pre>
            </div>
          </div>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name="d0e9497"></a>CSS
                stylesheet</h4>
              </div>
            </div>

            <p><a class="indexterm" name="d0e9504"></a> CSS
            stylesheets consist of selectors and formatting
            properties, as shown in <a href="ch04.html#ex-css"
            title=
            "Example&#160;4.3.&#160;A Fragment of a CSS Stylesheet">Example&#160;4.3</a>.</p>

            <div class="example">
              <a name="ex-css"></a>

              <p class="title"><b>Example&#160;4.3.&#160;A Fragment
              of a CSS Stylesheet</b></p>
<pre class="programlisting">
para              { display: block }
emphasis          { display: inline;
                    font-style: italic; }
emphasis emphasis { display: inline;
                    font-style: upright; }
</pre>
            </div>
          </div>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name="d0e9523"></a>XSL
                stylesheet</h4>
              </div>
            </div>

            <p><a class="indexterm" name="d0e9530"></a> XSL
            stylesheets are XML documents, as shown in <a href=
            "ch04.html#ex-xsl" title=
            "Example&#160;4.4.&#160;A Fragment of an XSL Stylesheet">Example&#160;4.4</a>. The element in the XSL stylesheet
            that controls the presentation of specific elements is
            the <tt class="sgmltag-element">xsl:template</tt>
            element.</p>

            <div class="example">
              <a name="ex-xsl"></a>

              <p class="title"><b>Example&#160;4.4.&#160;A Fragment
              of an XSL Stylesheet</b></p>
<pre class="programlisting">
&lt;?xml version='1.0'?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/XSL/Transform/1.0"
                xmlns:fo="http://www.w3.org/XSL/Format/1.0"&gt;

&lt;xsl:template match="para"&gt;   
  &lt;fo:block&gt;
    &lt;xsl:apply-templates/&gt;  
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;  

&lt;xsl:template match="emphasis"&gt;
  &lt;fo:sequence font-style="italic"&gt;
    &lt;xsl:apply-templates/&gt;  
  &lt;/fo:sequence&gt;
&lt;/xsl:template&gt;  

&lt;xsl:template match="emphasis/emphasis"&gt;
  &lt;fo:sequence font-style="upright"&gt;
    &lt;xsl:apply-templates/&gt;  
  &lt;/fo:sequence&gt;
&lt;/xsl:template&gt;  

&lt;/xsl:stylesheet&gt;
</pre>
            </div>
          </div>
        </div>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <h2 class="title" style="clear: both"><a name=
            "jade"></a>Using Jade and DSSSL to Publish DocBook
            Documents</h2>
          </div>
        </div>

        <p><a class="indexterm" name="d0e9566"></a> <a class=
        "indexterm" name="d0e9572"></a> <a class="indexterm" name=
        "d0e9578"></a> <a class="indexterm" name="d0e9584"></a> <a
        class="indexterm" name="d0e9592"></a> Jade is a free tool
        that applies <a href="http://www.jclark.com/dsssl/" target=
        "_top">DSSSL</a> stylesheets to SGML and XML documents. As
        distributed, Jade can output RTF, TeX, MIF, and SGML. The
        SGML backend can be used for SGML to SGML transformations
        (for example, DocBook to HTML).</p>

        <p>A complete set of DSSSL stylesheets for creating print
        and HTML output from DocBook is included on the CD-ROM.
        More information about obtaining and installing Jade
        appears in <a href="appa.html" title=
        "Installation">Appendix&#160;A</a>. <a class="indexterm"
        name="d0e9643"></a></p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <h2 class="title" style="clear: both"><a name=
            "dsssl"></a>A Brief Introduction to DSSSL</h2>
          </div>
        </div>

        <p>DSSSL is a stylesheet language for both print and online
        rendering. The acronym stands for <i>Document Style
        Semantics and Specification Language</i>. It is defined by
        ISO/IEC 10179:1996. For more general information about
        DSSSL, see <a href="http://www.jclark.com/dsssl/" target=
        "_top">the DSSSL Page</a>.</p>

        <div class="section" lang="en">
          <div class="titlepage">
            <div>
              <h3 class="title"><a name="scheme"></a>Scheme</h3>
            </div>
          </div>

          <p><a class="indexterm" name="d0e9678"></a> <a class=
          "indexterm" name="d0e9684"></a> <a class="indexterm"
          name="d0e9688"></a> The DSSSL expression language is
          Scheme, a variant of Lisp. Lisp is a functional
          programming language with a remarkably regular syntax.
          Every expression looks like this:</p>
<pre class="screen">
(<i><tt>operator</tt></i> [arg1] [arg2] ... [arg<i><tt>n</tt></i>] )
</pre>
          <a class="indexterm" name="d0e9714"></a> This is called
          &#8220;prefix&#8221; syntax because the operator comes
          before its arguments.<br>
          <br>

          <p>In Scheme, the expression that subtracts 2 from 3, is
          <tt>(- 3 2)</tt>. And <tt>(+ (- 3 2) (* 2 4))</tt> is 9.
          While the prefix syntax and the parentheses may take a
          bit of getting used to, Scheme is not hard to learn, in
          part because there are no exceptions to the syntax.</p>
        </div>

        <div class="section" lang="en">
          <div class="titlepage">
            <div>
              <h3 class="title"><a name="d0e9731"></a>DSSSL
              Stylesheets</h3>
            </div>
          </div>

          <p><a class="indexterm" name="d0e9738"></a> <a class=
          "indexterm" name="d0e9744"></a> A complete DSSSL
          stylesheet is shown in <a href=
          "ch04.html#dsssl.stylesheet" title=
          "Example&#160;4.5.&#160;A Complete DSSSL Stylesheet">Example&#160;4.5</a>.
          After only a brief examination of the stylesheet, you'll
          probably begin to have a feel for how it works. For each
          element in the document, there is an element rule that
          describes how you should format that element. The goal of
          the rest of this chapter is to make it possible for you
          to read, understand, and even write stylesheets at this
          level of complexity.</p>

          <div class="example">
            <a name="dsssl.stylesheet"></a>

            <p class="title"><b>Example&#160;4.5.&#160;A Complete
            DSSSL Stylesheet</b></p>
<pre class="programlisting">
&lt;!DOCTYPE style-sheet PUBLIC "-//James Clark//DTD DSSSL Style Sheet//EN"&gt;

&lt;style-sheet&gt;
&lt;style-specification&gt;
&lt;style-specification-body&gt;

(element chapter
  (make simple-page-sequence
    top-margin: 1in
    bottom-margin: 1in
    left-margin: 1in
    right-margin: 1in
    font-size: 12pt
    line-spacing: 14pt
    min-leading: 0pt
    (process-children)))

(element title
  (make paragraph
    font-weight: 'bold
    font-size: 18pt
    (process-children)))

(element para
  (make paragraph
    space-before: 8pt
    (process-children)))

(element emphasis
  (if (equal? (attribute-string "role") "strong")
      (make sequence
    font-weight: 'bold
    (process-children))
      (make sequence
    font-posture: 'italic
    (process-children))))

(element (emphasis emphasis)
  (make sequence
    font-posture: 'upright
    (process-children)))

(define (super-sub-script plus-or-minus
               #!optional (sosofo (process-children)))
  (make sequence
    font-size: (* (inherited-font-size) 0.8)
    position-point-shift: (plus-or-minus (* (inherited-font-size) 0.4))
    sosofo))

(element superscript (super-sub-script +))
(element subscript (super-sub-script -))

&lt;/style-specification-body&gt;
&lt;/style-specification&gt;
&lt;/style-sheet&gt;
</pre>
          </div>

          <p><a class="indexterm" name="d0e9765"></a> This
          stylesheet is capable of formatting simple DocBook
          documents like the one shown in <a href=
          "ch04.html#simple.document" title=
          "Example&#160;4.6.&#160;A Simple DocBook Document">Example&#160;4.6</a>.</p>

          <div class="example">
            <a name="simple.document"></a>

            <p class="title"><b>Example&#160;4.6.&#160;A Simple
            DocBook Document</b></p>
<pre class="programlisting">
&lt;!DOCTYPE chapter PUBLIC "-//OASIS//DTD Docbook XML V4.1.2//EN"
                  "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd"&gt;
&lt;chapter&gt;&lt;title&gt;Test Chapter&lt;/title&gt;
&lt;para&gt;
This is a paragraph in the test chapter. It is unremarkable in
every regard. This is a paragraph in the test chapter. It is
unremarkable in every regard. This is a paragraph in the test
chapter. It is unremarkable in every regard.
&lt;/para&gt;
&lt;para&gt;
&lt;emphasis role="bold"&gt;This&lt;/emphasis&gt; paragraph contains
&lt;emphasis&gt;some &lt;emphasis&gt;emphasized&lt;/emphasis&gt; text&lt;/emphasis&gt;
and a &lt;superscript&gt;super&lt;/superscript&gt;script
and a &lt;subscript&gt;sub&lt;/subscript&gt;script.
&lt;/para&gt;
&lt;para&gt;
This is a paragraph in the test chapter. It is unremarkable in
every regard. This is a paragraph in the test chapter. It is
unremarkable in every regard. This is a paragraph in the test
chapter. It is unremarkable in every regard.
&lt;/para&gt;
&lt;/chapter&gt;

</pre>
          </div>

          <p>The result of formatting a simple document with this
          stylesheet can be seen in <a href=
          "ch04.html#simple.document.formatted" title=
          "Figure&#160;4.1.&#160;The formatted simple document">Figure&#160;4.1</a>.</p>

          <div class="figure">
            <a name="simple.document.formatted"></a>

            <p class="title"><b>Figure&#160;4.1.&#160;The formatted
            simple document</b></p>

            <div>
              <img src="figures/simple-page.png" alt=
              "The formatted simple document">
            </div>
          </div>

          <p>We'll take a closer look at this stylesheet after
          you've learned a little more DSSSL.</p>
        </div>

        <div class="section" lang="en">
          <div class="titlepage">
            <div>
              <h3 class="title"><a name="d0e9793"></a>DSSSL
              Stylesheets Are SGML Documents</h3>
            </div>
          </div>

          <p><a class="indexterm" name="d0e9803"></a> <a class=
          "indexterm" name="d0e9809"></a> <a class="indexterm"
          name="d0e9815"></a> One of the first things that may
          strike you about DSSSL stylesheets (aside from all the
          parentheses), is the fact that the stylesheet itself is
          an SGML document! This means that you have all the power
          of SGML documents at your disposal in DSSSL stylesheets.
          In particular, you can use entities and marked sections
          to build a modular stylesheet.</p>

          <p><a class="indexterm" name="d0e9835"></a> <a class=
          "indexterm" name="d0e9841"></a> In fact, DSSSL
          stylesheets are defined so that they correspond to a
          particular <i>architecture</i>. This means that you can
          change the DTD used by stylesheets within the bounds of
          the architecture. A complete discussion of document
          architectures is beyond the scope of this book, but we'll
          show you one way to take advantage of them in your DSSSL
          stylesheets in <a href="ch04.html#dsssl.arch" title=
          "The DSSSL Architecture">the section called &#8220;The
          DSSSL Architecture&#8221;</a> later in the chapter.</p>
        </div>

        <div class="section" lang="en">
          <div class="titlepage">
            <div>
              <h3 class="title"><a name="d0e9861"></a>DSSSL
              Processing Model</h3>
            </div>
          </div>

          <p><a class="indexterm" name="d0e9868"></a> <a class=
          "indexterm" name="d0e9872"></a> <a class="indexterm"
          name="d0e9876"></a> A DSSSL processor builds a tree out
          of the source document. Each element in the source
          document becomes a node in the tree (processing
          instructions and other constructs become nodes as well).
          Processing the source tree begins with the root rule and
          continues until there are no more nodes to process.</p>
        </div>

        <div class="section" lang="en">
          <div class="titlepage">
            <div>
              <h3 class="title"><a name="d0e9883"></a>Global
              Variables and Side Effects</h3>
            </div>
          </div>

          <p><a class="indexterm" name="d0e9888"></a> <a class=
          "indexterm" name="d0e9894"></a> There aren't any global
          variables or side effects. It can be difficult to come to
          grips with this, especially if you're just starting
          out.</p>

          <p><a class="indexterm" name="d0e9900"></a> <a class=
          "indexterm" name="d0e9906"></a> It is possible to <a
          href="ch04.html#dsssl.expr.define" title=
          "Define expressions">define constants and functions</a>
          and to create local variables with <a href=
          "ch04.html#dsssl.expr.let" title=
          "Let expressions"><tt>let</tt> expressions</a>, but you
          can't create any global variables or change anything
          after you've defined it.</p>
        </div>

        <div class="section" lang="en">
          <div class="titlepage">
            <div>
              <h3 class="title"><a name="d0e9919"></a>DSSSL
              Expressions</h3>
            </div>
          </div>

          <p><a class="indexterm" name="d0e9926"></a> DSSSL has a
          rich vocabulary of expressions for dealing with all of
          the intricacies of formatting. Many, but by no means all
          of them, are supported by Jade. In this introduction,
          we'll cover only a few of the most common.</p>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name=
                "dsssl.expr.element"></a>Element expressions</h4>
              </div>
            </div>

            <p><a class="indexterm" name="d0e9938"></a> <a class=
            "indexterm" name="d0e9946"></a> <a class="indexterm"
            name="d0e9952"></a> Element expressions, which define
            the rules for formatting particular elements, make up
            the bulk of most DSSSL stylesheets. A simple element
            rule can be seen in <a href="ch04.html#ex.d.simple"
            title=
            "Example&#160;4.7.&#160;A Simple DSSSL Rule">Example&#160;4.7</a>.
            This rule says that a <a href="para.html"><tt class=
            "sgmltag-element">para</tt></a> element should be
            formatted by making a paragraph (see <a href=
            "ch04.html#dsssl.expr.make" title=
            "Make expressions">the section called &#8220;Make
            expressions&#8221;</a>).</p>

            <div class="example">
              <a name="ex.d.simple"></a>

              <p class="title"><b>Example&#160;4.7.&#160;A Simple
              DSSSL Rule</b></p>
<pre class="screen">
(element para
  (make paragraph
    space-before: 8pt
    (process-children)))
</pre>
            </div>

            <p><a class="indexterm" name="d0e9978"></a> An element
            expression can be made more specific by specifying an
            element and its ancestors instead of just specifying an
            element. The rule <tt>(element title ...)</tt> applies
            to all <a href="title.html"><tt class=
            "sgmltag-element">Title</tt></a> elements, but a rule
            that begins <tt>(element (figure title) ...)</tt>
            applies only to <a href="title.html"><tt class=
            "sgmltag-element">Title</tt></a> elements that are
            immediate children of <a href="figure.html"><tt class=
            "sgmltag-element">Figure</tt></a> elements.</p>

            <p>If several rules apply, the most specific rule is
            used.</p>

            <p>When a rule is used, the node in the source tree
            that was matched becomes the &#8220;current node&#8221;
            while that element expression is being processed.</p>
          </div>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name=
                "dsssl.expr.make"></a>Make expressions</h4>
              </div>
            </div>

            <p><a class="indexterm" name="d0e10009"></a> <a class=
            "indexterm" name="d0e10013"></a> A make expression
            specifies the characteristics of a &#8220;flow
            object.&#8221; Flow objects are abstract
            representations of content (paragraphs, rules, tables,
            and so on). The expression:</p>
<pre class="screen">
(make paragraph
  font-size: 12pt
  line-spacing: 14pt ...)
</pre>
            specifies that the content that goes &#8220;here&#8221;
            is to be placed into a paragraph flow object with a
            font-size of 12pt and a line-spacing of 14pt (all of
            the unspecified characteristics of the flow object are
            defaulted in the appropriate way). <br>
            <br>

            <p>They're called flow objects because DSSSL, in its
            full generality, allows you to specify the
            characteristics of a sequence of flow objects and a set
            of areas on the physical page where you can place
            content. The content of the flow objects is then
            &#8220;poured on to&#8221; (or flows in to) the areas
            on the page(s).</p>

            <p><a class="indexterm" name="d0e10038"></a> <a class=
            "indexterm" name="d0e10042"></a> In most cases, it's
            sufficient to think of the make expressions as
            constructing the flow objects, but they really only
            specify the <span class=
            "emphasis"><em>characteristics</em></span> of the flow
            objects. This detail is apparent in one of the most
            common and initially confusing pieces of DSSSL jargon:
            the <i>sosofo</i>. Sosofo stands for a
            &#8220;specification of a sequence of flow
            objects.&#8221; All this means is that processing a
            document may result in a nested set of <tt>make</tt>
            expressions (in other words, the paragraph may contain
            a table that contains rows that contain cells that
            contain paragraphs, and so on).</p>

            <p>The general form of a <tt>make</tt> expression
            is:</p>
<pre class="screen">
(make <i><tt>flow-object-name</tt></i>
  <i><tt>keyword1:</tt></i> <i><tt>value1</tt></i>
  <i><tt>keyword2:</tt></i> <i><tt>value2</tt></i>
  ...
  <i><tt>keywordn:</tt></i> <i><tt>valuen</tt></i>
  (<i><tt>content-expression</tt></i>))
</pre>
            <br>
            <br>

            <p><a class="indexterm" name="d0e10095"></a> Keyword
            arguments specify the characteristics of the flow
            object. The specific characteristics you use depends on
            the flow object. The <i><tt>content-expression</tt></i>
            can vary; it is usually another make expression or one
            of the <a href="ch04.html#dsssl.expr.proc" title=
            "Processing expressions">processing
            expressions</a>.</p>

            <p><a class="indexterm" name="d0e10109"></a> Some
            common flow objects in the print stylesheet are:</p>

            <div class="variablelist">
              <dl>
                <dt><span class=
                "term"><tt>simple-page-sequence</tt></span></dt>

                <dd>
                  <p><a class="indexterm" name="d0e10121"></a>
                  Contains a sequence of pages. The keyword
                  arguments of this flow object let you specify
                  margins, headers and footers, and other
                  page-related characteristics. Print stylesheets
                  should always produce one or more
                  <tt>simple-page-sequence</tt> flow objects.</p>

                  <p>Nesting <tt>simple-page-sequence</tt> does not
                  work. Characteristics on the inner sequences are
                  ignored.</p>
                </dd>

                <dt><span class=
                "term"><tt>paragraph</tt></span></dt>

                <dd>
                  <p><a class="indexterm" name="d0e10142"></a> <a
                  class="indexterm" name="d0e10148"></a> A
                  paragraph is used for any block of text. This may
                  include not only paragraphs in the source
                  document, but also titles, the terms in a
                  definition list, glossary entries, and so on.
                  Paragraphs in DSSSL can be nested.</p>
                </dd>

                <dt><span class=
                "term"><tt>sequence</tt></span></dt>

                <dd>
                  <p><a class="indexterm" name="d0e10164"></a> A
                  sequence is a wrapper. It is most frequently used
                  to change inherited characteristics (like font
                  style) of a set of flow objects without
                  introducing other semantics (such as line
                  breaks).</p>
                </dd>

                <dt><span class="term"><tt>score</tt></span></dt>

                <dd>
                  <p><a class="indexterm" name="d0e10177"></a> A
                  score flow object creates underlining,
                  strike-throughs, or overlining.</p>
                </dd>

                <dt><span class="term"><tt>table</tt></span></dt>

                <dd>
                  <p><a class="indexterm" name="d0e10188"></a> A
                  table flow object creates a table of rows and
                  cells.</p>
                </dd>
              </dl>
            </div>

            <p><a class="indexterm" name="d0e10196"></a> The HTML
            stylesheet uses the SGML backend, which has a different
            selection of flow objects.</p>

            <div class="variablelist">
              <dl>
                <dt><span class="term"><tt>element</tt></span></dt>

                <dd>
                  <p><a class="indexterm" name="d0e10216"></a> <a
                  class="indexterm" name="d0e10220"></a> Creates an
                  element. The content of this <tt>make</tt>
                  expression will appear between the start and end
                  tags. The expression:</p>
<pre class="screen">
(make element gi: "H1" 
        (literal "Title"))
</pre>

                  <p>produces
                  <tt>&lt;H1&gt;Title&lt;/H1&gt;</tt>.</p>
                </dd>

                <dt><span class=
                "term"><tt>empty-element</tt></span></dt>

                <dd>
                  <p><a class="indexterm" name="d0e10243"></a>
                  Creates an empty element that may not have
                  content. The expression:</p>
<pre class="screen">
(make empty-element gi: "BR"
     attributes: '(("CLEAR" "ALL")))
</pre>

                  <p>produces <tt>&lt;BR CLEAR="ALL"&gt;</tt>.</p>
                </dd>

                <dt><span class=
                "term"><tt>sequence</tt></span></dt>

                <dd>
                  <p><a class="indexterm" name="d0e10263"></a>
                  Produces no output in of itself as a wrapper, but
                  is still required in DSSSL contexts in which you
                  want to output several flow objects but only one
                  object top-level object may be returned.</p>
                </dd>

                <dt><span class=
                "term"><tt>entity-ref</tt></span></dt>

                <dd>
                  <p><a class="indexterm" name="d0e10279"></a> <a
                  class="indexterm" name="d0e10285"></a> <a class=
                  "indexterm" name="d0e10291"></a> Inserts an
                  entity reference. The expression:</p>
<pre class="screen">
(make entity-ref name: "nbsp")
</pre>

                  <p>produces <tt>&amp;nbsp;</tt>.</p>
                </dd>
              </dl>
            </div>

            <p><a class="indexterm" name="d0e10304"></a> <a class=
            "indexterm" name="d0e10312"></a> <a class="indexterm"
            name="d0e10316"></a> In both stylesheets, a completely
            empty flow object is constructed with
            <tt>(empty-sosofo)</tt>.</p>
          </div>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name=
                "dsssl.expr.data"></a>Selecting data</h4>
              </div>
            </div>

            <p><a class="indexterm" name="d0e10330"></a> <a class=
            "indexterm" name="d0e10334"></a> Extracting parts of
            the source document can be accomplished with these
            functions:</p>

            <div class="variablelist">
              <dl>
                <dt><span class="term"><tt>(data
                <i><tt>nd</tt></i>)</tt></span></dt>

                <dd>
                  <p>Returns all of the character data from
                  <i><tt>nd</tt></i> as a string.</p>
                </dd>

                <dt><span class="term"><tt>(attribute-string
                "<i><tt>attr</tt></i>"
                <i><tt>nd</tt></i>)</tt></span></dt>

                <dd>
                  <p>Returns the value of the <i><tt>attr</tt></i>
                  attribute of <i><tt>nd</tt></i>.</p>
                </dd>

                <dt><span class=
                "term"><tt>(inherited-attribute-string
                "<i><tt>attr</tt></i>"
                <i><tt>nd</tt></i>)</tt></span></dt>

                <dd>
                  <p>Returns the value of the <i><tt>attr</tt></i>
                  attribute of <i><tt>nd</tt></i>. If that
                  attribute is not specified on <i><tt>nd</tt></i>,
                  it searches up the hierarchy for the first
                  ancestor element that does set the attribute, and
                  returns its value.</p>
                </dd>
              </dl>
            </div>
          </div>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name=
                "dsssl.expr.nodes"></a>Selecting elements</h4>
              </div>
            </div>

            <p><a class="indexterm" name="d0e10398"></a> <a class=
            "indexterm" name="d0e10404"></a> <a class="indexterm"
            name="d0e10408"></a> <a class="indexterm" name=
            "d0e10414"></a> <a class="indexterm" name=
            "d0e10422"></a> A common requirement of formatting is
            the ability to reorder content. In order to do this,
            you must be able to select other elements in the tree
            for processing. DSSSL provides a number of functions
            that select other elements. These functions all return
            a list of nodes.</p>

            <div class="variablelist">
              <dl>
                <dt><span class=
                "term"><tt>(current-node)</tt></span></dt>

                <dd>
                  <p>Returns the current node.</p>
                </dd>

                <dt><span class="term"><tt>(children
                <i><tt>nd</tt></i>)</tt></span></dt>

                <dd>
                  <p>Returns the children of
                  <i><tt>nd</tt></i>.</p>
                </dd>

                <dt><span class="term"><tt>(descendants
                <i><tt>nd</tt></i>)</tt></span></dt>

                <dd>
                  <p>Returns the descendants of <i><tt>nd</tt></i>
                  (the children of <i><tt>nd</tt></i> and all their
                  children's children, and so on).</p>
                </dd>

                <dt><span class="term"><tt>(parent
                <i><tt>nd</tt></i>)</tt></span></dt>

                <dd>
                  <p>Returns the parent of <i><tt>nd</tt></i>.</p>
                </dd>

                <dt><span class="term"><tt>(ancestor
                "<i><tt>name</tt></i>"
                <i><tt>nd</tt></i>)</tt></span></dt>

                <dd>
                  <p>Returns the first ancestor of
                  <i><tt>nd</tt></i> named
                  <i><tt>name</tt></i>.</p>
                </dd>

                <dt><span class="term"><tt>(element-with-id
                "<i><tt>id</tt></i>")</tt></span></dt>

                <dd>
                  <p>Returns the element in the document with the
                  ID <i><tt>id</tt></i>, if such an element
                  exists.</p>
                </dd>

                <dt><span class="term"><tt>(select-elements
                <i><tt>node-list</tt></i>
                "<i><tt>name</tt></i>")</tt></span></dt>

                <dd>
                  <p>Returns all of the elements of the
                  <i><tt>node-list</tt></i> that have the name
                  <i><tt>name</tt></i>. For example,
                  <tt>(select-elements (descendants (current-node))
                  "para")</tt> returns a list of all the paragraphs
                  that are descendants of the current node.</p>
                </dd>

                <dt><span class=
                "term"><tt>(empty-node-list)</tt></span></dt>

                <dd>
                  <p>Returns a node list that contains no
                  nodes.</p>
                </dd>
              </dl>
            </div>

            <p>Other functions allow you to manipulate node
            lists.</p>

            <div class="variablelist">
              <dl>
                <dt><span class="term"><tt>(node-list-empty?
                <i><tt>nl</tt></i>)</tt></span></dt>

                <dd>
                  <p>Returns true if (and only if)
                  <i><tt>nl</tt></i> is an empty node list.</p>
                </dd>

                <dt><span class="term"><tt>(node-list-length
                <i><tt>nl</tt></i>)</tt></span></dt>

                <dd>
                  <p>Returns the number of nodes in
                  <i><tt>nl</tt></i>.</p>
                </dd>

                <dt><span class="term"><tt>(node-list-first
                <i><tt>nl</tt></i>)</tt></span></dt>

                <dd>
                  <p>Returns a node list that consists of the
                  single node that is the first node in
                  <i><tt>nl</tt></i>.</p>
                </dd>

                <dt><span class="term"><tt>(node-list-rest
                <i><tt>nl</tt></i>)</tt></span></dt>

                <dd>
                  <p>Returns a node list that contains all of the
                  nodes in <i><tt>nl</tt></i> except the first
                  node.</p>
                </dd>
              </dl>
            </div>

            <p><a class="indexterm" name="d0e10600"></a> <a class=
            "indexterm" name="d0e10606"></a> <a class="indexterm"
            name="d0e10612"></a> There are many other expressions
            for manipulating nodes and node lists.</p>
          </div>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name=
                "dsssl.expr.proc"></a>Processing expressions</h4>
              </div>
            </div>

            <p><a class="indexterm" name="d0e10623"></a> Processing
            expressions control which elements in the document will
            be processed and in what order. Processing an element
            is performed by finding a matching element rule and
            using that rule.</p>

            <div class="variablelist">
              <dl>
                <dt><span class=
                "term"><tt>(process-children)</tt></span></dt>

                <dd>
                  <p>Processes all of the children of the current
                  node. In most cases, if no process expression is
                  given, processing the children is the default
                  behavior.</p>
                </dd>

                <dt><span class="term"><tt>(process-node-list
                <i><tt>nl</tt></i>)</tt></span></dt>

                <dd>
                  <p>Processes each of the elements in
                  <i><tt>nl</tt></i>.</p>
                </dd>
              </dl>
            </div>
          </div>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name=
                "dsssl.expr.define"></a>Define expressions</h4>
              </div>
            </div>

            <p><a class="indexterm" name="d0e10653"></a> <a class=
            "indexterm" name="d0e10659"></a> <a class="indexterm"
            name="d0e10663"></a> You can declare your own functions
            and constants in DSSSL. The general form of a function
            declaration is:</p>
<pre class="screen">
(define (<i><tt>function</tt></i> <i><tt>args</tt></i>)
  <i><tt>function-body</tt></i>)
</pre>
            A constant declaration is: 
<pre class="screen">
(define <i><tt>constant</tt></i>
  <i><tt>constant-function-body</tt></i>)
</pre>
            <br>
            <br>

            <p>The distinction between constants and functions is
            that the body of a constant is evaluated when the
            definition occurs, while functions are evaluated when
            they are used.</p>
          </div>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name=
                "dsssl.expr.conditional"></a>Conditionals</h4>
              </div>
            </div>

            <p><a class="indexterm" name="d0e10700"></a> <a class=
            "indexterm" name="d0e10704"></a> <a class="indexterm"
            name="d0e10708"></a> <a class="indexterm" name=
            "d0e10712"></a> In DSSSL, the constant <tt>#t</tt>
            represents true and <tt>#f</tt> false. There are
            several ways to test conditions and take action in
            DSSSL.</p>

            <div class="variablelist">
              <dl>
                <dt><span class="term"><tt>if</tt></span></dt>

                <dd>
                  <p><a class="indexterm" name="d0e10738"></a> The
                  form of an <tt>if</tt> expression is:</p>
<pre class="screen">
(if <i><tt>condition</tt></i>
  <i><tt>true-expression</tt></i>
  <i><tt>false-expression</tt></i>)
</pre>
                  <br>
                  <br>

                  <p>If the condition is true, the
                  <i><tt>true-expression</tt></i> is evaluated,
                  otherwise the <i><tt>false-expression</tt></i> is
                  evaluated. You must always provide an expression
                  to be evaluated when the condition is not met. If
                  you want to produce nothing, use
                  <tt>(empty-sosofo)</tt>.</p>
                </dd>

                <dt><span class="term"><tt>case</tt></span></dt>

                <dd>
                  <p><a class="indexterm" name="d0e10775"></a>
                  <tt>case</tt> selects from among several
                  alternatives:</p>
<pre class="screen">
(case <i><tt>expression</tt></i>
  ((<i><tt>constant1</tt></i>) (<i><tt>expression1</tt></i>)
  ((<i><tt>constant2</tt></i>) (<i><tt>expression2</tt></i>)
  ((<i><tt>constant3</tt></i>) (<i><tt>expression3</tt></i>)
  (else <i><tt>else-expression</tt></i>))
</pre>
                  <br>
                  <br>

                  <p>The value of the expression is compared
                  against each of the constants in turn and the
                  expression associated with the first matching
                  constant is evaulated.</p>
                </dd>

                <dt><span class="term"><tt>cond</tt></span></dt>

                <dd>
                  <p><a class="indexterm" name="d0e10818"></a>
                  <tt>cond</tt> also selects from among several
                  alternatives, but the selection is performed by
                  evaluating each expression:</p>
<pre class="screen">
(cond
  ((<i><tt>condition1</tt></i>) (<i><tt>expression1</tt></i>)
  ((<i><tt>condition2</tt></i>) (<i><tt>expression2</tt></i>)
  ((<i><tt>condition3</tt></i>) (<i><tt>expression3</tt></i>)
  (else <i><tt>else-expression</tt></i>))
</pre>
                  <br>
                  <br>

                  <p>The value of each conditional is calculated in
                  turn. The expression associated with the first
                  condition that is true is evaluated.</p>
                </dd>
              </dl>
            </div>

            <p><a class="indexterm" name="d0e10853"></a> Any
            expression that returns <tt>#f</tt> is false; all other
            expressions are true. This can be somewhat
            counterintuitive. In many programming languages, it's
            common to assume that &#8220;empty&#8221; things are
            false (0 is false, a null pointer is false, an empty
            set is false, for example.) In DSSSL, this isn't the
            case; note, for example, that an empty node list is not
            <tt>#f</tt> and is therefore true. To avoid these
            difficulties, always use functions that return true or
            false in conditionals. To test for an empty node list,
            use <tt>(node-list-empty?)</tt>.</p>
          </div>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name="dsssl.expr.let"></a>Let
                expressions</h4>
              </div>
            </div>

            <p><a class="indexterm" name="d0e10877"></a> The way to
            create local variables in DSSSL is with <tt>(let)</tt>.
            The general form of a <tt>let</tt> expression is:</p>
<pre class="screen">
(let ((<i><tt>var1</tt></i> expression1)
      (<i><tt>var2</tt></i> expression2)
      ...
      (<i><tt>varn</tt></i> expressionn))
  <i><tt>let-body</tt></i>)
</pre>
            <br>
            <br>

            <p><a class="indexterm" name="d0e10916"></a> In a
            <tt>let</tt>; expression, all of the variables are
            defined &#8220;simultaneously.&#8221; The expression
            that defines <i><tt>var2</tt></i> cannot contain any
            references to any other variables defined in the same
            <tt>let</tt> expression. A <tt>let*</tt> expression
            allows variables to refer to each other, but runs
            slightly slower.</p>

            <p><a class="indexterm" name="d0e10939"></a> Variables
            are available only within the <i><tt>let-body</tt></i>.
            A common use of <tt>let</tt> is within a
            <tt>define</tt> expression:</p>
<pre class="screen">
(define (cals-rule-default nd)
   (let* ((table (ancestor "table" nd))
          (frame (if (attribute-string "frame" table)
                     (attribute-string "frame" table)
                     "all")))
    (equal? frame "all")))
</pre>
            <br>
            <br>

            <p>This function creates two local variables
            <tt>table</tt> and <tt>frame</tt>. <tt>let</tt> returns
            the value of the last expression in the body, so this
            function returns true if the <tt class=
            "sgmltag-attribute">frame</tt> attribute on the table
            is <tt>all</tt> or if no <tt class=
            "sgmltag-attribute">frame</tt> attribute is
            present.</p>
          </div>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name=
                "dsssl.expr.loop"></a>Loops</h4>
              </div>
            </div>

            <p><a class="indexterm" name="d0e10980"></a> <a class=
            "indexterm" name="d0e10984"></a> <a class="indexterm"
            name="d0e10988"></a> DSSSL doesn't have any construct
            that resembles the &#8220;for loop&#8221; that occurs
            in most imperative languages like C and Java. Instead,
            DSSSL employs a common trick in functional languages
            for implementing a loop: tail recursion.</p>

            <p>Loops in DSSSL use a special form of <tt>let</tt>.
            This loop counts from 1 to 10:</p>
<pre class="screen">
(let <a name="dl1"></a><img src="figures/callouts/1.png" alt="1"
border="0">loopvar <a name="dl2"></a><img src=
"figures/callouts/2.png" alt="2" border="0">((count 1))
  <a name="dl3"></a><img src="figures/callouts/3.png" alt="3"
border="0">(if (&gt; count 10)
    <a name="dl4"></a><img src="figures/callouts/4.png" alt="4"
border="0">#t
    (<a name="dl5"></a><img src="figures/callouts/5.png" alt="5"
border="0">loopvar <a name="dl6"></a><img src=
"figures/callouts/6.png" alt="6" border="0">(+ count 1))))
</pre>
            <br>
            <br>

            <div class="calloutlist">
              <table border="0" summary="Callout list">
                <tr>
                  <td width="5%" valign="top" align="left"><a href=
                  "#dl1"><img src="figures/callouts/1.png" alt="1"
                  border="0"></a></td>

                  <td valign="top" align="left">
                    <p>This variable controls the loop. It is
                    declared without an initial value, immediately
                    after the <tt>let</tt> operand.</p>
                  </td>
                </tr>

                <tr>
                  <td width="5%" valign="top" align="left"><a href=
                  "#dl2"><img src="figures/callouts/2.png" alt="2"
                  border="0"></a></td>

                  <td valign="top" align="left">
                    <p><a class="indexterm" name="d0e11033"></a>
                    Any number of additional local variables can be
                    defined after the loop variable, just as they
                    can in any other <tt>let</tt> expression.</p>
                  </td>
                </tr>

                <tr>
                  <td width="5%" valign="top" align="left"><a href=
                  "#dl3"><img src="figures/callouts/3.png" alt="3"
                  border="0"></a></td>

                  <td valign="top" align="left">
                    <p>If you ever want the loop to end, you have
                    to put some sort of a test in it.</p>
                  </td>
                </tr>

                <tr>
                  <td width="5%" valign="top" align="left"><a href=
                  "#dl4"><img src="figures/callouts/4.png" alt="4"
                  border="0"></a></td>

                  <td valign="top" align="left">
                    <p>This is the value that will be returned.</p>
                  </td>
                </tr>

                <tr>
                  <td width="5%" valign="top" align="left"><a href=
                  "#dl5"><img src="figures/callouts/5.png" alt="5"
                  border="0"></a></td>

                  <td valign="top" align="left">
                    <p>Note that you iterate the loop by using the
                    loop variable as if it was a function name.</p>
                  </td>
                </tr>

                <tr>
                  <td width="5%" valign="top" align="left"><a href=
                  "#dl6"><img src="figures/callouts/6.png" alt="6"
                  border="0"></a></td>

                  <td valign="top" align="left">
                    <p>The arguments to this &#8220;function&#8221;
                    are the values that you want the local
                    variables declared in <a href=
                    "ch04.html#dl2"><img src=
                    "figures/callouts/2.png" alt="2" border="0"></a> to have in the next iteration.</p>
                  </td>
                </tr>
              </table>
            </div>
          </div>
        </div>

        <div class="section" lang="en">
          <div class="titlepage">
            <div>
              <h3 class="title"><a name="d0e11059"></a>A Closer
              Look at <a href="ch04.html#dsssl.stylesheet" title=
              "Example&#160;4.5.&#160;A Complete DSSSL Stylesheet">Example&#160;4.5</a></h3>
            </div>
          </div>

          <p><a class="indexterm" name="d0e11065"></a> <a href=
          "ch04.html#dsssl.stylesheet" title=
          "Example&#160;4.5.&#160;A Complete DSSSL Stylesheet">Example&#160;4.5</a>
          is a style sheet that contains a style specification.
          Stylesheets may consist of multiple specifications, as
          we'll see in <a href="ch04.html#dsssl.twostylesheets"
          title="A Single Stylesheet for Both Print and HTML">the
          section called &#8220;A Single Stylesheet for Both Print
          and HTML&#8221;</a>.</p>

          <p>The actual DSSSL code goes in the style specification
          body, within the style specification. Each construction
          rule processes different elements from the source
          document.</p>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name="d0e11082"></a>Processing
                chapters</h4>
              </div>
            </div>

            <p><a class="indexterm" name="d0e11087"></a> <a class=
            "indexterm" name="d0e11091"></a> <a class="indexterm"
            name="d0e11097"></a> <a href="chapter.html"><tt class=
            "sgmltag-element">Chapter</tt></a>s are processed by
            the <tt>chapter</tt> construction rule. Each <a href=
            "chapter.html"><tt class=
            "sgmltag-element">Chapter</tt></a> is formatted as a
            <tt>simple-page-sequence</tt>. Every print stylesheet
            should format a document as one or more simple page
            sequences. Characteristics on the simple page sequence
            can specify headers and footers as well as margins and
            other page parameters.</p>

            <p><a class="indexterm" name="d0e11117"></a> One
            important note about simple page sequences: they cannot
            nest. This means that you cannot blindly process
            divisions (<a href="part.html"><tt class=
            "sgmltag-element">Part</tt></a>s, <a href=
            "reference.html"><tt class=
            "sgmltag-element">Reference</tt></a>) and the elements
            they contain (<a href="chapter.html"><tt class=
            "sgmltag-element">Chapter</tt></a>s, <a href=
            "refentry.html"><tt class=
            "sgmltag-element">RefEntry</tt></a>s) as simple page
            sequences. This sometimes involves a little
            creativity.</p>
          </div>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name="d0e11135"></a>Processing
                titles</h4>
              </div>
            </div>

            <p><a class="indexterm" name="d0e11140"></a> The
            <tt>make</tt> expression in the <tt>title</tt> element
            rule ensures that <a href="title.html"><tt class=
            "sgmltag-element">Title</tt></a>s are formatted in
            large, bold print.</p>

            <p>This construction rule applies equally to <a href=
            "chapter.html"><tt class=
            "sgmltag-element">Chapter</tt></a> titles, <a href=
            "figure.html"><tt class=
            "sgmltag-element">Figure</tt></a> titles, and <a href=
            "book.html"><tt class="sgmltag-element">Book</tt></a>
            titles. It's unlikely that you'd want all of these
            titles to be presented in the same way, so a more
            robust stylesheet would have to arrange the processing
            of titles with more context. This might be achieved in
            the way that nested <a href="emphasis.html"><tt class=
            "sgmltag-element">Emphasis</tt></a> elements are
            handled in <a href="ch04.html#dsssl.nestedemph" title=
            "Processing emphasis">the section called
            &#8220;Processing emphasis&#8221;</a>.</p>
          </div>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name="d0e11171"></a>Processing
                paragraphs</h4>
              </div>
            </div>

            <p><a href="para.html"><tt class=
            "sgmltag-element">Para</tt></a> elements are simply
            formatted as paragraphs. <a class="indexterm" name=
            "d0e11179"></a></p>
          </div>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name=
                "dsssl.nestedemph"></a>Processing emphasis</h4>
              </div>
            </div>

            <p><a class="indexterm" name="d0e11190"></a> <a class=
            "indexterm" name="d0e11196"></a> Processing <a href=
            "emphasis.html"><tt class=
            "sgmltag-element">Emphasis</tt></a> elements is made a
            little more interesting because we want to consider an
            attribute value and the possibility that <a href=
            "emphasis.html"><tt class=
            "sgmltag-element">Emphasis</tt></a> elements can be
            nested.</p>

            <p>In the simple case, in which we're processing an <a
            href="emphasis.html"><tt class=
            "sgmltag-element">Emphasis</tt></a> element that is not
            nested, we begin by testing the value of the <tt class=
            "sgmltag-attribute">role</tt> attribute. If the content
            of that attribute is the string <tt>strong</tt>, it is
            formatted in bold; otherwise, it is formatted in
            italic.</p>

            <p>The nested case is handled by the <tt>(emphasis
            emphasis)</tt> rule. This rule simply formats the
            content using an upright (nonitalic) font. This rule,
            like the rule for <a href="title.html"><tt class=
            "sgmltag-element">Title</tt></a>s, is not robust. <a
            href="emphasis.html"><tt class=
            "sgmltag-element">Emphasis</tt></a> nested inside
            <tt>strong</tt> <a href="emphasis.html"><tt class=
            "sgmltag-element">Emphasis</tt></a> won't be
            distinguished, for example, and nestings more than two
            elements deep will be handled just as nestings that are
            two deep.</p>
          </div>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name="d0e11236"></a>Processing
                subscripts and superscripts</h4>
              </div>
            </div>

            <p><a class="indexterm" name="d0e11241"></a> <a class=
            "indexterm" name="d0e11247"></a> Processing <a href=
            "subscript.html"><tt class=
            "sgmltag-element">Subscript</tt></a> and <a href=
            "superscript.html"><tt class=
            "sgmltag-element">Superscript</tt></a> elements is
            really handled by the <tt>super-sub-script</tt>
            function. There are several interesting things about
            this function:</p>

            <div class="variablelist">
              <dl>
                <dt><span class="term">The <tt>plus-or-minus</tt>
                argument</span></dt>

                <dd>
                  <p><a class="indexterm" name="d0e11272"></a> <a
                  class="indexterm" name="d0e11278"></a> You might
                  ordinarily think of passing a keyword or boolean
                  argument to the <tt>super-sub-script</tt>
                  function to indicate whether subscripts or
                  superscripts are desired. But with Scheme, it's
                  possible to pass the actual function as an
                  argument!</p>

                  <p>Note that in the element construction rules
                  for <a href="superscript.html"><tt class=
                  "sgmltag-element">Superscript</tt></a> and <a
                  href="subscript.html"><tt class=
                  "sgmltag-element">Subscript</tt></a>, we pass the
                  actual functions <tt>+</tt> and <tt>-</tt>. In
                  the body of <tt>super-sub-script</tt>, we use the
                  <tt>plus-or-minus</tt> argument as a function
                  name (it appears immediately after an open
                  parenthesis).</p>
                </dd>

                <dt><span class="term">The optional
                argument</span></dt>

                <dd>
                  <p><a class="indexterm" name="d0e11313"></a>
                  <tt>optional</tt> arguments are indicated by
                  <tt>#!optional</tt> in the function declaration.
                  Any number of <tt>optional</tt> arguments may be
                  given, but each must specify a default value.
                  This is accomplished by listing each argument and
                  default value (an expression) as a pair.</p>

                  <p>In <tt>super-sub-script</tt>, the optional
                  argument <tt>sosofo</tt> is initialized to
                  <tt>process-children</tt>. This means that at the
                  point where the function is <span class=
                  "emphasis"><em>called</em></span>,
                  <tt>process-children</tt> is evaluated and the
                  resulting <tt>sosofo</tt> is passed to the
                  function.</p>
                </dd>

                <dt><span class="term">Use of inherited
                characteristics</span></dt>

                <dd>
                  <p><a class="indexterm" name="d0e11352"></a> It
                  is possible to use the &#8220;current&#8221;
                  value of an inherited characteristic to calculate
                  a new value. Using this technique, superscripts
                  and subscripts will be presented at 80 percent of
                  the current font size.</p>
                </dd>
              </dl>
            </div>
          </div>
        </div>

        <div class="section" lang="en">
          <div class="titlepage">
            <div>
              <h3 class="title"><a name="d0e11359"></a>Customizing
              the Stylesheets</h3>
            </div>
          </div>

          <p><a class="indexterm" name="d0e11364"></a> <a class=
          "indexterm" name="d0e11372"></a> <a class="indexterm"
          name="d0e11378"></a> The best way to customize the
          stylesheets is to write your own &#8220;driver&#8221;
          file; this is a stylesheet that contains your local
          modifications and then includes the appropriate
          stylesheet from the standard distribution by reference.
          This allows you to make local changes and extensions
          without modifying the distributed files, which makes
          upgrading to the next release much simpler.</p>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name=
                "dsssl.driver"></a>Writing Your Own Driver</h4>
              </div>
            </div>

            <p>A basic driver file looks like this:</p>
<pre class="screen">
&lt;!DOCTYPE style-sheet PUBLIC "-//James Clark//DTD DSSSL Style Sheet//EN" [
&lt;!ENTITY dbstyle PUBLIC "-//Norman Walsh//DOCUMENT DocBook Print Stylesheet//EN" CDATA DSSSL&gt;
]&gt;

&lt;style-sheet&gt;
&lt;style-specification use="docbook"&gt;
&lt;style-specification-body&gt;

;; your changes go here...

&lt;/style-specification-body&gt;
&lt;/style-specification&gt;
&lt;external-specification id="docbook" document="dbstyle"&gt;
&lt;/style-sheet&gt;
</pre>
            <br>
            <br>

            <p><a class="indexterm" name="d0e11397"></a> <a class=
            "indexterm" name="d0e11403"></a> There are two public
            identifiers associated with the Modular DocBook
            Stylesheets:</p>

            <div class="itemizedlist">
              <ul type="disc">
                <li>
                  <p><tt>-//Norman Walsh//DOCUMENT DocBook Print
                  Stylesheet//EN</tt></p>
                </li>

                <li>
                  <p><tt>-//Norman Walsh//DOCUMENT DocBook HTML
                  Stylesheet//EN</tt></p>
                </li>
              </ul>
            </div>
            <a class="indexterm" name="d0e11419"></a> <a class=
            "indexterm" name="d0e11425"></a> <a class="indexterm"
            name="d0e11433"></a> The former selects the print
            stylesheet and the latter selects the HTML stylesheet.
            There is an SGML Open catalog file in the distribution
            that maps these public identifiers to the stylesheet
            files.<br>
            <br>

            <p>You can add your own definitions, or redefinitions,
            of stylesheet rules and parameters so that</p>
<pre class="screen">
;; your changes go here...
</pre>
            occurs in the previous example. <br>
            <br>

            <p><a class="indexterm" name="d0e11452"></a> For a
            concrete example of a driver file, see
            <tt>plain.dsl</tt> in the <tt>docbook/print</tt>
            directory in the stylesheet distribution (or on the <a
            href="appe.html" title=
            "What's on the CD-ROM?">CD-ROM</a>). This is a
            customization of the print stylesheet, which turns off
            title page and TOC generation.</p>
          </div>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name="d0e11471"></a>Changing
                the Localization</h4>
              </div>
            </div>

            <p><a class="indexterm" name="d0e11476"></a> <a class=
            "indexterm" name="d0e11484"></a> As distributed, the
            stylesheets use English for all generated text, but
            other localization files are also provided. At the time
            of this writing, the stylesheets support Catalan,
            Czech, Danish, Dutch, English, Finnish, French, German,
            Greek, Italian, Japanese, Norwegian, Polish,
            Portuguese, Portuguese (Brazil), Romanian, Russian,
            Slovak, Spanish, and Swedish. (If you can write a
            localization for another language, <span class=
            "emphasis"><em>please</em></span> contribute it.)</p>

            <p><a class="indexterm" name="d0e11495"></a> <a class=
            "indexterm" name="d0e11499"></a> There are two ways to
            switch languages: by specifying a <tt class=
            "sgmltag-attribute">lang</tt> attribute, or by changing
            the default language in a customization.</p>

            <div class="section" lang="en">
              <div class="titlepage">
                <div>
                  <h5 class="title"><a name="d0e11510"></a>Using
                  the <tt class="sgmltag-attribute">lang</tt>
                  attribute</h5>
                </div>
              </div>

              <p><a class="indexterm" name="d0e11518"></a> <a
              class="indexterm" name="d0e11524"></a> One of the
              DocBook common attributes is <tt class=
              "sgmltag-attribute">lang</tt>. If you specify a
              language, the DocBook stylesheets will use that
              language (and all its descendants, if no other
              language is specified) for generated text within that
              element.</p>

              <p><a href="ch04.html#tbl.lang" title=
              "Table&#160;4.1.&#160;DocBook Stylesheet Language Codes">Table&#160;4.1</a> summarizes the language codes for
              the supported languages.<sup>[<a name="d0e11537"
              href="#ftn.d0e11537">15</a>]</sup> <a class=
              "indexterm" name="d0e11547"></a> The following
              chapter uses text generated in French:</p>
<pre class="screen">
&lt;chapter lang="fr"&gt;&lt;title&gt;B&#234;tises&lt;/title&gt;
&lt;para&gt;Pierre qui roule n'amasse pas de mousse.&lt;/para&gt;
&lt;/chapter&gt;
</pre>
              <br>
              <br>

              <div class="table">
                <a name="tbl.lang"></a>

                <p class="title"><b>Table&#160;4.1.&#160;DocBook
                Stylesheet Language Codes</b></p>

                <table summary="DocBook Stylesheet Language Codes"
                cellpadding="2px" border="0" style=
                "border-collapse: collapse;">
                  <colgroup>
                    <col width="33%">
                    <col width="67%">
                  </colgroup>

                  <thead>
                    <tr style="border-bottom: 0.5pt solid ; ">
                      <th style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "
                       align="left">Language Code</th>

                      <th style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "
                       align="left">Language</th>
                    </tr>
                  </thead>

                  <tbody>
                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>af</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Afrikaans</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>ca</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Catalan</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>cs</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Czech</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>da</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Danish</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>de</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      German</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>el</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Greek</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>en</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      English</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>es</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Spanish</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>et</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Estonian</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>eu</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Basque</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>fi</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Finnish</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>fr</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      French</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>he</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Hebrew</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>hu</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Hungarian</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>id</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Indonesian</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>it</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Italian</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>ja</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Japanese</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>ko</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Korean</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>nl</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Dutch</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>nn</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Nyorsk</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>no</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Norwegian</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>pl</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Polish</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>pt</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Portuguese</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>pt-br</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Portuguese (Brazil)</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>ro</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Romanian</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>ru</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Russian</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>sk</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Slovak</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>sl</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Slovenian</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>sv</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Swedish</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>th</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Thai</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>tr</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Turkish</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>uk</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Ukranian</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>xh</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Xhosa</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>zh-cn</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Chinese (Continental)</td>
                    </tr>

                    <tr>
                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      <tt>zh-tw</tt></td>

                      <td style=
                      "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                      Chinese (Traditional)</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>

            <div class="section" lang="en">
              <div class="titlepage">
                <div>
                  <h5 class="title"><a name="d0e11778"></a>Changing
                  the default language</h5>
                </div>
              </div>

              <p><a class="indexterm" name="d0e11783"></a> <a
              class="indexterm" name="d0e11789"></a> If no <tt
              class="sgmltag-attribute">lang</tt> attribute is
              specified, the default language is used. You can
              change the default language with a <a href=
              "ch04.html#dsssl.driver" title=
              "Writing Your Own Driver">driver</a>.</p>

              <p>In the driver, define the default language. <a
              href="ch04.html#tbl.lang" title=
              "Table&#160;4.1.&#160;DocBook Stylesheet Language Codes">Table&#160;4.1</a> summarizes the language codes for
              the supported languages. The following driver makes
              German the default language:</p>
<pre class="screen">
&lt;!DOCTYPE style-sheet PUBLIC "-//James Clark//DTD DSSSL Style Sheet//EN" [
&lt;!ENTITY dbstyle PUBLIC "-//Norman Walsh//DOCUMENT DocBook Print Stylesheet//EN" CDATA DSSSL&gt;
]&gt;

&lt;style-sheet&gt;
&lt;style-specification use="docbook"&gt;
&lt;style-specification-body&gt;

(define %default-language% "dege")

&lt;/style-specification-body&gt;
&lt;/style-specification&gt;
&lt;external-specification id="docbook" document="dbstyle"&gt;
&lt;/style-sheet&gt;
</pre>
              <br>
              <br>

              <p><a class="indexterm" name="d0e11810"></a> There
              are two other settings that can be changed only in a
              driver. Both of these settings are turned off in the
              distributed stylesheet:</p>

              <div class="variablelist">
                <dl>
                  <dt><span class=
                  "term"><tt>%gentext-language%</tt></span></dt>

                  <dd>
                    <p>If a language code is specified in
                    <tt>%gentext-language%</tt>, then that language
                    will be used for all generated text, regardless
                    of any <tt class="sgmltag-attribute">lang</tt>
                    attribute settings in the document.</p>
                  </dd>

                  <dt><span class=
                  "term"><tt>%gentext-use-xref-language%</tt></span></dt>

                  <dd>
                    <p><a class="indexterm" name="d0e11835"></a> <a
                    class="indexterm" name="d0e11839"></a> If
                    turned on (defined as <tt>#t</tt>), then the
                    stylesheets will generate the text associated
                    with a cross reference using the language of
                    the target, not the current language. Consider
                    the following book:</p>
<pre class="screen">
&lt;book&gt;&lt;title&gt;A Test Book&lt;/title&gt;
&lt;preface&gt;
&lt;para&gt;There are three chapters in this book: &lt;xref linkend="c1"&gt;, 
&lt;xref linkend="c2"&gt;, and &lt;xref linkend="c3"&gt;.
&lt;/para&gt;
&lt;/preface&gt;
&lt;chapter lang="usen"&gt;&lt;title&gt;English&lt;/title&gt; ... &lt;/chapter&gt;
&lt;chapter lang="fr"&gt;&lt;title&gt;French&lt;/title&gt; ... &lt;/chapter&gt;
&lt;chapter lang="dege"&gt;&lt;title&gt;Deutsch&lt;/title&gt; ... &lt;/chapter&gt;
&lt;/book&gt;
</pre>

                    <p>The standard stylesheets render the Preface
                    as something like this:</p>

                    <div class="blockquote">
                      <blockquote class="blockquote">
                        <p>There are three chapters in this book:
                        Chapter 1, Chapter 2, and Chapter 3.</p>
                      </blockquote>
                    </div>

                    <p>With <tt>%gentext-use-xref-language%</tt>
                    turned on, it would render like this:</p>

                    <div class="blockquote">
                      <blockquote class="blockquote">
                        <p>There are are three chapters in this
                        book: Chapter 1, Chapitre 2, and Kapitel
                        3.</p>
                      </blockquote>
                    </div>
                  </dd>
                </dl>
              </div>
              <br>
              <br>
            </div>
          </div>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name=
                "dsssl.twostylesheets"></a>A Single Stylesheet for
                Both Print and HTML</h4>
              </div>
            </div>

            <p><a class="indexterm" name="d0e11870"></a> <a class=
            "indexterm" name="d0e11876"></a> <a class="indexterm"
            name="d0e11882"></a> A DSSSL stylesheet consists of one
            or more &#8220;style specifications.&#8221; Using more
            than one style specification allows you to build a
            single stylesheet file that can format with either the
            print or SGML backends. <a href=
            "ch04.html#ex-twostyles" title=
            "Example&#160;4.8.&#160;both.dsl: A Stylesheet with Two Style Specifications">Example&#160;4.8</a> shows a stylesheet with two style
            specifications. <a class="indexterm" name=
            "d0e11899"></a></p>

            <div class="example">
              <a name="ex-twostyles"></a>

              <p class="title">
              <b>Example&#160;4.8.&#160;<tt>both.dsl</tt>: A
              Stylesheet with Two Style Specifications</b></p>
<pre class="screen">
&lt;!DOCTYPE style-sheet PUBLIC "-//James Clark//DTD DSSSL Style Sheet//EN" [
&lt;!ENTITY html-ss 
  PUBLIC "-//Norman Walsh//DOCUMENT DocBook HTML Stylesheet//EN" CDATA dsssl&gt;
&lt;!ENTITY print-ss
  PUBLIC "-//Norman Walsh//DOCUMENT DocBook Print Stylesheet//EN" CDATA dsssl&gt;
]&gt;
&lt;style-sheet&gt;
&lt;style-specification id="print" use="print-stylesheet"&gt;
&lt;style-specification-body&gt; 

;; customize the print stylesheet

&lt;/style-specification-body&gt;
&lt;/style-specification&gt;
&lt;style-specification id="html" use="html-stylesheet"&gt;
&lt;style-specification-body&gt; 

;; customize the html stylesheet

&lt;/style-specification-body&gt;
&lt;/style-specification&gt;
&lt;external-specification id="print-stylesheet" document="print-ss"&gt;
&lt;external-specification id="html-stylesheet"  document="html-ss"&gt;
&lt;/style-sheet&gt;

</pre>
            </div>

            <p><a class="indexterm" name="d0e11918"></a> Once you
            have stylesheets with more than one style
            specification, you have to be able to indicate which
            style specification you want to use. In Jade, you
            indicate this by providing the ID of the style
            specification after the stylesheet filename, separated
            with a hash mark: <tt>#</tt>.</p>

            <p>Using the code from <a href="ch04.html#ex-twostyles"
            title=
            "Example&#160;4.8.&#160;both.dsl: A Stylesheet with Two Style Specifications">Example&#160;4.8</a>, you can format a document using
            the print stylesheet by running:</p>
<pre class="screen">
jade -t rtf -d both.dsl#print file.sgm
</pre>

            <p>and using the HTML stylesheet by running:</p>
<pre class="screen">
jade -t sgml -d both.dsl#html file.sgm
</pre>
          </div>
        </div>

        <div class="section" lang="en">
          <div class="titlepage">
            <div>
              <h3 class="title"><a name="jademultdecl"></a>Dealing
              with Multiple Declarations</h3>
            </div>
          </div>

          <p><a class="indexterm" name="d0e11948"></a> The DocBook
          SGML DTD and the DocBook DSSSL Stylesheets happen to use
          the same SGML declaration. This makes it very easy to run
          Jade with DocBook. However, you may sometimes wish to use
          Jade with other document types, for example the DocBook
          XML DTD, which has a different declaration. There are a
          couple of ways to do this.</p>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name="d0e11972"></a>Pass the
                Declaration Explicitly</h4>
              </div>
            </div>

            <p>If your stylesheets parse fine with the default
            declaration, but you want to use an alternate
            declaration with a particular document, just pass the
            declaration on the command line:</p>
<pre class="screen">
jade <i><tt>options</tt></i> the-declaration the-document
</pre>
            Note that there's no option required before the
            declaration; it simply occurs before the first
            filename. Jade concatenates all of the files that you
            give it together, and parses them as if they were one
            document. <br>
            <br>
          </div>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name="d0e11983"></a>Use the
                Catalogs</h4>
              </div>
            </div>

            <p>The other way to fix this is with a little catalog
            trickery.</p>

            <p><a class="indexterm" name="d0e11990"></a> First,
            note that Jade always looks in the file called
            <tt>catalog</tt> in the same directory as the document
            that it is loading, and uses settings in that file in
            preference to settings in other catalogs.</p>

            <p>With this fact, we can employ the following
            trick:</p>

            <div class="itemizedlist">
              <ul type="disc">
                <li>
                  <p>Put a <tt>catalog</tt> file in the directory
                  that contains your stylesheets, which contain an
                  <tt>SGMLDECL</tt> directive. Jade understands the
                  directive, which points to the SGML declaration
                  that you should use when parsing the stylesheets.
                  For the DocBook stylesheets, the DocBook
                  declaration works fine.</p>
                </li>

                <li>
                  <p>In the directory that contains the document
                  you want to process, create a <tt>catalog</tt>
                  file that contains an <tt>SGMLDECL</tt> directive
                  that points to the SGML declaration that should
                  be used when parsing the document.</p>
                </li>
              </ul>
            </div>

            <p>There's no easy way to have both the stylesheet and
            the document in the same directory if they must be
            processed with different declarations. But this is
            usually not too inconvenient.</p>
          </div>
        </div>

        <div class="section" lang="en">
          <div class="titlepage">
            <div>
              <h3 class="title"><a name="dsssl.arch"></a>The DSSSL
              Architecture</h3>
            </div>
          </div>

          <p><a class="indexterm" name="d0e12036"></a> <a class=
          "indexterm" name="d0e12042"></a> <a class="indexterm"
          name="d0e12048"></a> <a class="indexterm" name=
          "d0e12054"></a> The concept of an architecture was
          promoted by HyTime. In some ways, it takes the standard
          SGML/XML notions of the role of elements and attributes
          and inverts them. Instead of relying on the name of an
          element to assign its primary semantics, it uses the
          values of a small set of fixed attributes.</p>

          <p>While this may be counterintuitive initially, it has
          an interesting benefit. An architecture-aware processor
          can work transparently with many different DTDs. A small
          example will help illustrate this point.</p>

          <div class="note" style=
          "margin-left: 0.5in; margin-right: 0.5in;">
            <h3 class="title">Note</h3>

            <p>The following example demonstrates the concept
            behind architectures, but for the sake of simplicity,
            it does not properly implement an architecture as
            defined in HyTime.</p>
          </div>

          <p>Imagine that you wrote an application that can read an
          SGML/XML document containing a letter (conforming to some
          letter DTD), and automatically print an envelope for the
          letter. It's easy to envision how this works. The
          application reads the content of the letter, extracts the
          address and return address elements from the source, and
          uses them to generate an envelope:</p>
<pre class="screen">
&lt;?xml version='1.0'&gt;
&lt;!DOCTYPE letter "/share/sgml/letter/letter.dtd" [
&lt;!ENTITY myaddress "/share/sgml/entities/myaddress.xml"&gt;
]&gt;
&lt;letter&gt;
&lt;returnaddress&gt;&amp;myaddress;&lt;/returnaddress&gt;
&lt;address&gt;
&lt;name&gt;Leonard Muellner&lt;/name&gt;
&lt;company&gt;O'Reilly &amp;amp; Associates&lt;/company&gt;
&lt;street&gt;90 Sherman Street&lt;/street&gt;
&lt;city&gt;Cambridge&lt;/city&gt;&lt;state&gt;MA&lt;/state&gt;&lt;zip&gt;02140&lt;/zip&gt;
&lt;/address&gt;
&lt;body&gt;
&lt;salutation&gt;Hi Lenny&lt;/salutation&gt;
...
&lt;/body&gt;
</pre>

          <p>The processor extracts the <tt class=
          "sgmltag-element">Returnaddress</tt> and <a href=
          "address.html"><tt class=
          "sgmltag-element">Address</tt></a> elements and their
          children and prints the envelope accordingly.</p>

          <p>Now suppose that a colleague from payroll comes by and
          asks you to adapt the application to print envelopes for
          mailing checks, using the information in the payroll
          database, which has a different DTD. And a week later,
          someone from sales comes by and asks if you can modify
          the application to use the contact information DTD. After
          a while, you would have 11 versions of this program to
          maintain.</p>

          <p><a class="indexterm" name="d0e12105"></a> Suppose that
          instead of using the actual element names to locate the
          addresses in the documents, you asked each person to add
          a few attributes to their DTD. By forcing the attributes
          to have fixed values, they'd automatically be present in
          each document, but authors would never have to worry
          about them.</p>

          <p>For example, the address part of the letter DTD might
          look like this:</p>
<pre class="screen">
&lt;!ELEMENT address (name, company? street*, city, state, zip)&gt;
&lt;!ATTLIST address
    ADDRESS CDATA   #FIXED "START"
&gt;

&lt;!ELEMENT name (#PCDATA)*&gt;
&lt;!ATTLIST name
    ADDRESS CDATA   #FIXED "NAME"
&gt;

&lt;!ELEMENT company (#PCDATA)*&gt;
&lt;!ATTLIST company
    ADDRESS CDATA   #FIXED "COMPANY"
&gt;

&lt;!ELEMENT street (#PCDATA)*&gt;
&lt;!ATTLIST street
    ADDRESS CDATA   #FIXED "STREET"
&gt;

&lt;!ELEMENT city (#PCDATA)*&gt;
&lt;!ATTLIST city
    ADDRESS CDATA   #FIXED "CITY"
&gt;

&lt;!ELEMENT state (#PCDATA)*&gt;
&lt;!ATTLIST state
    ADDRESS CDATA   #FIXED "STATE"
&gt;

&lt;!ELEMENT zip (#PCDATA)*&gt;
&lt;!ATTLIST zip
    ADDRESS CDATA   #FIXED "ZIP"
&gt;

</pre>

          <p>Effectively, each address in a letter would look like
          this:</p>
<pre class="screen">
&lt;address ADDRESS="START"&gt;
&lt;name ADDRESS="NAME"&gt;Leonard Muellner&lt;/name&gt;
&lt;company ADDRESS="COMPANY"&gt;O'Reilly &amp;amp;amp; Associates&lt;/company&gt;
&lt;street&gt; ADDRESS="STREET"&gt;90 Sherman Street&lt;/street&gt;
&lt;city ADDRESS="CITY"&gt;Cambridge&lt;/city&gt;&lt;state ADDRESS="STATE"&gt;MA&lt;/state&gt;
&lt;zip ADDRESS="ZIP"&gt;02140&lt;/zip&gt;
&lt;/address&gt;

</pre>

          <p>In practice, the author would not include the <tt
          class="sgmltag-attribute">ADDRESS</tt> attributes; they
          are automatically provided by the DTD because they are
          <tt>#FIXED</tt>.<sup>[<a name="d0e12138" href=
          "#ftn.d0e12138">16</a>]</sup></p>

          <p>Now the address portion of the payroll DTD might look
          like this:</p>
<pre class="screen">
&lt;!ELEMENT employee (name, mailingaddress)&gt;

&lt;!ELEMENT name (#PCDATA)*&gt;
&lt;!ATTLIST name
    ADDRESS CDATA   #FIXED "NAME"
&gt;

&lt;!ELEMENT mailingaddress (addrline1, addrline2, 
                          city, state.or.province, postcode)&gt;
&lt;!ATTLIST mailingaddress
    ADDRESS CDATA   #FIXED "START"
&gt;

&lt;!ELEMENT addrline1 (#PCDATA)*&gt;
&lt;!ATTLIST addrline1
    ADDRESS CDATA   #FIXED "STREET"
&gt;

&lt;!ELEMENT addrline2 (#PCDATA)*&gt;
&lt;!ATTLIST addrline2
    ADDRESS CDATA   #FIXED "STREET"
&gt;

&lt;!ELEMENT city (#PCDATA)*&gt;
&lt;!ATTLIST city
    ADDRESS CDATA   #FIXED "CITY"
&gt;

&lt;!ELEMENT state.or.province (#PCDATA)*&gt;
&lt;!ATTLIST state.or.province
    ADDRESS CDATA   #FIXED "STATE"
&gt;

&lt;!ELEMENT postcode (#PCDATA)*&gt;
&lt;!ATTLIST postcode
    ADDRESS CDATA   #FIXED "ZIP"
&gt;

</pre>

          <p>The employee records will look like this:</p>
<pre class="screen">
&lt;employee&gt;&lt;name ADDRESS="NAME"&gt;Leonard Muellner&lt;/name&gt;
&lt;mailingaddress ADDRESS="START"&gt;
&lt;addrline1 ADDRESS="STREET"&gt;90 Sherman Street&lt;/addrline1&gt;
&lt;city ADDRESS="CITY"&gt;Cambridge&lt;/city&gt;
&lt;state.or.province ADDRESS="STATE"&gt;MA&lt;/state.or.province&gt;
&lt;postcode ADDRESS="ZIP"&gt;02140&lt;/postcode&gt;
&lt;/mailingaddress&gt;
&lt;/employee&gt;

</pre>

          <p>Your application no longer cares about the actual
          element names. It simply looks for the elements with the
          correct attributes and uses them. This is the power of an
          architecture: it provides a level of abstraction that
          processing applications can use to their advantage. In
          practice, architectural forms are a bit more complex to
          set up because they have facilities for dealing with
          attribute name conflicts, among other things.</p>

          <p>Why have we told you all this? Because DSSSL is an
          architecture. This means you can modify the stylesheet
          DTD and still run your stylesheets through Jade.</p>

          <p>Consider the case presented earlier in <a href=
          "ch04.html#ex-twostyles" title=
          "Example&#160;4.8.&#160;both.dsl: A Stylesheet with Two Style Specifications">Example&#160;4.8</a>. In order to use this stylesheet,
          you must specify three things: the backend you want to
          use, the stylesheet you want to use, and the style
          specification you want to use. If you mismatch any of the
          parameters, you'll get the wrong results. In practice,
          the problem is compounded further:</p>

          <div class="itemizedlist">
            <ul type="disc">
              <li>
                <p>Some stylesheets support several backends (RTF,
                TeX, and SGML). <a class="indexterm" name=
                "d0e12190"></a> <a class="indexterm" name=
                "d0e12194"></a></p>
              </li>

              <li>
                <p>Some stylesheets support only some backends (RTF
                and SGML, but not TeX or MIF).</p>
              </li>

              <li>
                <p>Some stylesheets support multiple outputs using
                the same backend (several kinds of HTML output, for
                example, using the SGML backend: HTML, HTMLHelp,
                JavaHelp, and so on).</p>
              </li>

              <li>
                <p>If you have complex stylesheets, some backends
                may require additional options to define parameter
                entities or stylesheet options.</p>
              </li>
            </ul>
          </div>

          <p>None of this complexity is really necessary, after
          all, the options don't change&#8212;you just have to use
          the correct combinations. The mental model is really
          something like this: &#8220;I want a certain kind of
          output, TeX say, so I have to use this combination of
          parameters.&#8221;</p>

          <p>You can summarize this information in a table to help
          keep track of it:</p>

          <div class="informaltable">
            <table border="0" style="border-collapse: collapse;">
              <colgroup>
                <col width="20%">
                <col align="center" width="20%">
                <col width="20%">
                <col width="20%">
                <col align="center" width="20%">
              </colgroup>

              <thead>
                <tr style="border-bottom: 0.5pt solid ; ">
                  <th style=
                  "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                  Desired Output</th>

                  <th style=
                  "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "
                   align="center">Backend</th>

                  <th style=
                  "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                  Style specification</th>

                  <th style=
                  "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                  Options</th>

                  <th style=
                  "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "
                   align="center">Supported?</th>
                </tr>
              </thead>

              <tbody>
                <tr>
                  <td style=
                  "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                  rtf</td>

                  <td style=
                  "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "
                   align="center">rtf</td>

                  <td style=
                  "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                  print</td>

                  <td style=
                  "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                  -V rtf-backend</td>

                  <td style=
                  "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "
                   align="center">yes</td>
                </tr>

                <tr>
                  <td style=
                  "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                  tex</td>

                  <td style=
                  "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "
                   align="center">tex</td>

                  <td style=
                  "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                  print</td>

                  <td style=
                  "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                  -V tex-backend -i tex</td>

                  <td style=
                  "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "
                   align="center">yes</td>
                </tr>

                <tr>
                  <td style=
                  "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                  html</td>

                  <td style=
                  "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "
                   align="center">sgml</td>

                  <td style=
                  "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                  htmlweb</td>

                  <td style=
                  "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                  -i html</td>

                  <td style=
                  "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "
                   align="center">yes</td>
                </tr>

                <tr>
                  <td style=
                  "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                  javahelp</td>

                  <td style=
                  "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "
                   align="center">sgml</td>

                  <td style=
                  "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                  help</td>

                  <td style=
                  "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                  -i help</td>

                  <td style=
                  "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "
                   align="center">yes</td>
                </tr>

                <tr>
                  <td style=
                  "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                  htmlhelp</td>

                  <td style=
                  "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "
                   align="center">&#160;</td>

                  <td style=
                  "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                  &#160;</td>

                  <td style=
                  "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">
                  &#160;</td>

                  <td style=
                  "border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "
                   align="center">no</td>
                </tr>
              </tbody>
            </table>
          </div>

          <p>Putting this information in a table will help you keep
          track of it, but it's not the best solution. The ideal
          solution is to keep this information on your system, and
          let the software figure it all out. You'd like to be able
          to run a command, tell it what output you want from what
          stylesheet, what file you want to process, and then let
          it figure everything else out. For example:</p>
<pre class="screen">
format html mybook.dsl mydoc.sgm
</pre>

          <p><a class="indexterm" name="d0e12315"></a> <a class=
          "indexterm" name="d0e12321"></a> One way to do this is to
          put the configuration data in a separate file, and have
          the <b>format</b> command load it out of this other file.
          The disadvantage of this solution is that it introduces
          another file that you have to maintain and it's
          independent from the stylesheet so it isn't easy to keep
          it up-to-date.</p>

          <p>In the DSSSL case, a better alternative is to modify
          the stylesheet DTD so you can store the configuration
          data <span class="emphasis"><em>in the
          stylesheet</em></span>. Using this alternate DTD, your
          <tt>mybook.dsl</tt> stylesheets might look like this:</p>
<pre class="screen">
&lt;!DOCTYPE style-sheet 
  PUBLIC "-//Norman Walsh//DTD Annotated DSSSL Style Sheet V1.2//EN" [
&lt;!-- perhaps additional declarations here --&gt;
]&gt;
&lt;style-sheet&gt;
&lt;title&gt;DocBook Stylesheet&lt;/title&gt;
&lt;doctype pubid="-//OASIS//DTD DocBook V3.1//EN"&gt;
&lt;doctype pubid="-//Davenport//DTD DocBook V3.0//EN"&gt;
&lt;doctype pubid="-//Norman Walsh//DTD Website V1.4//EN"&gt;
&lt;backend name="rtf"  backend="rtf"  fragid="print"
         options="-V rtf-backend" default="true"&gt;
&lt;backend name="tex"  backend="tex"  fragid="print"
         options="-V tex-backend -i tex"&gt;
&lt;backend name="html" backend="sgml" fragid="htmlweb" options="-i html"&gt;
&lt;backend name="javahelp" backend="sgml" fragid="help"  options="-i help"&gt;
&lt;backend name="htmlhelp" supported="no"&gt;
&lt;style-specification id="print" use="docbook"&gt;
&lt;style-specification-body&gt;
.
.
.

</pre>

          <p>In this example, the stylesheet has been annotated
          with a title, a list of the public IDs to which it is
          applicable, and a table that provides information about
          the output formats that it supports.</p>

          <p>Using this information, the <b>format</b> command can
          get all the information it needs to construct the
          appropriate call to Jade. To make HTML from
          <tt>myfile.sgm</tt>, <b>format</b> would run the
          following:</p>
<pre class="screen">
jade -t sgml -d mybook.dsl#htmlweb -i html myfile.sgm
</pre>

          <p>The additional information, titles and public IDs, can
          be used as part of a GUI interface to simplify the
          selection of stylesheets for an author.</p>

          <p>The complete annotated stylesheet DTD, and an example
          of the <b>format</b> command script, are provided on <a
          href="appe.html" title="What's on the CD-ROM?">the
          CD-ROM</a>. <a class="indexterm" name="d0e12391"></a> <a
          class="indexterm" name="d0e12393"></a></p>
        </div>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <h2 class="title" style="clear: both"><a name=
            "xsl"></a>A Brief Introduction to XSL</h2>
          </div>

          <div>
            <div class="author">
              <h3 class="author">Bob Stayton</h3>
            </div>
          </div>

          <div>
            <br clear="all">
          </div>
        </div>

        <div class="section" lang="en">
          <div class="titlepage">
            <div>
              <h3 class="title"><a name="d0e12409"></a>Using XSL
              tools to publish DocBook documents</h3>
            </div>
          </div>

          <p>There is a growing list of tools to process DocBook
          documents using XSL stylesheets. Each tool implements
          parts or all of the XSL standard, which actually has
          several components:</p>

          <div class="variablelist">
            <dl>
              <dt><span class="term">Extensible Stylesheet Language
              (XSL)</span></dt>

              <dd>
                <p>A language for expressing stylesheets written in
                XML. It includes the formatting object language,
                but refers to separate documents for the
                transformation language and the path language.</p>
              </dd>

              <dt><span class="term">XSL Transformation
              (XSLT)</span></dt>

              <dd>
                <p>The part of XSL for transforming XML documents
                into other XML documents, HTML, or text. It can be
                used to rearrange the content and generate new
                content.</p>
              </dd>

              <dt><span class="term">XML Path Language
              (XPath)</span></dt>

              <dd>
                <p>A language for addressing parts of an XML
                document. It is used to find the parts of your
                document to apply different styles to. All XSL
                processors use this component.</p>
              </dd>
            </dl>
          </div>
          <br>
          <br>

          <p>To publish HTML from your XML documents, you just need
          an XSLT engine. To get to print, you need an XSLT engine
          to produce formatting objects (FO), which then must be
          processed with a formatting object processor to produce
          PostScript or PDF output.</p>

          <p>James Clark's XT was the first useful XSLT engine, and
          it is still in wide use. It is written in Java, so it
          runs on many platforms, and it is free ( <a href=
          "http://www.jclark.com" target=
          "_top">http://www.jclark.com</a>). XT comes with James
          Clark's nonvalidating parser XP, but you can substitute a
          different Java parser. Here is a simple example of using
          XT from the Unix command line to produce HTML: You'll
          need to alter your <i><tt>CLASSPATH</tt></i> environment
          variable to include the path to where you put the
          <tt>.jar</tt> files from the XT distribution.</p>
<pre class="screen">
CLASSPATH=xt.jar:xp.jar:sax.jar
export CLASSPATH
java  com.jclark.xsl.sax.Driver <i><tt>filename.xml</tt></i> <i><tt>docbook/html/docbook.xsl</tt></i> &gt; <i><tt>output.html</tt></i>
</pre>

          <p>If you replace the HTML stylesheet with a formatting
          object stylesheet, XT will produce a formatting object
          file. Then you can convert that to PDF using FOP, a
          formatting object processor available for free from the
          Apache XML Project ( <a href="http://xml.apache.org"
          target="_top">http://xml.apache.org</a>). Here is an
          example of that two stage processing:</p>
<pre class="screen">
CLASSPATH=xt.jar:xp.jar:sax.jar:fop.jar
export CLASSPATH
java  com.jclark.xsl.sax.Driver <i><tt>filename.xml</tt></i> <i><tt>docbook/fo/docbook.xsl</tt></i> &gt; <i><tt>output.fo</tt></i>
java  org.apache.fop.apps.CommandLine <i><tt>output.fo</tt></i> <i><tt>output.pdf</tt></i>
</pre>

          <p>As of this writing, some other XSLT processors to
          choose from include:</p>

          <div class="itemizedlist">
            <ul type="disc">
              <li>
                <p>4XSLT, written in Python, from FourThought LLC (
                <a href="http://www.fourthought.com" target=
                "_top">http://www.fourthought.com</a>)</p>
              </li>

              <li>
                <p>Sablotron, written in C++, from Ginger Alliance
                ( <a href="http://www.gingerall.com" target=
                "_top">http://www.gingerall.com</a>)</p>
              </li>

              <li>
                <p>Saxon, written in Java, from Michael Kay ( <a
                href="http://users.iclway.co.uk/mhkay/saxon"
                target=
                "_top">http://users.iclway.co.uk/mhkay/saxon</a>)</p>
              </li>

              <li>
                <p>Xalan, written in Java, from the Apache XML
                Project ( <a href="http://xml.apache.org" target=
                "_top">http://xml.apache.org</a>)</p>
              </li>

              <li>
                <p>XML::XSLT,written in Perl, from Geert Josten and
                Egon Willighagen ( <a href="http://www.cpan.org"
                target="_top">http://www.cpan.org</a>)</p>
              </li>
            </ul>
          </div>

          <p>For print output, these additional tools are available
          for processing formatting objects:</p>

          <div class="itemizedlist">
            <ul type="disc">
              <li>
                <p>XEP (written in Java) from RenderX ( <a href=
                "http://www.renderx.com" target=
                "_top">http://www.renderx.com</a>).</p>
              </li>

              <li>
                <p>PassiveTeX from Sebastian Rahtz (<a href=
                "http://users.ox.ac.uk/~rahtz/passivetex/" target=
                "_top">http://users.ox.ac.uk/~rahtz/passivetex/</a>).</p>
              </li>
            </ul>
          </div>
        </div>

        <div class="section" lang="en">
          <div class="titlepage">
            <div>
              <h3 class="title"><a name="d0e12546"></a>A brief
              introduction to XSL</h3>
            </div>
          </div>

          <p>XSL is both a transformation language and a formatting
          language. The XSLT transformation part lets you scan
          through a document's structure and rearrange its content
          any way you like. You can write out the content using a
          different set of XML tags, and generate text as needed.
          For example, you can scan through a document to locate
          all headings and then insert a generated table of
          contents at the beginning of the document, at the same
          time writing out the content marked up as HTML. XSL is
          also a rich formatting language, letting you apply
          typesetting controls to all components of your output.
          With a good formatting backend, it is capable of
          producing high quality printed pages.</p>

          <p>An XSL stylesheet is written using XML syntax, and is
          itself a well-formed XML document. That makes the basic
          syntax familiar, and enables an XML processor to check
          for basic syntax errors. The stylesheet instructions use
          special element names, which typically begin with <tt
          class="sgmltag-element">xsl:</tt> to distinguish them
          from any XML tags you want to appear in the output. The
          XSL namespace is identified at the top of the stylesheet
          file. As with other XML, any XSL elements that are not
          empty will require a closing tag. And some XSL elements
          have specific attributes that control their behavior. It
          helps to keep a good XSL reference book handy.</p>

          <p>Here is an example of a simple XSL stylesheet applied
          to a simple XML file to generate HTML output.</p>

          <div class="example">
            <a name="d0e12579"></a>

            <p class="title"><b>Example&#160;4.9.&#160;Simple XML
            file</b></p>
<pre class="programlisting">
&lt;?xml version="1.0"?&gt;
&lt;document&gt;
&lt;title&gt;Using a mouse&lt;/title&gt;
&lt;para&gt;It's easy to use a mouse. Just roll it
around and click the buttons.&lt;/para&gt;
&lt;/document&gt;
</pre>
          </div>

          <div class="example">
            <a name="d0e12587"></a>

            <p class="title"><b>Example&#160;4.10.&#160;Simple XSL
            stylesheet</b></p>
<pre class="programlisting">
&lt;?xml version='1.0'?&gt;
&lt;xsl:stylesheet
          xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version='1.0'&gt;
&lt;xsl:output method="html"/&gt;

&lt;xsl:template match="document"&gt;
  &lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;
    &lt;xsl:value-of select="./title"/&gt;
  &lt;/TITLE&gt;
  &lt;/HEAD&gt;
  &lt;BODY&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/BODY&gt;
  &lt;/HTML&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="title"&gt;
  &lt;H1&gt;&lt;xsl:apply-templates/&gt;&lt;/H1&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="para"&gt;
  &lt;P&gt;&lt;xsl:apply-templates/&gt;&lt;/P&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</pre>
          </div>

          <div class="example">
            <a name="d0e12592"></a>

            <p class="title"><b>Example&#160;4.11.&#160;HTML
            output</b></p>
<pre class="programlisting">
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt;Using a mouse&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Using a mouse&lt;/H1&gt;
&lt;P&gt;It's easy to use a mouse. Just roll it
around and click the buttons.&lt;/P&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</pre>
          </div>
        </div>

        <div class="section" lang="en">
          <div class="titlepage">
            <div>
              <h3 class="title"><a name="d0e12597"></a>XSL
              processing model</h3>
            </div>
          </div>

          <p>XSL is a template language, not a procedural language.
          That means a stylesheet specifies a sample of the output,
          not a sequence of programming steps to generate it. A
          stylesheet consists of a mixture of output samples with
          instructions of what to put in each sample. Each bit of
          output sample and instructions is called a <span class=
          "emphasis"><em>template</em></span>.</p>

          <p>In general, you write a template for each element type
          in your document. That lets you concentrate on handling
          just one element at a time, and keeps a stylesheet
          modular. The power of XSL comes from processing the
          templates recursively. That is, each template handles the
          processing of its own element, and then calls other
          templates to process its children, and so on. Since an
          XML document is always a single root element at the top
          level that contains all of the nested descendent
          elements, the XSL templates also start at the top and
          work their way down through the hierarchy of
          elements.</p>

          <p>Take the DocBook <tt class=
          "sgmltag-element">&lt;para&gt;</tt> paragraph element as
          an example. To convert this to HTML, you want to wrap the
          paragraph content with the HTML tags <tt class=
          "sgmltag-starttag">&lt;&lt;p&gt;&gt;</tt> and <tt class=
          "sgmltag-endtag">&lt;/&lt;/p&gt;&gt;</tt>. But a DocBook
          <tt class="sgmltag-element">&lt;para&gt;</tt> can contain
          any number of in-line DocBook elements marking up the
          text. Fortunately, you can let other templates take care
          of those elements, so your XSL template for <tt class=
          "sgmltag-element">&lt;para&gt;</tt> can be quite
          simple:</p>
<pre class="programlisting">
&lt;xsl:template match="para"&gt;
  &lt;p&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;
</pre>

          <p>The <tt class=
          "sgmltag-element">&lt;xsl:template&gt;</tt> element
          starts a new template, and its <tt class=
          "sgmltag-attribute">match</tt> attribute indicates where
          to apply the template, in this case to any <tt class=
          "sgmltag-element">&lt;para&gt;</tt> elements. The
          template says to output a literal <tt class=
          "sgmltag-starttag">&lt;&lt;p&gt;&gt;</tt> string and then
          execute the <tt class=
          "sgmltag-element">&lt;xsl:apply-templates/&gt;</tt>
          instruction. This tells the XSL processor to look among
          all the templates in the stylesheet for any that should
          be applied to the content of the paragraph. If each
          template in the stylesheet includes an <tt class=
          "sgmltag-element">&lt;xsl:apply-templates/&gt;</tt>
          instruction, then all descendents will eventually be
          processed. When it is through recursively applying
          templates to the paragraph content, it outputs the <tt
          class="sgmltag-endtag">&lt;/&lt;/p&gt;&gt;</tt> closing
          tag.</p>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name="d0e12652"></a>Context is
                important</h4>
              </div>
            </div>

            <p>Since you aren't writing a linear procedure to
            process your document, the context of where and how to
            apply each modular template is important. The <tt
            class="sgmltag-attribute">match</tt> attribute of <tt
            class="sgmltag-element">&lt;xsl:template&gt;</tt>
            provides that context for most templates. There is an
            entire expression language, XPath, for identifying what
            parts of your document should be handled by each
            template. The simplest context is just an element name,
            as in the example above. But you can also specify
            elements as children of other elements, elements with
            certain attribute values, the first or last elements in
            a sequence, and so on. Here is how the DocBook <tt
            class="sgmltag-element">&lt;formalpara&gt;</tt> element
            is handled:</p>
<pre class="programlisting">
&lt;xsl:template match="formalpara"&gt;
  &lt;p&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="formalpara/title"&gt;
  &lt;b&gt;&lt;xsl:apply-templates/&gt;&lt;/b&gt;
  &lt;xsl:text&gt; &lt;/xsl:text&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="formalpara/para"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;
</pre>

            <p>There are three templates defined, one for the <tt
            class="sgmltag-element">&lt;formalpara&gt;</tt> element
            itself, and one for each of its children elements. The
            <tt class="sgmltag-attribute">match</tt> attribute
            value <tt>formalpara/title</tt> in the second template
            is an XPath expression indicating a <tt class=
            "sgmltag-element">&lt;title&gt;</tt> element that is an
            immediate child of a <tt class=
            "sgmltag-element">&lt;formalpara&gt;</tt> element. This
            distinguishes such titles from other <tt class=
            "sgmltag-element">&lt;title&gt;</tt> elements used in
            DocBook. XPath expressions are the key to controlling
            how your templates are applied.</p>

            <p>In general, the XSL processor has internal rules
            that apply templates that are more specific before
            templates that are less specific. That lets you control
            the details, but also provides a fallback mechanism to
            a less specific template when you don't supply the full
            context for every combination of elements. This feature
            is illustrated by the third template, for
            <tt>formalpara/para</tt>. By including this template,
            the stylesheet processes a <tt class=
            "sgmltag-element">&lt;para&gt;</tt> within <tt class=
            "sgmltag-element">&lt;formalpara&gt;</tt> in a special
            way, in this case by not outputting the HTML <tt class=
            "sgmltag-element">&lt;p&gt;</tt> tags already output by
            its parent. If this template had not been included,
            then the processor would have fallen back to the
            template specified by <tt class=
            "sgmltag-attribute">match="para"</tt> described above,
            which would have output a second set of <tt class=
            "sgmltag-element">&lt;p&gt;</tt> tags.</p>

            <p>You can also control template context with XSL <span
            class="emphasis"><em>modes</em></span>, which are used
            extensively in the DocBook stylesheets. Modes let you
            process the same input more than once in different
            ways. A <tt class="sgmltag-attribute">mode</tt>
            attribute in an <tt class=
            "sgmltag-element">&lt;xsl:template&gt;</tt> definition
            adds a specific mode name to that template. When the
            same mode name is used in <tt class=
            "sgmltag-element">&lt;xsl:apply-templates/&gt;</tt>, it
            acts as a filter to narrow the selection of templates
            to only those selected by the <tt class=
            "sgmltag-attribute">match</tt> expression <span class=
            "emphasis"><em>and</em></span> that have that mode
            name. This lets you define two different templates for
            the same element match that are applied under different
            contexts. For example, there are two templates defined
            for DocBook <tt class=
            "sgmltag-element">&lt;listitem&gt;</tt> elements:</p>
<pre class="programlisting">
&lt;xsl:template match="listitem"&gt;
  &lt;li&gt;&lt;xsl:apply-templates/&gt;&lt;/li&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="listitem" mode="xref"&gt;
  &lt;xsl:number format="1"/&gt;
&lt;/xsl:template&gt;
</pre>

            <p>The first template is for the normal list item
            context where you want to output the HTML <tt class=
            "sgmltag-element">&lt;li&gt;</tt> tags. The second
            template is called with <tt class=
            "sgmltag-element">&lt;xsl:apply-templates
            select="$target" mode="xref"/&gt;</tt> in the context
            of processing <tt class=
            "sgmltag-element">&lt;xref&gt;</tt> elements. In this
            case the <tt class="sgmltag-attribute">select</tt>
            attribute locates the ID of the specific list item and
            the <tt class="sgmltag-attribute">mode</tt> attribute
            selects the second template, whose effect is to output
            its item number when it is in an ordered list. Because
            there are many such special needs when processing <tt
            class="sgmltag-element">&lt;xref&gt;</tt> elements, it
            is convenient to define a mode name <tt>xref</tt> to
            handle them all. Keep in mind that mode settings do
            <span class="emphasis"><em>not</em></span>
            automatically get passed down to other templates
            through <tt class=
            "sgmltag-element">&lt;xsl:apply-templates/&gt;</tt>.</p>
          </div>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name=
                "d0e12762"></a>Programming features</h4>
              </div>
            </div>

            <p>Although XSL is template-driven, it also has some
            features of traditional programming languages. Here are
            some examples from the DocBook stylesheets.</p>
<pre class="programlisting">
<i class="lineannotation">Assign a value to a variable:</i>
&lt;xsl:variable name="refelem" select="name($target)"/&gt;

<i class="lineannotation">If statement:</i>
&lt;xsl:if test="$show.comments"&gt;
    &lt;i&gt;&lt;xsl:call-template name="inline.charseq"/&gt;&lt;/i&gt;
&lt;/xsl:if&gt;

<i class="lineannotation">Case statement:</i>
&lt;xsl:choose&gt;
    &lt;xsl:when test="@columns"&gt;
        &lt;xsl:value-of select="@columns"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;1&lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;

<i class=
"lineannotation">Call a template by name like a subroutine, passing parameter values and accepting a return value:</i>
&lt;xsl:call-template name="xref.xreflabel"&gt;
   &lt;xsl:with-param name="target" select="$target"/&gt;
&lt;/xsl:call-template&gt;
</pre>

            <p>However, you can't always use these constructs as
            you do in other programming languages. Variables in
            particular have very different behavior.</p>

            <div class="section" lang="en">
              <div class="titlepage">
                <div>
                  <h5 class="title"><a name="d0e12782"></a>Using
                  variables and parameters</h5>
                </div>
              </div>

              <p>XSL provides two elements that let you assign a
              value to a name: <tt class=
              "sgmltag-element">&lt;xsl:variable&gt;</tt> and <tt
              class="sgmltag-element">&lt;xsl:param&gt;</tt>. These
              share the same name space and syntax for assigning
              names and values. Both can be referred to using the
              <tt>$name</tt> syntax. The main difference between
              these two elements is that a param's value acts as a
              default value that can be overridden when a template
              is called using a <tt class=
              "sgmltag-element">&lt;xsl:with-param&gt;</tt> element
              as in the last example above.</p>

              <p>Here are two examples from DocBook:</p>
<pre class="programlisting">
&lt;xsl:param name="cols"&gt;1&lt;/xsl:param&gt;
&lt;xsl:variable name="segnum" select="position()"/&gt;
</pre>

              <p>In both elements, the name of the parameter or
              variable is specified with the <tt class=
              "sgmltag-attribute">name</tt> attribute. So the name
              of the <tt class="sgmltag-element">param</tt> here is
              <tt class="sgmltag-attvalue">cols</tt> and the name
              of the <tt class="sgmltag-element">variable</tt> is
              <tt class="sgmltag-attvalue">segnum</tt>. The value
              of either can be supplied in two ways. The value of
              the first example is the text node "1" and is
              supplied as the content of the element. The value of
              the second example is supplied as the result of the
              expression in its <tt class=
              "sgmltag-attribute">select</tt> attribute, and the
              element itself has no content.</p>

              <p>The feature of XSL variables that is odd to new
              users is that once you assign a value to a variable,
              you cannot assign a new value within the same scope.
              Doing so will generate an error. So variables are not
              used as dynamic storage bins they way they are in
              other languages. They hold a fixed value within their
              scope of application, and then disappear when the
              scope is exited. This feature is a result of the
              design of XSL, which is template-driven and not
              procedural. This means there is no definite order of
              processing, so you can't rely on the values of
              changing variables. To use variables in XSL, you need
              to understand how their scope is defined.</p>

              <p>Variables defined outside of all templates are
              considered global variables, and they are readable
              within all templates. The value of a global variable
              is fixed, and its global value can't be altered from
              within any template. However, a template can create a
              local variable of the same name and give it a
              different value. That local value remains in effect
              only within the scope of the local variable.</p>

              <p>Variables defined within a template remain in
              effect only within their permitted scope, which is
              defined as all following siblings and their
              descendants. To understand such a scope, you have to
              remember that XSL instructions are true XML elements
              that are embedded in an XML family hierarchy of XSL
              elements, often referred to as parents, children,
              siblings, ancestors and descendants. Taking the
              family analogy a step further, think of a variable
              assignment as a piece of advice that you are allowed
              to give to certain family members. You can give your
              advice only to your younger siblings (those that
              follow you) and their descendents. Your older
              siblings won't listen, neither will your parents or
              any of your ancestors. To stretch the analogy a bit,
              it is an error to try to give different advice under
              the same name to the same group of listeners (in
              other words, to redefine the variable). Keep in mind
              that this family is not the elements of your
              document, but just the XSL instructions in your
              stylesheet. To help you keep track of such scopes in
              hand-written stylesheets, it helps to indent nested
              XSL elements. Here is an edited snippet from the
              DocBook stylesheet file <tt>pi.xsl</tt> that
              illustrates different scopes for two variables:</p>
<pre class="programlisting">
 1 &lt;xsl:template name="dbhtml-attribute"&gt;
 2 ...
 3    &lt;xsl:choose&gt;
 4       &lt;xsl:when test="$count&gt;count($pis)"&gt;
 5          &lt;!-- not found --&gt;
 6       &lt;/xsl:when&gt;
 7       &lt;xsl:otherwise&gt;
 8          &lt;xsl:variable name="pi"&gt;
 9             &lt;xsl:value-of select="$pis[$count]"/&gt;
10          &lt;/xsl:variable&gt;
11          &lt;xsl:choose&gt;
12             &lt;xsl:when test="contains($pi,concat($attribute, '='))"&gt;
13                &lt;xsl:variable name="rest" select="substring-after($pi,concat($attribute,'='))"/&gt;
14                &lt;xsl:variable name="quote" select="substring($rest,1,1)"/&gt;
15                &lt;xsl:value-of select="substring-before(substring($rest,2),$quote)"/&gt;
16             &lt;/xsl:when&gt;
17             &lt;xsl:otherwise&gt;
18             ...
19             &lt;/xsl:otherwise&gt;
20          &lt;/xsl:choose&gt;
21       &lt;/xsl:otherwise&gt;
22    &lt;/xsl:choose&gt;
23 &lt;/xsl:template&gt;

</pre>

              <p>The scope of the variable <tt>pi</tt> begins on
              line 8 where it is defined in this template, and ends
              on line 20 when its last sibling ends.<sup>[<a name=
              "d0e12845" href="#ftn.d0e12845">17</a>]</sup> The
              scope of the variable <tt>rest</tt> begins on line 13
              and ends on line 15. Fortunately, line 15 outputs an
              expression using the value before it goes out of
              scope.</p>

              <p>What happens when an <tt class=
              "sgmltag-element">&lt;xsl:apply-templates/&gt;</tt>
              element is used within the scope of a local variable?
              Do the templates that are applied to the document
              children get the variable? The answer is no. The
              templates that are applied are not actually within
              the scope of the variable. They exist elsewhere in
              the stylesheet and are not following siblings or
              their descendants.</p>

              <p>To pass a value to another template, you pass a
              parameter using the <tt class=
              "sgmltag-element">&lt;xsl:with-param&gt;</tt>
              element. This parameter passing is usually done with
              calls to a specific named template using <tt class=
              "sgmltag-element">&lt;xsl:call-template&gt;</tt>,
              although it works with <tt class=
              "sgmltag-element">&lt;xsl:apply-templates&gt;</tt>
              too. That's because the called template must be
              expecting the parameter by defining it using a <tt
              class="sgmltag-element">&lt;xsl:param&gt;</tt>
              element with the same parameter name. Any passed
              parameters whose names are not defined in the called
              template are ignored.</p>

              <p>Here is an example of parameter passing from
              <tt>docbook.xsl</tt>:</p>
<pre class="programlisting">
&lt;xsl:call-template name="head.content"&gt;
   &lt;xsl:with-param name="node" select="$doc"/&gt;
&lt;/xsl:call-template&gt;
</pre>

              <p>Here a template named <tt>head.content</tt> is
              being called and passed a parameter named
              <i><tt>node</tt></i> whose content is the value of
              the <tt>$doc</tt> variable in the current context.
              The top of that template looks like this:</p>
<pre class="programlisting">
&lt;xsl:template name="head.content"&gt;
   &lt;xsl:param name="node" select="."/&gt;
</pre>

              <p>The template is expecting the parameter because it
              has a <tt class=
              "sgmltag-element">&lt;xsl:param&gt;</tt> defined with
              the same name. The value in this definition is the
              default value. This would be the parameter value used
              in the template if the template was called without
              passing that parameter.</p>
            </div>
          </div>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name="d0e12899"></a>Generating
                HTML output.</h4>
              </div>
            </div>

            <p>You generate HTML from your DocBook XML files by
            applying the HTML version of the stylesheets. This is
            done by using the HTML driver file
            <tt>docbook/html/docbook.xsl</tt> as your stylesheet.
            That is the master stylesheet file that uses <tt class=
            "sgmltag-element">&lt;xsl:include&gt;</tt> to pull in
            the component files it needs to assemble a complete
            stylesheet for producing HTML.</p>

            <p>The way the DocBook stylesheet generates HTML is to
            apply templates that output a mix of text content and
            HTML elements. Starting at the top level in the main
            file <tt>docbook.xsl</tt>:</p>
<pre class="programlisting">
&lt;xsl:template match="/"&gt;
  &lt;xsl:variable name="doc" select="*[1]"/&gt;
  &lt;html&gt;
  &lt;head&gt;
    &lt;xsl:call-template name="head.content"&gt;
      &lt;xsl:with-param name="node" select="$doc"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;
</pre>

            <p>This template matches the root element of your input
            document, and starts the process of recursively
            applying templates. It first defines a variable named
            <tt>doc</tt> and then outputs two literal HTML elements
            <tt class="sgmltag-element">&lt;html&gt;</tt> and <tt
            class="sgmltag-element">&lt;head&gt;</tt>. Then it
            calls a named template <tt>head.content</tt> to process
            the content of the HTML <tt class=
            "sgmltag-element">&lt;head&gt;</tt>, closes the <tt
            class="sgmltag-element">&lt;head&gt;</tt> and starts
            the <tt class="sgmltag-element">&lt;body&gt;</tt>.
            There it uses <tt class=
            "sgmltag-emptytag">&lt;&lt;xsl:apply-templates/&gt;/&gt;</tt>
            to recursively process the entire input document. Then
            it just closes out the HTML file.</p>

            <p>Simple HTML elements can generated as literal
            elements as shown here. But if the HTML being output
            depends on the context, you need something more
            powerful to select the element name and possibly add
            attributes and their values. Here is a fragment from
            <tt>sections.xsl</tt> that shows how a heading tag is
            generated using the <tt class=
            "sgmltag-element">&lt;xsl:element&gt;</tt> and <tt
            class="sgmltag-element">&lt;xsl:attribute&gt;</tt>
            elements:</p>
<pre class="programlisting">
 1 &lt;xsl:element name="h{$level}"&gt;
 2   &lt;xsl:attribute name="class"&gt;title&lt;/xsl:attribute&gt;
 3   &lt;xsl:if test="$level&lt;3"&gt;
 4     &lt;xsl:attribute name="style"&gt;clear: all&lt;/xsl:attribute&gt;
 5   &lt;/xsl:if&gt;
 6   &lt;a&gt;
 7     &lt;xsl:attribute name="name"&gt;
 8       &lt;xsl:call-template name="object.id"/&gt;
 9     &lt;/xsl:attribute&gt;
10     &lt;b&gt;&lt;xsl:copy-of select="$title"/&gt;&lt;/b&gt;
11   &lt;/a&gt;
12 &lt;/xsl:element&gt;
</pre>

            <p>This whole example is generating a single HTML
            heading element. Line 1 begins the HTML element
            definition by identifying the name of the element. In
            this case, the name is an expression that includes the
            variable <i><tt>$level</tt></i> passed as a parameter
            to this template. Thus a single template can generate
            <tt class="sgmltag-element">&lt;h1&gt;</tt>, <tt class=
            "sgmltag-element">&lt;h2&gt;</tt>, etc. depending on
            the context in which it is called. Line 2 defines a <tt
            class="sgmltag-attribute">class="title"</tt> attribute
            that is added to this element. Lines 3 to 5 add a <tt
            class="sgmltag-attribute">style="clear all"</tt>
            attribute, but only if the heading level is less than
            3. Line 6 opens an <tt class=
            "sgmltag-element">&lt;a&gt;</tt> anchor element.
            Although this looks like a literal output string, it is
            actually modified by lines 7 to 9 that insert the <tt
            class="sgmltag-attribute">name</tt> attribute into the
            <tt class="sgmltag-element">&lt;a&gt;</tt> element.
            This illustrates that XSL is managing output elements
            as active element nodes, not just text strings. Line 10
            outputs the text of the heading title, also passed as a
            parameter to the template, enclosed in HTML boldface
            tags. Line 11 closes the anchor tag with the literal
            <tt class="sgmltag-endtag">&lt;/&lt;/a&gt;&gt;</tt>
            syntax, while line 12 closes the heading tag by closing
            the element definition. Since the actual element name
            is a variable, it couldn't use the literal syntax.</p>

            <p>As you follow the sequence of nested templates
            processing elements, you might be wondering how the
            ordinary text of your input document gets to the
            output. In the file <tt>docbook.xsl</tt> you will find
            this template that handles any text not processed by
            any other template:</p>
<pre class="programlisting">
&lt;xsl:template match="text()"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;
</pre>

            <p>This template's body consists of the "value" of the
            text node, which is just its text. In general, all XSL
            processors have some built-in templates to handle any
            content for which your stylesheet doesn't supply a
            matching template. This template serves the same
            function but appears explicitly in the stylesheet.</p>
          </div>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name="d0e12997"></a>Generating
                formatting objects.</h4>
              </div>
            </div>

            <p>You generate formatting objects from your DocBook
            XML files by applying the fo version of the
            stylesheets. This is done by using the fo driver file
            <tt>docbook/fo/docbook.xsl</tt> as your stylesheet.
            That is the master stylesheet file that uses <tt class=
            "sgmltag-element">&lt;xsl:include&gt;</tt> to pull in
            the component files it needs to assemble a complete
            stylesheet for producing formatting objects. Generating
            a formatting objects file is only half the process of
            producing typeset output. You also need a formatting
            object processor such as the Apache XML Project's FOP
            as described in an earlier section.</p>

            <p>The DocBook fo stylesheet works in a similar manner
            to the HTML stylesheet. Instead of outputting HTML
            tags, it outputs text marked up with <tt class=
            "sgmltag-element">&lt;fo:<i><tt>something</tt></i>&gt;</tt>
            tags. For example, to indicate that some text should be
            kept in-line and typeset with a monospace font, it
            might look like this:</p>
<pre class="programlisting">
&lt;fo:inline-sequence font-family="monospace"&gt;/usr/man&lt;/fo:inline-sequence&gt;
</pre>

            <p>The templates in <tt>docbook/fo/inline.xsl</tt> that
            produce this output for a DocBook <tt class=
            "sgmltag-element">&lt;filename&gt;</tt> element look
            like this:</p>
<pre class="programlisting">
&lt;xsl:template match="filename"&gt;
  &lt;xsl:call-template name="inline.monoseq"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template name="inline.monoseq"&gt;
  &lt;xsl:param name="content"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:param&gt;
  &lt;fo:inline-sequence font-family="monospace"&gt;
    &lt;xsl:copy-of select="$content"/&gt;
  &lt;/fo:inline-sequence&gt;
&lt;/xsl:template&gt;
</pre>

            <p>There are dozens of fo tags and attributes specified
            in the XSL standard. It is beyond the scope of this
            document to cover how all of them are used in the
            DocBook stylesheets. Fortunately, this is only an
            intermediate format that you probably won't have to
            deal with very much directly unless you are writing
            your own stylesheets.</p>
          </div>
        </div>

        <div class="section" lang="en">
          <div class="titlepage">
            <div>
              <h3 class="title"><a name="d0e13036"></a>Customizing
              DocBook XSL stylesheets</h3>
            </div>
          </div>

          <p>The DocBook XSL stylesheets are written in a modular
          fashion. Each of the HTML and FO stylesheets starts with
          a driver file that assembles a collection of component
          files into a complete stylesheet. This modular design
          puts similar things together into smaller files that are
          easier to write and maintain than one big stylesheet. The
          modular stylesheet files are distributed among four
          directories:</p>

          <div class="variablelist">
            <dl>
              <dt><span class="term">common/</span></dt>

              <dd>
                <p>contains code common to both stylesheets,
                including localization data</p>
              </dd>

              <dt><span class="term">fo/</span></dt>

              <dd>
                <p>a stylesheet that produces XSL FO result
                trees</p>
              </dd>

              <dt><span class="term">html/</span></dt>

              <dd>
                <p>a stylesheet that produces HTML/XHTML result
                trees</p>
              </dd>

              <dt><span class="term">lib/</span></dt>

              <dd>
                <p>contains schema-independent functions</p>
              </dd>
            </dl>
          </div>

          <p>The driver files for each of HTML and FO stylesheets
          are <tt>html/docbook.xsl</tt> and
          <tt>fo/docbook.xsl</tt>, respectively. A driver file
          consists mostly of a bunch of <tt class=
          "sgmltag-element">&lt;xsl:include&gt;</tt> instructions
          to pull in the component templates, and then defines some
          top-level templates. For example:</p>
<pre class="programlisting">
&lt;xsl:include href="../VERSION"/&gt;
&lt;xsl:include href="../lib/lib.xsl"/&gt;
&lt;xsl:include href="../common/l10n.xsl"/&gt;
&lt;xsl:include href="../common/common.xsl"/&gt;
&lt;xsl:include href="autotoc.xsl"/&gt;
&lt;xsl:include href="lists.xsl"/&gt;
&lt;xsl:include href="callout.xsl"/&gt;
...
&lt;xsl:include href="param.xsl"/&gt;
&lt;xsl:include href="pi.xsl"/&gt;
</pre>

          <p>The first four modules are shared with the FO
          stylesheet and are referenced using relative pathnames to
          the common directories. Then the long list of component
          stylesheets starts. Pathnames in include statements are
          always taken to be relative to the including file. Each
          included file must be a valid XSL stylesheet, which means
          its root element must be <tt class=
          "sgmltag-element">&lt;xsl:stylesheet&gt;</tt>.</p>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name="d0e13084"></a>Stylesheet
                inclusion vs. importing</h4>
              </div>
            </div>

            <p>XSL actually provides two inclusion mechanisms: <tt
            class="sgmltag-element">&lt;xsl:include&gt;</tt> and
            <tt class="sgmltag-element">&lt;xsl:import&gt;</tt>. Of
            the two, <tt class=
            "sgmltag-element">&lt;xsl:include&gt;</tt> is the
            simpler. It treats the included content as if it were
            actually typed into the file at that point, and doesn't
            give it any more or less precedence relative to the
            surrounding text. It is best used when assembling
            dissimilar templates that don't overlap what they
            match. The DocBook driver files use this instruction to
            assemble a set of modules into a stylesheet.</p>

            <p>In contrast, <tt class=
            "sgmltag-element">&lt;xsl:import&gt;</tt> lets you
            manage the precedence of templates and variables. It is
            the preferred mode of customizing another stylesheet
            because it lets you override definitions in the
            distributed stylesheet with your own, without altering
            the distribution files at all. You simply import the
            whole stylesheet and add whatever changes you want.</p>

            <p>The precedence rules for import are detailed and
            rigorously defined in the XSL standard. The basic rule
            is that any templates and variables in the importing
            stylesheet have precedence over equivalent templates
            and variables in the imported stylesheet. Think of the
            imported stylesheet elements as a fallback collection,
            to be used only if a match is not found in the current
            stylesheet. You can customize the templates you want to
            change in your stylesheet file, and let the imported
            stylesheet handle the rest.</p>

            <div class="note" style=
            "margin-left: 0.5in; margin-right: 0.5in;">
              <h3 class="title">Note</h3>

              <p>Customizing a DocBook XSL stylesheet is the
              opposite of customizing a DocBook DTD. When you
              customize a DocBook DTD, the rules of XML and SGML
              dictate that the <span class=
              "emphasis"><em>first</em></span> of any duplicate
              declarations wins. Any subsequent declarations of the
              same element or entity are ignored. The architecture
              of the DTD provides slots for inserting your own
              custom declarations early enough in the DTD for them
              to override the standard declarations. In contrast,
              customizing an XSL stylesheet is simpler because your
              definitions have precedence over imported ones.</p>
            </div>

            <p>You can carry modularization to deeper levels
            because module files can also include or import other
            modules. You'll need to be careful to maintain the
            precedence that you want as the modules get rolled up
            into a complete stylesheet.</p>
          </div>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name=
                "d0e13119"></a>Customizing with <tt class=
                "sgmltag-element">&lt;xsl:import&gt;</tt></h4>
              </div>
            </div>

            <p>There is currently one example of customizing with
            <tt class="sgmltag-element">&lt;xsl:import&gt;</tt> in
            the HTML version of the DocBook stylesheets. The
            <tt>xtchunk.xsl</tt> stylesheet modifies the HTML
            processing to output many smaller HTML files rather
            than a single large file per input document. It uses
            XSL extensions defined only in the XSL processor
            <b>XT</b>. In the driver file <tt>xtchunk.xsl</tt>, the
            first instruction is <tt class=
            "sgmltag-element">&lt;xsl:import
            href="docbook.xsl"/&gt;</tt>. That instruction imports
            the original driver file, which in turn uses many <tt
            class="sgmltag-element">&lt;xsl:include&gt;</tt>
            instructions to include all the modules. That single
            import instruction gives the new stylesheet the
            complete set of DocBook templates to start with.</p>

            <p>After the import, <tt>xtchunk.xsl</tt> redefines
            some of the templates and adds some new ones. Here is
            one example of a redefined template:</p>
<pre class="programlisting">
<i class="lineannotation">Original template in autotoc.xsl</i>
&lt;xsl:template name="href.target"&gt;
  &lt;xsl:param name="object" select="."/&gt;
  &lt;xsl:text&gt;#&lt;/xsl:text&gt;
  &lt;xsl:call-template name="object.id"&gt;
    &lt;xsl:with-param name="object" select="$object"/&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;

<i class="lineannotation">New template in xtchunk.xsl</i>
&lt;xsl:template name="href.target"&gt;
  &lt;xsl:param name="object" select="."/&gt;
  &lt;xsl:variable name="ischunk"&gt;
    &lt;xsl:call-template name="chunk"&gt;
      &lt;xsl:with-param name="node" select="$object"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:variable&gt;

  &lt;xsl:apply-templates mode="chunk-filename" select="$object"/&gt;

  &lt;xsl:if test="$ischunk='0'"&gt;
    &lt;xsl:text&gt;#&lt;/xsl:text&gt;
    &lt;xsl:call-template name="object.id"&gt;
      &lt;xsl:with-param name="object" select="$object"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:if&gt;
&lt;/xsl:template&gt;
</pre>

            <p>The new template handles the more complex processing
            of HREFs when the output is split into many HTML files.
            Where the old template could simply output
            <tt>#<i><tt>object.id</tt></i></tt>, the new one
            outputs
            <tt><i><tt>filename</tt></i>#<i><tt>object.id</tt></i></tt>.</p>
          </div>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name="d0e13170"></a>Setting
                stylesheet variables</h4>
              </div>
            </div>

            <p>You may not have to define any new templates,
            however. The DocBook stylesheets are parameterized
            using XSL variables rather than hard-coded values for
            many of the formatting features. Since the <tt class=
            "sgmltag-element">&lt;xsl:import&gt;</tt> mechanism
            also lets you redefine global variables, this gives you
            an easy way to customize many features of the DocBook
            stylesheets. Over time, more features will be
            parameterized to permit customization. If you find
            hardcoded values in the stylesheets that would be
            useful to customize, please let the maintainer
            know.</p>

            <p>Near the end of the list of includes in the main
            DocBook driver file is the instruction <tt class=
            "sgmltag-element">&lt;xsl:include
            href="param.xsl"/&gt;</tt>. The <tt>param.xsl</tt> file
            is the most important module for customizing a DocBook
            XSL stylesheet. This module contains no templates, only
            definitions of stylesheet variables. Since these
            variables are defined outside of any template, they are
            global variables and apply to the entire stylesheet. By
            redefining these variables in an importing stylesheet,
            you can change the behavior of the stylesheet.</p>

            <p>To create a customized DocBook stylesheet, you
            simply create a new stylesheet file such as
            <tt>mystyle.xsl</tt> that imports the standard
            stylesheet and adds your own new variable definitions.
            Here is an example of a complete custom stylesheet that
            changes the depth of sections listed in the table of
            contents from two to three:</p>
<pre class="programlisting">
&lt;?xml version='1.0'?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version='1.0'
                xmlns="http://www.w3.org/TR/xhtml1/transitional"
                exclude-result-prefixes="#default"&gt;

&lt;xsl:import href="docbook.xsl"/&gt;

&lt;xsl:variable name="toc.section.depth"&gt;3&lt;/xsl:variable&gt;
&lt;!-- Add other variable definitions here --&gt;

&lt;/xsl:stylesheet&gt;
</pre>

            <p>Following the opening stylesheet element are the
            import instruction and one variable definition. The
            variable <tt>toc.section.depth</tt> was defined in
            <tt>param.xsl</tt> with value "2", and here it is
            defined as "3". Since the importing stylesheet takes
            precedence, this new value is used. Thus documents
            processed with <tt>mystyle.xsl</tt> instead of
            <tt>docbook.xsl</tt> will have three levels of sections
            in the tables of contents, and all other processing
            will be the same.</p>

            <p>Use the list of variables in <tt>param.xsl</tt> as
            your guide for creating a custom stylesheet. If the
            changes you want are controlled by a variable there,
            then customizing is easy.</p>
          </div>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name="d0e13212"></a>Writing
                your own templates</h4>
              </div>
            </div>

            <p>If the changes you want are more extensive than what
            is supported by variables, you can write new templates.
            You can put your new templates directly in your
            importing stylesheet, or you can modularize your
            importing stylesheet as well. You can write your own
            stylesheet module containing a collection of templates
            for processing lists, for example, and put them in a
            file named <tt>mylists.xsl</tt>. Then your importing
            stylesheet can pull in your list templates with a <tt
            class="sgmltag-element">&lt;xsl:include
            href="mylists.xsl"/&gt;</tt> instruction. Since your
            included template definitions appear after the main
            import instruction, your templates will take
            precedence.</p>

            <p>You'll need to make sure your new templates are
            compatible with the remaining modules, which means:</p>

            <div class="itemizedlist">
              <ul type="disc">
                <li>
                  <p>Any named templates should use the same name
                  so calling templates in other modules can find
                  them.</p>
                </li>

                <li>
                  <p>Your template set should process the same
                  elements matched by templates in the original
                  module, to ensure complete coverage.</p>
                </li>

                <li>
                  <p>Include the same set of <tt class=
                  "sgmltag-element">&lt;xsl:param&gt;</tt> elements
                  in each template to interface properly with any
                  calling templates, although you can set different
                  values for your parameters.</p>
                </li>

                <li>
                  <p>Any templates that are used like subroutines
                  to return a value should return the same data
                  type.</p>
                </li>
              </ul>
            </div>
          </div>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name="d0e13241"></a>Writing
                your own driver</h4>
              </div>
            </div>

            <p>Another approach to customizing the stylesheets is
            to write your own driver file. Instead of using <tt
            class="sgmltag-element">&lt;xsl:import
            href="docbook.xsl"/&gt;</tt>, you copy that file to a
            new name and rewrite any of the <tt class=
            "sgmltag-element">&lt;xsl:include/&gt;</tt>
            instructions to assemble a custom collection of
            stylesheet modules. One reason to do this is to speed
            up processing by reducing the size of the stylesheet.
            If you are using a customized DocBook DTD that omits
            many elements you never use, you might be able to omit
            those modules of the stylesheet.</p>
          </div>

          <div class="section" lang="en">
            <div class="titlepage">
              <div>
                <h4 class="title"><a name=
                "d0e13252"></a>Localization</h4>
              </div>
            </div>

            <p>The DocBook stylesheets include features for
            localizing generated text, that is, printing any
            generated text in a language other than the default
            English. In general, the stylesheets will switch to the
            language identified by a <tt class=
            "sgmltag-attribute">lang</tt> attribute when processing
            elements in your documents. If your documents use the
            <tt class="sgmltag-attribute">lang</tt> attribute, then
            you don't need to customize the stylesheets at all for
            localization.</p>

            <p>As far as the stylesheets go, a <tt class=
            "sgmltag-attribute">lang</tt> attribute is inherited by
            the descendents of a document element. The stylesheet
            searches for a <tt class="sgmltag-attribute">lang</tt>
            attribute using this XPath expression:</p>
<pre class="programlisting">
&lt;xsl:variable name="lang-attr"
         select="($target/ancestor-or-self::*/@lang
                  |$target/ancestor-or-self::*/@xml:lang)[last()]"/&gt;
</pre>

            <p>This locates the attribute on the current element or
            its most recent ancestor. Thus a <tt class=
            "sgmltag-attribute">lang</tt> attribute is in effect
            for an element and all of its descendents, unless it is
            reset in one of those descendents. If you define it in
            only your document root element, then it applies to the
            whole document:</p>
<pre class="programlisting">
&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.0//EN" "docbook.dtd"&gt;
&lt;book lang="fr"&gt;
...
&lt;/book&gt;
</pre>

            <p>When text is being generated, the stylesheet checks
            the most recent <tt class="sgmltag-attribute">lang</tt>
            attribute and looks up the generated text strings for
            that language in a localization XML file. These are
            located in the <tt>common</tt> directory of the
            stylesheets, one file per language. Here is the top of
            the file <tt>fr.xml</tt>:</p>
<pre class="programlisting">
&lt;localization language="fr"&gt;

&lt;gentext key="abstract"                 text="R&amp;#x00E9;sum&amp;#x00E9;"/&gt;
&lt;gentext key="answer"                   text="R:"/&gt;
&lt;gentext key="appendix"                 text="Annexe"/&gt;
&lt;gentext key="article"                  text="Article"/&gt;
&lt;gentext key="bibliography"             text="Bibliographie"/&gt;
...
</pre>

            <p>The stylesheet templates use the gentext key names,
            and then the stylesheet looks up the associated text
            value when the document is processed with that lang
            setting. The file <tt>l10n.xml</tt> (note the
            <tt>.xml</tt> suffix) lists the filenames of all the
            supported languages.</p>

            <p>You can also create a custom stylesheet that sets
            the language. That might be useful if your documents
            don't make appropriate use of the <tt class=
            "sgmltag-attribute">lang</tt> attribute. The module
            <tt>l10n.xsl</tt> defines two global variables that can
            be overridden with an importing stylesheet as described
            above. Here are their default definitions:</p>
<pre class="programlisting">
&lt;xsl:variable name="l10n.gentext.language"&gt;&lt;/xsl:variable&gt;
&lt;xsl:variable name="l10n.gentext.default.language"&gt;en&lt;/xsl:variable&gt;
</pre>

            <p>The first one sets the language for all elements,
            regardless of an element's <tt class=
            "sgmltag-attribute">lang</tt> attribute value. The
            second just sets a default language for any elements
            that haven't got a <tt class=
            "sgmltag-attribute">lang</tt> setting of their own (or
            their ancestors).</p>
          </div>
        </div>
      </div>

      <div class="footnotes">
        <br>
        <hr width="100" align="left">

        <div class="footnote">
          <p><sup>[<a name="ftn.d0e9264" href=
          "#d0e9264">14</a>]</sup> See <i><a href=
          "http://www-cals.itsi.disa.mil/core/formal/fps.htm"
          target="_top">Formally Published CALS Standards</a></i>
          for more information.</p>
        </div>

        <div class="footnote">
          <p><sup>[<a name="ftn.d0e11537" href=
          "#d0e11537">15</a>]</sup> Language codes should conform
          to IETF RFC 3066.</p>
        </div>

        <div class="footnote">
          <p><sup>[<a name="ftn.d0e12138" href=
          "#d0e12138">16</a>]</sup> The use of uppercase names here
          is intentional. These are not attributes that an author
          is ever expected to type. In XML, which is
          case-sensitive, using uppercase for things like this
          reduces the likelihood of collision with
          &#8220;real&#8221; attribute names in the DTD.</p>
        </div>

        <div class="footnote">
          <p><sup>[<a name="ftn.d0e12845" href=
          "#d0e12845">17</a>]</sup> Technically, the scope extends
          to the end tag of the parent of the <tt class=
          "sgmltag-element">&lt;xsl:variable&gt;</tt> element. That
          is effectively the last sibling.</p>
        </div>
      </div>
    </div>

    <div class="navfooter">
      <table width="100%" summary="Navigation table">
        <tr>
          <td width="40%" align="left"><a title=
          "Parsing DocBook Documents" href="ch03.html"><img src=
          "figures/nav-prev.png" alt="Prev" border="0"></a>&#160;</td>

          <td width="20%" align="center"><a title="DocBook" href=
          "docbook.html"><img src="figures/nav-home.png" alt="Home"
          border="0"></a></td>

          <td width="40%" align="right">&#160;<a title=
          "Customizing DocBook" href="ch05.html"><img src=
          "figures/nav-next.png" alt="Next" border="0"></a></td>
        </tr>

        <tr>
          <td width="40%" align="left">Parsing DocBook
          Documents&#160;</td>

          <td width="20%" align="center"><a title=
          "Part&#160;I.&#160;Introduction" href="part1.html"><img
          src="figures/nav-up.png" alt="Up" border="0"></a></td>

          <td width="40%" align="right">&#160;Customizing
          DocBook</td>
        </tr>
      </table>
    </div>

    <div class="copyrightfooter">
      <p><a href="dbcpyright.html">Copyright</a> &#169; 1999, 2000,
      2001, 2002 <a href="http://www.oreilly.com/">O'Reilly &amp;
      Associates, Inc.</a> All rights reserved.</p>
    </div>
  </body>
</html>

