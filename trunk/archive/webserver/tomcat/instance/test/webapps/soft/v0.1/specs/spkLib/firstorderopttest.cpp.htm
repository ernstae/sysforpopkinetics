<html><head>
<title>firstOrderOpt: Example and Test</title>
<meta name="description" id="description" content="firstOrderOpt: Example and Test">
<meta name="keywords" id="keywords" content=" ">
<style type='text/css'>
BODY { color : black }
BODY { background-color : white }
</style>
<script type='text/javascript' language='JavaScript' src='_firstorderopttest.cpp_htm.js'>
</script>
</head>
<body>
<table><tr>
<td>
<a href="http://depts.washington.edu/rfpk" target="_top"><img border="0" src="_image.gif"></a>
</td>
<td>
<select onchange='choose_across0(this)'>
<option>Index-&gt;</option>
<option>contents</option>
<option>reference</option>
<option>index</option>
<option>search</option>
<option>external</option>
</select>
</td>
<td>
<select onchange='choose_up0(this)'>
<option>Up-&gt;</option>
<option>main</option>
<option>population</option>
<option>firstOrderOpt</option>
<option>firstOrderOptTest.cpp</option>
</select>
</td>
<td><a href="firstorderopt.htm" target="_top">Prev</a>
</td><td><a href="fitpopulation.htm" target="_top">Next</a>
</td><td>
<select onchange='choose_down3(this)'>
<option>main-&gt;</option>
<option>Notes</option>
<option>SpkModel</option>
<option>individual</option>
<option>population</option>
<option>statistical</option>
<option>simulation</option>
<option>general</option>
<option>glossary</option>
</select>
</td>
<td>
<select onchange='choose_down2(this)'>
<option>population-&gt;</option>
<option>estimateB</option>
<option>expectedHessian</option>
<option>ExpectedHessianFuncOb</option>
<option>ExpectedHessianValarrayFuncOb</option>
<option>firstOrderOpt</option>
<option>fitPopulation</option>
<option>EqIndModel</option>
<option>lambda</option>
<option>lambda_alp</option>
<option>lambda_b</option>
<option>lambdaFuncOb</option>
<option>lambdaDiff</option>
<option>lambda2diff</option>
<option>lTilde</option>
<option>NaiveFoModel</option>
<option>namespace_population_analysis</option>
<option>Objective</option>
<option>ppkaOpt</option>
<option>popResiduals</option>
<option>popStatistics</option>
<option>popStatistics_DerivExist</option>
<option>popStatistics_DerivExist_AllElemActive</option>
<option>twoStageMethod</option>
<option>spk_non_par</option>
</select>
</td>
<td>
<select onchange='choose_down1(this)'>
<option>firstOrderOpt-&gt;</option>
<option>firstOrderOptTest.cpp</option>
</select>
</td>
<td>firstOrderOptTest.cpp</td>
<td>Headings</td>
</tr></table><br>


<center><b><big><big>firstOrderOpt: Example and Test</big></big></b></center>
<code><font color="blue"><span style='white-space: nowrap'>&nbsp;<br>
/*************************************************************************<br>
&nbsp;*&nbsp;Function:&nbsp;firstOrderOptAnalyticTest<br>
&nbsp;*<br>
&nbsp;*&nbsp;This&nbsp;is&nbsp;an&nbsp;example&nbsp;and&nbsp;test&nbsp;of&nbsp;firstOrderOpt.cpp&nbsp;&nbsp;written&nbsp;by&nbsp;Brad&nbsp;Bell<br>
&nbsp;*************************************************************************/<br>
<br>
//&nbsp;link&nbsp;so&nbsp;that&nbsp;Value&nbsp;works&nbsp;with&nbsp;double&nbsp;as&nbsp;well&nbsp;as&nbsp;AD&lt;double&gt;<br>
double&nbsp;Value(double&nbsp;x)<br>
{&nbsp;&nbsp;&nbsp;return&nbsp;x;&nbsp;}<br>
<br>
template&nbsp;&lt;class&nbsp;Scalar&gt;<br>
class&nbsp;fo_test_model&nbsp;:&nbsp;public&nbsp;SpkModel&lt;Scalar&gt;<br>
{<br>
private:<br>
&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sigma_;&nbsp;//&nbsp;standard&nbsp;deviation&nbsp;of&nbsp;measurement&nbsp;noise&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;valarray&lt;Scalar&gt;&nbsp;alpha_;&nbsp;//&nbsp;current&nbsp;fixed&nbsp;effects<br>
&nbsp;&nbsp;&nbsp;&nbsp;valarray&lt;Scalar&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b_;&nbsp;//&nbsp;current&nbsp;random&nbsp;effects<br>
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i_;&nbsp;//&nbsp;current&nbsp;individual&nbsp;(does&nbsp;not&nbsp;matter)<br>
public:<br>
&nbsp;&nbsp;&nbsp;&nbsp;fo_test_model(double&nbsp;sigma)&nbsp;:&nbsp;sigma_(sigma),&nbsp;&nbsp;alpha_(2)&nbsp;,&nbsp;b_(1)&nbsp;&nbsp;{};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;use&nbsp;default&nbsp;destruction:&nbsp;~fo_test_model()&nbsp;{};<br>
private:<br>
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;doSelectIndividual(int&nbsp;i)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;i_&nbsp;=&nbsp;i;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;doSetPopPar(const&nbsp;valarray&lt;Scalar&gt;&amp;&nbsp;alpha)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;alpha_&nbsp;=&nbsp;alpha;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;doSetIndPar(const&nbsp;valarray&lt;Scalar&gt;&amp;&nbsp;b)<br>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;b_&nbsp;=&nbsp;b;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;doIndParVariance(&nbsp;valarray&lt;Scalar&gt;&amp;&nbsp;D)&nbsp;const<br>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;D.resize(1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D[0]&nbsp;=&nbsp;alpha_[1];<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;doIndParVariance_popPar(&nbsp;valarray&lt;double&gt;&amp;&nbsp;D_alp&nbsp;)&nbsp;const<br>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;D_alp.resize(2);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D_alp[0]&nbsp;=&nbsp;0.;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D_alp[1]&nbsp;=&nbsp;1.;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;doIndParVarianceInv(&nbsp;valarray&lt;double&gt;&amp;&nbsp;Dinv)&nbsp;const<br>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;Dinv.resize(1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dinv[0]&nbsp;=&nbsp;1.&nbsp;/&nbsp;Value(alpha_[1]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;doIndParVarianceInv_popPar(&nbsp;valarray&lt;double&gt;&amp;&nbsp;Dinv_alp&nbsp;)&nbsp;const<br>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;Dinv_alp.resize(2);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dinv_alp[0]&nbsp;=&nbsp;0.;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dinv_alp[1]&nbsp;=&nbsp;-&nbsp;1.&nbsp;/&nbsp;Value(alpha_[1]&nbsp;*&nbsp;alpha_[1]);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;doDataMean(&nbsp;valarray&lt;Scalar&gt;&amp;&nbsp;f&nbsp;)&nbsp;const<br>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;f.resize(1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f[0]&nbsp;=&nbsp;alpha_[0]&nbsp;+&nbsp;b_[0];<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;doDataMean_popPar(&nbsp;valarray&lt;double&gt;&amp;&nbsp;f_alp&nbsp;)&nbsp;const<br>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;f_alp.resize(2);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f_alp[0]&nbsp;=&nbsp;1.;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f_alp[1]&nbsp;=&nbsp;0.;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;doDataMean_indPar(&nbsp;valarray&lt;double&gt;&amp;&nbsp;f_b&nbsp;)&nbsp;const<br>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;f_b.resize(1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f_b[0]&nbsp;=&nbsp;1.;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;doDataVariance(&nbsp;valarray&lt;Scalar&gt;&amp;&nbsp;R&nbsp;)&nbsp;const<br>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;R.resize(1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R[0]&nbsp;=&nbsp;Scalar(sigma_&nbsp;*&nbsp;sigma_);<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;doDataVariance_popPar(&nbsp;valarray&lt;double&gt;&amp;&nbsp;R_alp&nbsp;)&nbsp;const<br>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;R_alp.resize(2);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R_alp[0]&nbsp;=&nbsp;0.;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R_alp[1]&nbsp;=&nbsp;0.;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;doDataVariance_indPar(&nbsp;valarray&lt;double&gt;&amp;&nbsp;R_b&nbsp;)&nbsp;const<br>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;R_b.resize(1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R_b[0]&nbsp;=&nbsp;0.;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;doDataVarianceInv(&nbsp;valarray&lt;Scalar&gt;&amp;&nbsp;Rinv&nbsp;)&nbsp;const<br>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;Rinv.resize(1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rinv[0]&nbsp;=&nbsp;Scalar(1.0&nbsp;/&nbsp;(sigma_&nbsp;*&nbsp;sigma_));<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;doDataVarianceInv_popPar(&nbsp;valarray&lt;double&gt;&amp;&nbsp;Rinv_alp&nbsp;)&nbsp;const<br>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;Rinv_alp.resize(2);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rinv_alp[0]&nbsp;=&nbsp;0.;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rinv_alp[1]&nbsp;=&nbsp;0.;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;doDataVarianceInv_indPar(&nbsp;valarray&lt;double&gt;&amp;&nbsp;Rinv_b&nbsp;)&nbsp;const<br>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;Rinv_b.resize(1);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rinv_b[0]&nbsp;=&nbsp;0.;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
};<br>
<br>
void&nbsp;firstOrderOptTest::firstOrderOptAnalyticTest()<br>
{&nbsp;//&nbsp;temporary&nbsp;indices<br>
&nbsp;&nbsp;size_t&nbsp;i;<br>
<br>
&nbsp;&nbsp;//&nbsp;number&nbsp;of&nbsp;inidividuals&nbsp;in&nbsp;the&nbsp;simulation&nbsp;&nbsp;(can&nbsp;be&nbsp;changed)<br>
&nbsp;&nbsp;const&nbsp;size_t&nbsp;M&nbsp;=&nbsp;10;<br>
<br>
&nbsp;&nbsp;//&nbsp;simulation&nbsp;value&nbsp;for&nbsp;standard&nbsp;deviation&nbsp;of&nbsp;the&nbsp;random&nbsp;effects<br>
&nbsp;&nbsp;const&nbsp;double&nbsp;std_b&nbsp;=&nbsp;&nbsp;.5;<br>
<br>
&nbsp;&nbsp;//&nbsp;simulation&nbsp;value&nbsp;for&nbsp;standard&nbsp;deviation&nbsp;of&nbsp;measurement&nbsp;noise<br>
&nbsp;&nbsp;const&nbsp;double&nbsp;sigma&nbsp;=&nbsp;1.;<br>
<br>
&nbsp;&nbsp;//&nbsp;simulation&nbsp;value&nbsp;for&nbsp;mean&nbsp;of&nbsp;data<br>
&nbsp;&nbsp;const&nbsp;double&nbsp;mean_y&nbsp;=&nbsp;3.;<br>
<br>
&nbsp;&nbsp;//&nbsp;simulation&nbsp;fixed&nbsp;effects&nbsp;values&nbsp;<br>
&nbsp;&nbsp;valarray&lt;double&gt;&nbsp;alpha_true(2);<br>
&nbsp;&nbsp;alpha_true[0]&nbsp;=&nbsp;mean_y;<br>
&nbsp;&nbsp;alpha_true[1]&nbsp;=&nbsp;std_b&nbsp;*&nbsp;std_b;<br>
<br>
&nbsp;&nbsp;//&nbsp;simulation&nbsp;random&nbsp;effects&nbsp;values<br>
&nbsp;&nbsp;valarray&lt;double&gt;&nbsp;b_all_true(M);<br>
&nbsp;&nbsp;b_all_true&nbsp;=&nbsp;std_b&nbsp;*&nbsp;randNormal(M);<br>
<br>
&nbsp;&nbsp;//&nbsp;simulation&nbsp;measurement&nbsp;noise&nbsp;values<br>
&nbsp;&nbsp;valarray&lt;double&gt;&nbsp;noise(M);<br>
&nbsp;&nbsp;noise&nbsp;=&nbsp;randNormal(M);&nbsp;<br>
&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;//&nbsp;model,&nbsp;adModel<br>
&nbsp;&nbsp;fo_test_model&lt;double&gt;&nbsp;model(&nbsp;sigma&nbsp;);<br>
&nbsp;&nbsp;fo_test_model&lt;&nbsp;CppAD::AD&lt;double&gt;&nbsp;&gt;&nbsp;adModel(&nbsp;sigma&nbsp;);&nbsp;<br>
<br>
&nbsp;&nbsp;//&nbsp;dvecN,&nbsp;dvecY<br>
&nbsp;&nbsp;DoubleMatrix&nbsp;dvecN(M,&nbsp;1);<br>
&nbsp;&nbsp;double&nbsp;*N&nbsp;=&nbsp;dvecN.data();<br>
&nbsp;&nbsp;DoubleMatrix&nbsp;dvecY(M,&nbsp;1);<br>
&nbsp;&nbsp;double&nbsp;*Y&nbsp;=&nbsp;dvecY.data();<br>
&nbsp;&nbsp;for(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;M;&nbsp;i++)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;//&nbsp;number&nbsp;of&nbsp;measurements&nbsp;for&nbsp;this&nbsp;subject<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N[i]&nbsp;=&nbsp;1.;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;value&nbsp;of&nbsp;measurement&nbsp;for&nbsp;this&nbsp;subject&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Y[i]&nbsp;=&nbsp;alpha_true[0]&nbsp;+&nbsp;b_all_true[i]&nbsp;+&nbsp;noise[i];<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;//&nbsp;fixed&nbsp;effects&nbsp;optimizer&nbsp;(linear&nbsp;least&nbsp;squares&nbsp;problem)<br>
&nbsp;&nbsp;double&nbsp;epsilon&nbsp;=&nbsp;1e-5;<br>
&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;max_itr&nbsp;=&nbsp;20;<br>
&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;level&nbsp;&nbsp;&nbsp;=&nbsp;0;<br>
&nbsp;&nbsp;Optimizer&nbsp;alpOptInfo(epsilon,&nbsp;max_itr,&nbsp;level);&nbsp;<br>
&nbsp;&nbsp;//&nbsp;Set&nbsp;these&nbsp;to&nbsp;exercise&nbsp;the&nbsp;warm&nbsp;start&nbsp;capabilities&nbsp;of&nbsp;firstOrderOpt.<br>
&nbsp;&nbsp;alpOptInfo.setThrowExcepIfMaxIter(&nbsp;false&nbsp;);<br>
&nbsp;&nbsp;alpOptInfo.setSaveStateAtEndOfOpt(&nbsp;true&nbsp;);<br>
<br>
&nbsp;&nbsp;//&nbsp;fixed&nbsp;effects&nbsp;arguements&nbsp;to&nbsp;firstOrderOpt<br>
&nbsp;&nbsp;size_t&nbsp;m&nbsp;=&nbsp;2;&nbsp;//&nbsp;number&nbsp;of&nbsp;fixed&nbsp;effects<br>
&nbsp;&nbsp;DoubleMatrix&nbsp;dvecAlpLow&nbsp;(&nbsp;m,&nbsp;1&nbsp;);<br>
&nbsp;&nbsp;DoubleMatrix&nbsp;dvecAlpUp&nbsp;&nbsp;(&nbsp;m,&nbsp;1&nbsp;);<br>
&nbsp;&nbsp;DoubleMatrix&nbsp;dvecAlpIn&nbsp;&nbsp;(&nbsp;m,&nbsp;1&nbsp;);<br>
&nbsp;&nbsp;DoubleMatrix&nbsp;dvecAlpOut&nbsp;(&nbsp;m,&nbsp;1&nbsp;);<br>
&nbsp;&nbsp;DoubleMatrix&nbsp;dvecAlpStep(&nbsp;m,&nbsp;1&nbsp;);<br>
<br>
&nbsp;&nbsp;double*&nbsp;alpLow&nbsp;&nbsp;=&nbsp;dvecAlpLow&nbsp;.data();<br>
&nbsp;&nbsp;double*&nbsp;alpUp&nbsp;&nbsp;&nbsp;=&nbsp;dvecAlpUp&nbsp;&nbsp;.data();<br>
&nbsp;&nbsp;double*&nbsp;alpIn&nbsp;&nbsp;&nbsp;=&nbsp;dvecAlpIn&nbsp;&nbsp;.data();<br>
&nbsp;&nbsp;double*&nbsp;alpStep&nbsp;=&nbsp;dvecAlpStep.data();<br>
<br>
&nbsp;&nbsp;//&nbsp;Set&nbsp;the&nbsp;values&nbsp;associated&nbsp;with&nbsp;first&nbsp;fixed&nbsp;effect<br>
&nbsp;&nbsp;alpLow&nbsp;[&nbsp;0&nbsp;]&nbsp;=&nbsp;alpha_true[0]&nbsp;-&nbsp;10.0;<br>
&nbsp;&nbsp;alpUp&nbsp;&nbsp;[&nbsp;0&nbsp;]&nbsp;=&nbsp;alpha_true[0]&nbsp;+&nbsp;10.0;<br>
&nbsp;&nbsp;alpIn&nbsp;&nbsp;[&nbsp;0&nbsp;]&nbsp;=&nbsp;alpha_true[0]&nbsp;-&nbsp;2.;<br>
&nbsp;&nbsp;alpStep[&nbsp;0&nbsp;]&nbsp;=&nbsp;1.0e-2;<br>
<br>
&nbsp;&nbsp;//&nbsp;Set&nbsp;the&nbsp;values&nbsp;associated&nbsp;with&nbsp;second&nbsp;firxed&nbsp;effect<br>
&nbsp;&nbsp;alpLow&nbsp;[&nbsp;1&nbsp;]&nbsp;=&nbsp;alpha_true[1]&nbsp;/&nbsp;10.;<br>
&nbsp;&nbsp;alpUp&nbsp;&nbsp;[&nbsp;1&nbsp;]&nbsp;=&nbsp;alpha_true[1]&nbsp;*&nbsp;10.;<br>
&nbsp;&nbsp;alpIn&nbsp;&nbsp;[&nbsp;1&nbsp;]&nbsp;=&nbsp;alpha_true[1]&nbsp;/&nbsp;2.;<br>
&nbsp;&nbsp;alpStep[&nbsp;1&nbsp;]&nbsp;=&nbsp;alpha_true[1]&nbsp;/&nbsp;100.;<br>
<br>
&nbsp;&nbsp;//&nbsp;random&nbsp;effects&nbsp;optimizer&nbsp;(not&nbsp;a&nbsp;linear&nbsp;least&nbsp;squares&nbsp;problem)<br>
&nbsp;&nbsp;epsilon&nbsp;=&nbsp;1e-6;<br>
&nbsp;&nbsp;max_itr&nbsp;=&nbsp;50;<br>
&nbsp;&nbsp;level&nbsp;&nbsp;&nbsp;=&nbsp;0;<br>
&nbsp;&nbsp;Optimizer&nbsp;bOptInfo(epsilon,&nbsp;max_itr,&nbsp;level);&nbsp;<br>
&nbsp;&nbsp;bOptInfo.setThrowExcepIfMaxIter(&nbsp;true&nbsp;);<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;//&nbsp;random&nbsp;effects&nbsp;arguments&nbsp;to&nbsp;firstOrderOpt<br>
&nbsp;&nbsp;size_t&nbsp;n&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;//&nbsp;number&nbsp;of&nbsp;random&nbsp;effects&nbsp;per&nbsp;individual<br>
&nbsp;&nbsp;DoubleMatrix&nbsp;dvecBLow&nbsp;(&nbsp;n,&nbsp;1&nbsp;);<br>
&nbsp;&nbsp;DoubleMatrix&nbsp;dvecBUp&nbsp;&nbsp;(&nbsp;n,&nbsp;1&nbsp;);<br>
&nbsp;&nbsp;DoubleMatrix&nbsp;dvecBStep(&nbsp;n,&nbsp;1&nbsp;);<br>
&nbsp;&nbsp;DoubleMatrix&nbsp;dmatBIn&nbsp;&nbsp;(&nbsp;n,&nbsp;M&nbsp;);<br>
&nbsp;&nbsp;DoubleMatrix&nbsp;dmatBOut&nbsp;(&nbsp;n,&nbsp;M&nbsp;);<br>
<br>
&nbsp;&nbsp;double&nbsp;*bLow&nbsp;&nbsp;=&nbsp;dvecBLow.data();<br>
&nbsp;&nbsp;double&nbsp;*bUp&nbsp;&nbsp;&nbsp;=&nbsp;dvecBUp&nbsp;.data();<br>
&nbsp;&nbsp;double&nbsp;*bStep&nbsp;=&nbsp;dvecBStep.data();<br>
&nbsp;&nbsp;double&nbsp;*bIn&nbsp;&nbsp;&nbsp;=&nbsp;dmatBIn.data();<br>
<br>
&nbsp;&nbsp;bLow[0]&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;-&nbsp;3.&nbsp;*&nbsp;std_b;<br>
&nbsp;&nbsp;bUp[0]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;+&nbsp;3.&nbsp;*&nbsp;std_b;<br>
&nbsp;&nbsp;bStep[0]&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;1e-2&nbsp;*&nbsp;std_b;&nbsp;<br>
&nbsp;&nbsp;dmatBIn.fill(&nbsp;0.0&nbsp;);<br>
<br>
&nbsp;&nbsp;//&nbsp;objective&nbsp;function&nbsp;values<br>
&nbsp;&nbsp;double&nbsp;dLtildeOut;<br>
&nbsp;&nbsp;DoubleMatrix&nbsp;drowLtilde_alpOut&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;1,&nbsp;m&nbsp;);<br>
&nbsp;&nbsp;DoubleMatrix&nbsp;dmatLtilde_alp_alpOut&nbsp;(&nbsp;m,&nbsp;m&nbsp;);<br>
&nbsp;&nbsp;DoubleMatrix&nbsp;dmatLtilde_alpOut&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;m,&nbsp;M&nbsp;);<br>
<br>
&nbsp;&nbsp;try<br>
&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;firstOrderOpt(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;model&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adModel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dvecN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dvecY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alpOptInfo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dvecAlpLow&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dvecAlpUp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dvecAlpIn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;dvecAlpOut&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dvecAlpStep&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bOptInfo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dvecBLow&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dvecBUp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmatBIn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;dmatBOut&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dvecBStep&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;dLtildeOut&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;drowLtilde_alpOut&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;dmatLtilde_alp_alpOut&nbsp;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;dmatLtilde_alpOut&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;catch(...)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;CPPUNIT_ASSERT_MESSAGE(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;firstOrderOptAnalyticTest:&nbsp;an&nbsp;exception&nbsp;occurred.&quot;,&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;false<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;//************************************************************<br>
&nbsp;&nbsp;//&nbsp;Note:&nbsp;equations&nbsp;for&nbsp;the&nbsp;known&nbsp;(analytic)&nbsp;values&nbsp;computed&nbsp;<br>
&nbsp;&nbsp;//&nbsp;here&nbsp;are&nbsp;derived&nbsp;in&nbsp;&quot;An&nbsp;Introduction&nbsp;to&nbsp;Mixed&nbsp;Effects<br>
&nbsp;&nbsp;//&nbsp;Modeling&nbsp;and&nbsp;Marginal&nbsp;Likelihood&nbsp;Estimation&nbsp;with&nbsp;a&nbsp;<br>
&nbsp;&nbsp;//&nbsp;Pharmacokinetic&nbsp;Example&quot;,&nbsp;B.&nbsp;M.&nbsp;Bell,&nbsp;Applied&nbsp;Physics<br>
&nbsp;&nbsp;//&nbsp;Laboratory,&nbsp;University&nbsp;of&nbsp;Washington,&nbsp;May&nbsp;25,&nbsp;2000.<br>
&nbsp;&nbsp;//************************************************************<br>
<br>
&nbsp;&nbsp;//&nbsp;Compute&nbsp;the&nbsp;mean&nbsp;of&nbsp;the&nbsp;data,&nbsp;yBar.<br>
&nbsp;&nbsp;double&nbsp;yBar&nbsp;=&nbsp;0.0;<br>
&nbsp;&nbsp;for(&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;M;&nbsp;i++&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;yBar&nbsp;+=&nbsp;Y[&nbsp;i&nbsp;];<br>
&nbsp;&nbsp;yBar&nbsp;/=&nbsp;double(M);<br>
<br>
&nbsp;&nbsp;//&nbsp;Compute&nbsp;the&nbsp;sample&nbsp;variance<br>
&nbsp;&nbsp;double&nbsp;sample_variance&nbsp;=&nbsp;0.0;<br>
&nbsp;&nbsp;for&nbsp;(&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;M;&nbsp;i++&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;sample_variance&nbsp;+=&nbsp;(Y[i]&nbsp;-&nbsp;yBar)&nbsp;*&nbsp;(Y[i]&nbsp;-&nbsp;yBar);<br>
&nbsp;&nbsp;sample_variance&nbsp;/=&nbsp;double(M);<br>
<br>
&nbsp;&nbsp;//&nbsp;check&nbsp;fixed&nbsp;effects&nbsp;estimates,&nbsp;The&nbsp;value&nbsp;for&nbsp;alpHat(0)&nbsp;and&nbsp;alpHat(1)&nbsp;<br>
&nbsp;&nbsp;//&nbsp;are&nbsp;contained&nbsp;in&nbsp;section&nbsp;9&nbsp;of&nbsp;the&nbsp;above&nbsp;reference.<br>
&nbsp;&nbsp;bool&nbsp;ok_alpha&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;true;<br>
&nbsp;&nbsp;double&nbsp;check&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;yBar;<br>
&nbsp;&nbsp;double&nbsp;alphaHat_0&nbsp;=&nbsp;*(dvecAlpOut.data()+0);<br>
&nbsp;&nbsp;ok_alpha&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;=&nbsp;fabs(alphaHat_0&nbsp;/&nbsp;check&nbsp;-&nbsp;1.)&nbsp;&lt;&nbsp;1e-4;<br>
&nbsp;&nbsp;check&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;sample_variance&nbsp;-&nbsp;sigma&nbsp;*&nbsp;sigma;<br>
&nbsp;&nbsp;if(&nbsp;check&nbsp;&lt;&nbsp;alpLow[1]&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;check&nbsp;=&nbsp;alpLow[1];<br>
&nbsp;&nbsp;if(&nbsp;check&nbsp;&gt;&nbsp;alpUp[1]&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;check&nbsp;=&nbsp;alpUp[1];<br>
&nbsp;&nbsp;double&nbsp;alphaHat_1&nbsp;=&nbsp;*(dvecAlpOut.data()+1);<br>
&nbsp;&nbsp;ok_alpha&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;=&nbsp;fabs(alphaHat_1&nbsp;/&nbsp;check&nbsp;-&nbsp;1.)&nbsp;&lt;&nbsp;1e-4;<br>
&nbsp;&nbsp;CPPUNIT_ASSERT_MESSAGE(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;firstOrderOptAnalyticTest:&nbsp;alphaOut&nbsp;is&nbsp;not&nbsp;correct.&quot;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ok_alpha<br>
&nbsp;&nbsp;);<br>
<br>
&nbsp;&nbsp;/*&nbsp;check&nbsp;random&nbsp;effects&nbsp;estimates<br>
&nbsp;&nbsp;mapObj&nbsp;=&nbsp;.5*b_i^2&nbsp;/&nbsp;alp_1&nbsp;+&nbsp;.5*[&nbsp;(&nbsp;y_i&nbsp;-&nbsp;alp_0&nbsp;-&nbsp;b_i)&nbsp;/&nbsp;sigma&nbsp;]^2<br>
&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;b_i&nbsp;/&nbsp;alp_1&nbsp;-&nbsp;(y_i&nbsp;-&nbsp;alp_0&nbsp;-&nbsp;b_i)&nbsp;/&nbsp;sigma^2<br>
&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;b_i&nbsp;(1&nbsp;/&nbsp;alp_1&nbsp;+&nbsp;1&nbsp;/&nbsp;sigma^2&nbsp;)&nbsp;-&nbsp;(y_i&nbsp;-&nbsp;alp_0&nbsp;)&nbsp;/&nbsp;sigma^2<br>
&nbsp;&nbsp;b_i&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;&nbsp;(y_i&nbsp;-&nbsp;alp_0&nbsp;)&nbsp;/&nbsp;(&nbsp;sigma^2&nbsp;/&nbsp;alp_1&nbsp;+&nbsp;1)<br>
&nbsp;&nbsp;*/<br>
&nbsp;&nbsp;bool&nbsp;ok_b&nbsp;=&nbsp;true;<br>
&nbsp;&nbsp;for&nbsp;(&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;M&nbsp;;&nbsp;i++&nbsp;)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;check&nbsp;=&nbsp;(Y[i]&nbsp;-&nbsp;alphaHat_0)&nbsp;/&nbsp;(sigma&nbsp;*&nbsp;sigma&nbsp;/&nbsp;alphaHat_1&nbsp;+&nbsp;1.);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;check&nbsp;&lt;&nbsp;bLow[0]&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;check&nbsp;=&nbsp;bLow[0];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;check&nbsp;&gt;&nbsp;bUp[0]&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;check&nbsp;=&nbsp;bUp[0];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ok_b&nbsp;&amp;=&nbsp;fabs(*(dmatBOut.data()&nbsp;+&nbsp;i)&nbsp;/&nbsp;check&nbsp;-&nbsp;1.)&nbsp;&lt;&nbsp;1e-4;<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;CPPUNIT_ASSERT_MESSAGE(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;firstOrderOptAnalyticTest:&nbsp;BOut&nbsp;is&nbsp;not&nbsp;correct.&quot;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ok_b<br>
&nbsp;&nbsp;);&nbsp;<br>
&nbsp;&nbsp;/*&nbsp;check&nbsp;fixed&nbsp;effects&nbsp;objective&nbsp;value<br>
&nbsp;&nbsp;Vi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;Ri&nbsp;+&nbsp;fi_b&nbsp;*&nbsp;D&nbsp;*&nbsp;fi_b'&nbsp;=&nbsp;Ri&nbsp;+&nbsp;D<br>
&nbsp;&nbsp;Ltilde&nbsp;=&nbsp;.5&nbsp;*&nbsp;sum_i&nbsp;logdet(2*pi*Vi)&nbsp;+&nbsp;(yi-alp_0)'&nbsp;Vi^{-1}&nbsp;(yi-alp_0)<br>
&nbsp;&nbsp;*/<br>
&nbsp;&nbsp;double&nbsp;pi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;4.&nbsp;*&nbsp;atan(1.);<br>
&nbsp;&nbsp;double&nbsp;Ltilde&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;0.;<br>
&nbsp;&nbsp;double&nbsp;Ltilde_alp_0&nbsp;&nbsp;&nbsp;=&nbsp;0.;<br>
&nbsp;&nbsp;double&nbsp;Ltilde_alp_1&nbsp;&nbsp;&nbsp;=&nbsp;0.;<br>
&nbsp;&nbsp;double&nbsp;Hessian_00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;0.;<br>
&nbsp;&nbsp;double&nbsp;Hessian_11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;0.;<br>
&nbsp;&nbsp;bool&nbsp;ok_L&nbsp;=&nbsp;true;<br>
&nbsp;&nbsp;for(&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;M;&nbsp;i++)<br>
&nbsp;&nbsp;{&nbsp;&nbsp;double&nbsp;Vi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;sigma&nbsp;*&nbsp;sigma&nbsp;+&nbsp;alphaHat_1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;Vi_alp_1&nbsp;=&nbsp;1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;ri&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;Y[i]&nbsp;-&nbsp;alphaHat_0;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;ri_alp_0&nbsp;=&nbsp;-1;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ltilde&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+=&nbsp;.5&nbsp;*&nbsp;(&nbsp;log(&nbsp;2&nbsp;*&nbsp;pi&nbsp;*&nbsp;Vi&nbsp;)&nbsp;+&nbsp;ri&nbsp;*&nbsp;ri&nbsp;/&nbsp;Vi&nbsp;);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;temp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;ri&nbsp;*&nbsp;ri_alp_0&nbsp;/&nbsp;Vi;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ok_L&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;=&nbsp;fabs(*(dmatLtilde_alpOut.data()+0+2*i)&nbsp;-&nbsp;temp)&nbsp;&lt;&nbsp;1e-4;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ltilde_alp_0&nbsp;&nbsp;&nbsp;+=&nbsp;temp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hessian_00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+=&nbsp;ri_alp_0&nbsp;*&nbsp;ri_alp_0&nbsp;/&nbsp;Vi;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;temp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;.5&nbsp;*&nbsp;Vi_alp_1&nbsp;/&nbsp;Vi&nbsp;-&nbsp;.5&nbsp;*&nbsp;ri&nbsp;*&nbsp;ri&nbsp;*&nbsp;Vi_alp_1&nbsp;/&nbsp;(Vi&nbsp;*&nbsp;Vi);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ok_L&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;=&nbsp;fabs(*(dmatLtilde_alpOut.data()+1+2*i)&nbsp;-&nbsp;temp)&nbsp;&lt;&nbsp;1e-4;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ltilde_alp_1&nbsp;&nbsp;&nbsp;+=&nbsp;temp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hessian_11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+=&nbsp;-.5&nbsp;*&nbsp;Vi_alp_1&nbsp;*&nbsp;Vi_alp_1&nbsp;/&nbsp;(Vi&nbsp;*&nbsp;Vi)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;ri&nbsp;*&nbsp;ri&nbsp;*&nbsp;Vi_alp_1&nbsp;*&nbsp;Vi_alp_1&nbsp;/&nbsp;(Vi&nbsp;*&nbsp;Vi&nbsp;*&nbsp;Vi);<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;ok_L&nbsp;&amp;=&nbsp;fabs(dLtildeOut&nbsp;/&nbsp;Ltilde&nbsp;-&nbsp;1)&nbsp;&lt;&nbsp;1e-4;<br>
&nbsp;&nbsp;ok_L&nbsp;&amp;=&nbsp;fabs(*(dmatLtilde_alp_alpOut.data()+0)&nbsp;/&nbsp;Hessian_00&nbsp;-&nbsp;1)&nbsp;&lt;&nbsp;1e-4;<br>
&nbsp;&nbsp;ok_L&nbsp;&amp;=&nbsp;fabs(*(dmatLtilde_alp_alpOut.data()+1)&nbsp;)&nbsp;&lt;&nbsp;1e-4;<br>
&nbsp;&nbsp;ok_L&nbsp;&amp;=&nbsp;fabs(*(dmatLtilde_alp_alpOut.data()+2)&nbsp;)&nbsp;&lt;&nbsp;1e-4;<br>
&nbsp;&nbsp;ok_L&nbsp;&amp;=&nbsp;fabs(*(dmatLtilde_alp_alpOut.data()+3)&nbsp;/&nbsp;Hessian_11&nbsp;-&nbsp;1)&nbsp;&lt;&nbsp;1e-4;<br>
&nbsp;&nbsp;//&nbsp;do&nbsp;use&nbsp;relative&nbsp;accuracy&nbsp;on&nbsp;derivatives&nbsp;because&nbsp;are&nbsp;zero<br>
&nbsp;&nbsp;//&nbsp;at&nbsp;the&nbsp;true&nbsp;minimizer.<br>
&nbsp;&nbsp;ok_L&nbsp;&amp;=&nbsp;fabs(*(drowLtilde_alpOut.data()+0)&nbsp;-&nbsp;Ltilde_alp_0&nbsp;)&nbsp;&lt;&nbsp;1e-8;<br>
&nbsp;&nbsp;ok_L&nbsp;&amp;=&nbsp;fabs(*(drowLtilde_alpOut.data()+1)&nbsp;-&nbsp;Ltilde_alp_1&nbsp;)&nbsp;&lt;&nbsp;1e-8;<br>
&nbsp;&nbsp;CPPUNIT_ASSERT_MESSAGE(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;firstOrderOptAnalyticTest:&nbsp;Ltilde&nbsp;or&nbsp;its&nbsp;derivative&nbsp;is&nbsp;not&nbsp;correct.&quot;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ok_L<br>
&nbsp;&nbsp;);&nbsp;<br>
&nbsp;&nbsp;return;<br>
}<br>
</span></font></code>
<hr>Input File: ../../test/UnitTests/src/firstOrderOptTest.cpp

</body>
</html>
