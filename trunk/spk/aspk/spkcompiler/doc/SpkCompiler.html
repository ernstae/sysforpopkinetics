<html>
<head>
<title>
SPK Compiler
</title>
</head>
<body>
<h1>
SPK Compiler
</h1>
<p>
SPK Compiler uses a DOM implementation of XML parser to create a parse tree out 
of a text document written in <a href="SpkML.html">SpkML</a>.
The compiler translates the document to C++ as it traverses the tree, verifying
syntax at the same time (syntax directed translation).  During the translation process,
the compiler maintains and/or looks up three different catalog/table.
The <a href="#model_lib">abstract model library catalog</a>
lists pre-defined sub-classes of SpkModel that represent well-known 
physiological models.  These sub-classes of SpkModel are abstract and each provides a set of
methods and properties bonded with a specific class of models.  
The <a href="#exp_lib">expression lookup table</a> maintains pre-determined mappings between client-expression elements 
and C++/Spk elements.
The symbol table records
newly appeared symbols and their attributes and is used to check the consistency at the end.
</p>
<p>
The end products of translation are
C++ source code for a <a href="#driver">Spk driver</a>, 
an <a href="#model">instance of SpkModel</a> class and <a href="#datum">IndData</a> class.
</p>

<img src="compilar.gif">
<hr>
<a name="model_lib">
<h1>
C++/Abstract Model Library
</h1>
</a>
<p>
The abstract model library composes of hierarchy of classes marked with SpkModel at the top.
This library initially most likely contains only the SpkModel class but may grow
as needs rise.
</p>
<p>
The classes of models that fit directly into SpkModel are
those which are specified in a way there's nothing but one-to-one relationships between
the user's defintions and the SpkModel virtual methods.
</p>
<p>
In the diagram below, sub-classes derived from SpkModel are <i><b>just</b></i> examples demonstrating
the idea.
</p>

<pre>
                             +---------------+
                             |   SpkModel    |
                             |               |
                             |  (abstract)   |
                             +---------------+                         
                               /|\       /|\
                                |         |
                                |         |
       +---------------------------+   +------------------------+
       |   Differential equation   |   |    Non-differential    |
       | based Physiological Model |   |  equation based model  |
       |         (abstract)        |   |       (abstract)       |
       +---------------------------+   +------------------------+
              /|\        /|\                 /|\        /|\
               |          |                   |          |
               |          |                   |          |
       +---------------+  |            +---------------+ |
       | Compartmental |  |            | Compartmental | |
       |  (abstract)   |-------+       |  (abstract)   |-------+
       +---+-----------+       |       +---+-----------+       |
           | non-Compartmental |           | non-Compartmental |
           |    (abstract)     |           |    (abstract)     |
           +-------------------+ ...       +-------------------+ ...
</pre>

<a name="exp_lib">
<h1>
C++/Spk Expression Compiler(s)
</h1>
</a>
<p>
The expressions the user write in their languages must be translated into C++
expressions using the standard library components or/and Spk provided
functions (See <a href="SpkExpLanguage.html">SpkExpLanguage.html</a> for complete specification).
Multiple versions of this type of compiler may be provided, each corresponding to
a particular source (expression) language.

</p>

<h1>
Generated C++ Code
</h1>
<a name="datum">
<h2>
IndData Class
</h2>
</a>
<p>
The data set associated with an individual is expressed as an object.  The base class, IndData, is 
not predefined in the SPK library, rather defined on fly to accomodate various (unknown) types of 
data sets.  In one domain, a data set may mean only sampling times and corresponding measurements 
from a sample compartment.  In another domain, a data set may additionally have dosage information
at various time points and individuals' weights.  In addition, the labels used to refer to
these data subsets are not necessarily the same even when they are refering to the same kind 
of subset in nature.
</p>
<p>
The below is an example of dynamically generated IndData class definition, 
from a data set containing "sampling points", "measurements at these sampling points",
"extra doses at various time points" and the weight of the sample compartment at
steady state.  The identifier and the order in which the individual is considered
within the population are fixed (appear in any instance of IndData).
</p>
<code><pre>
class IndData
{
   string _ID;
   int    _order;
   double _weight;
   valarray&lt;double&gt; _time;
   valarray&lt;double&gt; _quantitity;
public:
   IndData(  const string& IDIn, int orderIn, 
                const valarray&lt;double&gt;& timeIn, const valarray&lt;double&gt;& quantityIn,
		double weightIn )
   : _ID(IDIn), _order(orderIn), _time(timeIn), _quantity(quantityIn), _weight(weightIn) {}
   double weight() const { return _weight; }
   const valarray&lt;double&gt; & time() const { return _time; }
   const valarray&lt;double&gt; & quantity() const { return _quantity; }
}
</pre></code>

<a name="driver">
<h2>
A Driver
</h2>
</a>
<p>
It is the driver that prepares the parameters needed to call
<code>fitPopulation()</code> or <code>fitIndividual</code>.
Such parameters include the intial estimates for the population parameter 
vector and individual paramters vector, 
a vector composed of all individuals' time-dependent
measurements against which the estimated values are compared, and values
that control optimizer's behavior.  One way to provide such a driver is
to have a pre-defined generic driver that takes these parameters as 
command line arguments.  The problem of this approach arises from 
the fact that the number of arguments changes from a problem to another and
could be very, very large (hundreds).  The approach suggested here is
to generate a driver on-fly.
</p>
<p>
The following example demonstrates how a driver is composed from a definition 
of a problem in which are 3 individuals, each individual comes with a data
set used in the above "Invididual class" section.  "..." indicates some value.
</p>

<code><pre>
#include "fitPopulation.h"
#include "UserPopModel.h"   // This header file is generated on-fly too.

int main( int argc, const char ** ofile )
{
   const int N  = 3;
   const int nAlp = 6;
   const int nB   = 3;

   IndData *data[N];
   valarray&lt;int&gt; nY( { 10, 8, 5 } );
   valarray&lt;double&gt; y( { ..., ..., ..., ..., ..., ..., ..., ..., ..., ...,
                               ..., ..., ..., ..., ..., ..., ..., ..., 
                               ..., ..., ..., ..., ... } );

   string ID      = "John";
   int i          = 0;
   valarray<double> ti( { ..., ..., ..., ..., ..., ..., ..., ..., ..., ... } );
   valarray<double> yi = y[ slice( 0, nY[0], 1 ) ];
   double weight  = ...;
   IndData John( ID, i, ti, yi, weight );   data[0] = & John;

   ID = Mike;
   i         = 1;
   ti        ( { ..., ..., ..., ..., ..., ..., ..., ... } );
   yi        = y[ slice( nY[0], nY[1], 1 ) ];
   weight    = ...;
   IndData Mike( ID, i, ti, yi, weight );   data[1] = & Mike;

   ID     = "Steve";
   i      = 2;
   ti     ( { ..., ..., ..., ..., ... } );
   yi     = y[ slice( nY[0]+nY[1], nY[2], 1 ) ];
   weight = ...;
   IndData Steve( ID, i, ti, yi, weight );  data[2] = & Steve;

   UserPopModel model( data );

   valarray&lt;double&gt; popParIn  ( {..., ..., ..., ..., ..., ...}, nAlp );
   valarray&lt;double&gt; popParLow ( {..., ..., ..., ..., ..., ...}, nAlp );
   valarray&lt;double&gt; popParUp  ( {..., ..., ..., ..., ..., ...}, nAlp );
   valarray&lt;double&gt; popParStep( {..., ..., ..., ..., ..., ...}, nAlp );
   valarray&lt;double&gt; popParOut ( nAlp );

   valarray&lt;double&gt; indParIn  ( {..., ..., ...,
                                       ..., ..., ..., 
                                       ..., ..., ...}, nB*N );
   valarray&lt;double&gt; indParLow ( {..., ..., ...}, nB );
   valarray&lt;double&gt; indParUp  ( {..., ..., ...}, nB );
   valarray&lt;double&gt; indParStep( {..., ..., ...}, nB );
   valarray&lt;double&gt; indParOut ( nB*N );

   const double pop_epsilon = ...;
   const double ind_epsilon = ...;
   const int    pop_mitr    = ...;
   const int    ind_mitr    = ...;
   const int    pop_trace   = ...;
   const int    ind_trace   = ...;

   Optimizer popOpt( pop_epsilon, pop_mitr, pop_trace );
   Optimizer indOpt( ind_epsilon, ind_mitr, ind_trace );  

   enum Objective     objective     = ...;
   enum PopParCovForm popParCovForm = ...;

   fitPopulation( model, objective, nY, y, 
                  popOpt, popParLow, popParUp, popParIn, popParStep, &popParOut,
                  indOpt, indParLow, indParUp, indParIn, indParStep, &indParOut,
                  &popObjOut, &popObj_popParOut, &popObj_popPar_popParOut );

   popStatistics( model, objective, nY, y,
                  popParOut, popObj_popPar_popPar,
                  indParOut, indParLow, indParUp, indParStep,
                  popParCovForm,
                  &popParCovOut, &popParSEOut, &popParCorOut );

   SpkOutML results( popObjOut, popObj_popParOut, popObj_popPar_popParOut,
                     popParCovOut, popParSEOut, popParCorOut, popParConfOut, popParCoefOut,
                     indParCovOut, indParSEOut, indParCorOut, indParConfOut, indParCoefOut,
                   );
   ofstream o( ofile );
   o << results;
   o.close();

   return 0;
}
</pre></code>

<a name="model">
<h2>
A Direct Instance of SpkModel Class
</h2>
The following (psuedo) code is an example of a direct instantiation of SpkModel class
where the population composes of different groups of subjects who have different
physiological models.  
</a>
<code><pre>
class UserPopModel : public SpkModel
{
public:
   UserPopModel( IndData ** dataIn ) : _pData( &dataIn ), _who(0)
   {
   }
private:
   valarray&lt;double&gt; _alp;
   valarray&lt;double&gt; _b;
   int              _who;
   IndData    ** _pData;

   virtual void doSetPopPar( const valarray&lt;double&gt;& alpIn )
   {
      _alp = alpIn;
   }
   virtual void doSetIndPar( const valarray&lt;double&gt;& bIn )
   {
      _b = bIn;
   }
   virtual void doSelectIndividual ( int who )
   {
      _who = who;
   }
   virtual void doDataMean( valarray&lt;double&gt; & fiOut ) const
   {
      switch( _who )
      {
         case 1, 4, 5: f_001( fiOut );
                       break;
         case 0, 2:    f_002( fiOut );
                       break;
         default:      f_000( fiOut );
                       break;
      }
   }
   virtual bool doDataMean_indPar( valarray&lt;double&gt; & fi_bOut ) const
   {
      switch( _who )
      {
         case 1, 4, 5: return f_b_001( fi_bOut );
                       break;
         case 0, 2:    return f_b_002( fi_bOut );
                       break;
         default:      return f_b_000( fi_bOut );
                       break;
      }
   }
   virtual bool doDataMean_popPar( valarray&lt;double&gt; & fi_alpOut ) const
   {
      switch( _who )
      {
         case 1, 4, 5: return f_alp_001( fi_alpOut );
                       break;
         case 0, 2:    return f_alp_002( fi_alpOut );
                       break;
         default:      return f_alp_000( fi_alpOut );
                       break;
      }
   }
   virtual void doDataVariance( valarray&lt;double&gt; & RiOut ) const
   {
      switch( _who )
      {
         case 1, 4, 5: R_001( RiOut );
                       break;
         case 0, 2:    R_002( RiOut );
                       break;
         default:      R_000( RiOut );
                       break;
      }
   }
   virtual bool doDataVariance_indPar( valarray&lt;double&gt; & Ri_bOut ) const
   {
      switch( _who )
      {
         case 1, 4, 5: return R_b_001( Ri_bOut );
                       break;
         case 0, 2:    return R_b_002( Ri_bOut );
                       break;
         default:      return R_b_000( Ri_bOut );
                       break;
      }				  
   }
   virtual bool doDataVariance_popPar( valarray&lt;double&gt; & Ri_alpOut ) const
   {
      switch( _who )
      {
         case 1, 4, 5: return R_alp_001( Ri_alpOut );
                       break;
         case 0, 2:    return R_alp_002( Ri_alpOut );
                       break;
         default:      return R_alp_000( Ri_alpOut );
                       break;
      }				  
   }
   virtual void doIndParVariance( valarray&lt;double&gt; & DOut ) const
   {
      // Definition of D(alp)      
   }
   virtual bool doDataVariance_indPar( valarray&lt;double&gt; & Ri_bOut ) const
   {
      // Definition of D_alp(alp)
   }

   void f_000( valarray&lt;double&gt;& f_000Out )
   {
      f_000Out = (_b[0] + _alp[0])/exp( _pData[_who]->time * (_b[1] + _alp[1]))
               + (_b[2] + _alp[2])/exp( _pData[_who]->time * (_b[3] + _alp[3]));
   }
   void f_001( valarray&lt;double&gt;& f_001Out )
   {
      // Definition			  
      ...
   }
   void f_002( valarray&lt;double&gt;& f_002Out )
   {
      // Definition			  
      ...
   }
   bool f_b_000( valarray&lt;double&gt;& f_b_000Out )
   {
      f_b_000Out[slice(nData*0, nData, 1)] = exp(-( _pData[_who]->time[1] + _alp[1])));                       
      f_b_000Out[slice(nData*1, nData, 1)] = -(( _pData[_who]->time*(_b[0] + _alp[0]))
                                             /exp( _pData[_who]->time*(_b[1] + _alp[1])));
      f_b_000Out[slice(nData*2, nData, 1)] = exp(-( _pData[_who]->time*(_b[3] + _alp[3])));                       
      f_b_000Out[slice(nData*3, nData, 1)] = -(( _pData[_who]->time*(_b[2] + _alp[2]))
                                             /exp( _pData[_who]->time*(_b[3] + _alp[3])));
   }
   bool f_b_001( valarray&lt;double&gt;& f_b_001Out )
   {
      // Definition			  
      ...
   }
   bool f_b_002( valarray&lt;double&gt;& f_b_002Out )
   {
      // Definition			  
      ...
   }
   bool f_alp_000( valarray&lt;double&gt;& f_alp_000Out )
   {
      // Definition			  
      ...
   }
   bool f_alp_001( valarray&lt;double&gt;& f_alp_001Out )
   {
      // Definition			  
      ...
   }
   bool f_alp_002( valarray&lt;double&gt;& f_alp_002Out )
   {
      // Definition			  
      ...
   }
   void R_000( valarray&lt;double&gt;& R_000Out )
   {
      // Definition			  
      ...
   }
   void R_001( valarray&lt;double&gt;& R_001Out )
   {
      // Definition			  
      ...
   }
   void R_002( valarray&lt;double&gt;& R_002Out )
   {
      // Definition			  
      ...
   }
   bool R_b_000( valarray&lt;double&gt;& R_b_000Out )
   {
      // Definition			  
      ...
   }
   bool R_b_001( valarray&lt;double&gt;& R_b_001Out )
   {
      // Definition			  
      ...
   }
   bool R_b_002( valarray&lt;double&gt;& R_b_002Out )
   {
      // Definition			  
      ...
   }
   bool R_alp_000( valarray&lt;double&gt;& R_alp_000Out )
   {
      // Definition			  
      ...
   }
   bool R_alp_001( valarray&lt;double&gt;& R_alp_001Out )
   {
      // Definition			  
      ...
   }
   bool R_alp_002( valarray&lt;double&gt;& R_alp_002Out )
   {
      // Definition			  
      ...
   }

}
</pre></code>
</body>
</html>
