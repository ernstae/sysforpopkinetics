#include <fstream>

#include "NonmemTranslator.h"
#include "explang.h"
#include "../lower.h"
#include "../series.h"

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOM.hpp>
#include <xercesc/util/XMLString.hpp>

using namespace std;
using namespace xercesc;

//========================================
// Local namespace
//----------------------------------------
namespace{

  //
  // Approximation method
  //
  enum APPROX     { FO, FOCE, LAPLACE };
  enum TARGET     { IND, POP};
  enum MODEL_SPEC { PRED };

  //
  // Place holders to hold values/info gathered through parsings.
  // The reason why this is just locally defined, as opposed to
  // defined as a NonmemTranslator class member, is 
  // to hide the existence since it's just an object of convenience.
  //
  enum TARGET       myTarget        = POP;  
  enum MODEL_SPEC   myModelSpec     = PRED;

  bool              myIsEstimate    = true;
  bool              myIsSimulate    = false;
  bool              myIsStat        = false;
  
  APPROX            myApproximation = FO;
  unsigned int      myPopSize       = 1;
  
  bool              myIsEtaOut      = false;
  bool              myIsRestart     = true;
  unsigned int      myThetaLen      = 0;
  unsigned int      myOmegaDim      = 0;
  unsigned int      myOmegaElemNum  = 0;
  Symbol::Structure myOmegaStruct   = Symbol::TRIANGLE;
  unsigned int      mySigmaDim      = 0;
  int               mySigmaElemNum  = 0;
  Symbol::Structure mySigmaStruct   = Symbol::TRIANGLE;
  int               myEtaLen        = 0;
    
  unsigned int      myPopMitr       = 100;
  unsigned int      myIndMitr       = 100;
  double            myPopEpsilon    = 1e-3;
  double            myIndEpsilon    = 1e-3;
  int               myPopTraceLevel = 1;
  int               myIndTraceLevel = 1;
  unsigned int      mySeed = 0;

  bool              myIsStderr      = false;
  bool              myIsCorrelation = false;
  bool              myIsCov         = false;
  bool              myIsInvCov      = false;
  bool              myIsConfidence  = false;
  bool              myIsCoefficient = false;

  valarray<int> myRecordNums;
};
//========================================

//========================================
// The global variables used by
// yyparse() and yylex() (or equivalent).
//----------------------------------------
extern int           gSpkExpErrors;
extern int           gSpkExpLines;
extern SymbolTable * gSpkExpSymbolTable;
extern FILE *        gSpkExpOutput;
extern FILE *        nm_in;
extern int           NM_ACCEPT;
extern int           NM_ABORT;

extern "C"{
     int nm_parse(void);
};
//========================================

NonmemTranslator::NonmemTranslator( DOMDocument* sourceIn, DOMDocument* dataIn )
  : ClientTranslator ( sourceIn, dataIn ),
    fIndData_h       ( "IndData.h" ),
    fDataSet_h       ( "DataSet.h" ),
    fPredEqn_fortran ( "predEqn.fortran" ),
    fPredEqn_cpp     ( "predEqn.cpp" ),
    fPred_h          ( "Pred.h" ),
    fOmega_h         ( "Omega.h" ),
    fOmega_cpp       ( "Omega.cpp" ),
    fDriver_cpp      ( "driver.cpp" ),
    BURNER           ( "// THIS FILE IS GENERATED BY THE ASPK COMPILER" ),
    X_YES            ( XMLString::transcode("yes") ),
    X_NO             ( XMLString::transcode("no") ),
    X_FIXED          ( XMLString::transcode("fixed") ),
    X_IN             ( XMLString::transcode("in") ),
    X_LOW            ( XMLString::transcode("low") ),
    X_UP             ( XMLString::transcode("up") ),
    X_DIAGONAL       ( XMLString::transcode("diagonal") ),
    X_BLOCK          ( XMLString::transcode("block") ),
    X_VALUE          ( XMLString::transcode("value") ),
    X_STRUCT         ( XMLString::transcode("struct") ),
    X_DIMENSION      ( XMLString::transcode("dimension") ),
    X_LABEL          ( XMLString::transcode("label") ),
    X_IS_ERR_OUT     ( XMLString::transcode("is_stderr_out") ),
    X_IS_CORR_OUT    ( XMLString::transcode("is_correlation_out") ),
    X_IS_COV_OUT     ( XMLString::transcode("is_covariance_out") ),
    X_IS_INV_COV_OUT ( XMLString::transcode("is_inverse_covariance_out") ),
    X_IS_COEF_OUT    ( XMLString::transcode("is_coefficent_out") ),
    X_IS_CONF_OUT    ( XMLString::transcode("is_confidence_out") ),
    X_NONMEM         ( XMLString::transcode("nonmem") ),
    X_POP_ANALYSIS   ( XMLString::transcode("pop_analysis") ),
    X_IND_ANALYSIS   ( XMLString::transcode("ind_analysis") ),
    X_CONSTRAINT     ( XMLString::transcode("constraint") ),
    X_MODEL          ( XMLString::transcode("model") ),
    X_PRED           ( XMLString::transcode("pred") ),
    X_PRESENTATION   ( XMLString::transcode("presentation") ),
    X_TABLE          ( XMLString::transcode("table") ),
    X_SCATTERPLOT    ( XMLString::transcode("scatterplot") ),
    X_COLUMN         ( XMLString::transcode("column") ),
    X_X              ( XMLString::transcode("x") ),
    X_Y              ( XMLString::transcode("y") ),
    X_BY             ( XMLString::transcode("by") ),
    X_APPROXIMATION  ( XMLString::transcode("approximation") ),
    X_FO             ( XMLString::transcode("fo") ),
    X_FOCE           ( XMLString::transcode("foce") ),
    X_LAPLACE        ( XMLString::transcode("laplace") ),
    X_POP_SIZE       ( XMLString::transcode("pop_size" ) ),
    X_IS_ESTIMATION  ( XMLString::transcode("is_estimation") ),
    X_IS_ETA_OUT     ( XMLString::transcode("is_eta_out") ),
    X_IS_RESTART     ( XMLString::transcode("is_restart") ),
    X_DATA_LABELS    ( XMLString::transcode("data_labels") ),
    X_FILENAME       ( XMLString::transcode("filename") ),
    X_NAME           ( XMLString::transcode("name") ),
    X_SYNONYM        ( XMLString::transcode("synonym") ),
    X_THETA          ( XMLString::transcode("theta") ),
    X_LENGTH         ( XMLString::transcode("length") ),
    X_OMEGA          ( XMLString::transcode("omega") ),
    X_SIGMA          ( XMLString::transcode("sigma") ),
    X_SIMULATION     ( XMLString::transcode("simulation") ),
    X_SEED           ( XMLString::transcode("seed") ),
    X_POP_STAT       ( XMLString::transcode("pop_stat") ),
    X_COVARIANCE_FORM( XMLString::transcode("covariance_form") ),
    X_MITR           ( XMLString::transcode("mitr") ),
    X_IND_STAT       ( XMLString::transcode("ind_stat") )
{
}
NonmemTranslator::NonmemTranslator()
{
}
NonmemTranslator::~NonmemTranslator()
{
  XMLString::release( &X_YES );
  XMLString::release( &X_NO );
  XMLString::release( &X_FIXED );
  XMLString::release( &X_IN );
  XMLString::release( &X_LOW );
  XMLString::release( &X_UP );
  XMLString::release( &X_DIAGONAL );
  XMLString::release( &X_BLOCK );
  XMLString::release( &X_VALUE );
  XMLString::release( &X_STRUCT );
  XMLString::release( &X_DIMENSION );
  XMLString::release( &X_LABEL );
  XMLString::release( &X_IS_ERR_OUT );
  XMLString::release( &X_IS_CORR_OUT );
  XMLString::release( &X_IS_COV_OUT );
  XMLString::release( &X_IS_INV_COV_OUT );
  XMLString::release( &X_IS_COEF_OUT );
  XMLString::release( &X_IS_CONF_OUT );
  
  XMLString::release( &X_NONMEM );
  XMLString::release( &X_POP_ANALYSIS );
  XMLString::release( &X_IND_ANALYSIS );
  XMLString::release( &X_CONSTRAINT );
  XMLString::release( &X_MODEL );
  XMLString::release( &X_PRED );
  XMLString::release( &X_PRESENTATION );
  XMLString::release( &X_TABLE );
  XMLString::release( &X_SCATTERPLOT );
  XMLString::release( &X_COLUMN );
  XMLString::release( &X_X );
  XMLString::release( &X_Y );
  XMLString::release( &X_BY );
  XMLString::release( &X_APPROXIMATION );
  XMLString::release( &X_FO );
  XMLString::release( &X_FOCE );
  XMLString::release( &X_LAPLACE );
  XMLString::release( &X_POP_SIZE );
  XMLString::release( &X_IS_ESTIMATION );
  XMLString::release( &X_IS_ETA_OUT );
  XMLString::release( &X_IS_RESTART );
  XMLString::release( &X_DATA_LABELS );
  XMLString::release( &X_FILENAME );
  XMLString::release( &X_NAME );
  XMLString::release( &X_SYNONYM );
  XMLString::release( &X_THETA );
  XMLString::release( &X_LENGTH );
  XMLString::release( &X_OMEGA );
  XMLString::release( &X_SIGMA );
  XMLString::release( &X_SIMULATION );
  XMLString::release( &X_SEED );
  XMLString::release( &X_POP_STAT );
  XMLString::release( &X_COVARIANCE_FORM );
  XMLString::release( &X_MITR );
  XMLString::release( &X_IND_STAT );
}
NonmemTranslator::NonmemTranslator( const NonmemTranslator& )
{
}
NonmemTranslator& NonmemTranslator::operator=( const NonmemTranslator& )
{
}
void NonmemTranslator::parseSource()
{
  assert( table.getLabels()->size() > 0 );

  DOMElement * spksouce = source->getDocumentElement();
  DOMNodeList * nonmems = spksouce->getElementsByTagName( X_NONMEM );
  assert( nonmems->getLength() == 1 );
  DOMElement * nonmem = dynamic_cast<DOMElement*>( nonmems->item(0) );

  //------------------------------------------------------
  // <constraint>
  //------------------------------------------------------
  DOMNodeList * constraints = nonmem->getElementsByTagName( X_CONSTRAINT );
  assert( constraints->getLength() == 1 );
  DOMElement * constraint = dynamic_cast<DOMElement*>( constraints->item(0) );
  assert( constraint->hasChildNodes() );

  DOMNodeList * pop_analysises = constraint->getElementsByTagName( X_POP_ANALYSIS );
  DOMNodeList * ind_analysises = constraint->getElementsByTagName( X_IND_ANALYSIS );
  DOMElement * analysis;
  bool isAnalysisDone = false;
  if( pop_analysises->getLength() == 1 )
    {
      myTarget = POP;
      analysis = dynamic_cast<DOMElement*>( pop_analysises->item(0) );
      parsePopAnalysis( analysis );
      isAnalysisDone = true;
    }
  else if( ind_analysises->getLength() == 1 )
    {
      myTarget = IND;
      analysis = dynamic_cast<DOMElement*>( ind_analysises->item(0) );
      myPopSize = 1;
      parseIndAnalysis( analysis );
      isAnalysisDone = true;
    }
  else
    {
      // illegal
      assert( pop_analysises->getLength() == 1 || ind_analysises->getLength() == 1 );
    }
  //------------------------------------------------------
  // <model>
  // NOTE: only <pred> is allowed under <model> for v0.1.
  //------------------------------------------------------
  DOMNodeList * models = nonmem->getElementsByTagName( X_MODEL );
  assert( models->getLength() == 1 );
  DOMElement * model = dynamic_cast<DOMElement*>( models->item(0) );
  DOMNodeList * preds = model->getElementsByTagName( X_PRED );
  assert( preds->getLength() == 1 );
  DOMElement * pred = dynamic_cast<DOMElement*>( preds->item(0) );
  myModelSpec = PRED;

  bool isPredDone = false;
  parsePred( pred );
  isPredDone = true;

  //------------------------------------------------------
  // <presentation>
  //------------------------------------------------------
  // PRED parsing and <xxx_analysis> parsing must have been completed so that the symbol table
  // contains entries for the user defined variables and THETA/OMEGA/SIGMA/ETA, respectively.
  assert( isPredDone );
  assert( isAnalysisDone );
  
  DOMNodeList * presentations = nonmem->getElementsByTagName( X_PRESENTATION );
  assert( presentations->getLength() == 1 );
  DOMElement * presentation = dynamic_cast<DOMElement*>( presentations->item(0) );

  myRecordNums.resize( myPopSize );
  Symbol * id = table.findi( "ID" );
  assert( id != NULL || id != Symbol::empty() );
  for( int i=0; i<myPopSize; i++ )
    {
      myRecordNums[i] = id->initial[i].size();
    }

  // For PRED, a label allowed in table/scatterplot specification is one of:
  // * THETA, OMEGA, (SIGMA), (ETA) --- <xxx_analysis> should have been done by now
  // * data labels  --- parseData() should have been done by now
  // * user defined variables in PRED definition --- PRED parsing should have been done by now
  // * PRED, RES, WRES
  if( table.findi( "PRED" ) == Symbol::empty() )
    table.insertUserVar( "PRED" );
  if( table.findi( "RES" )  == Symbol::empty() )
    table.insertUserVar( "RES" );
  if( myTarget == POP && table.findi( "WRES" ) == Symbol::empty() )
    table.insertUserVar( "WRES" );

  //
  // Generate the headers and definition files for IndData class and
  // DataSet class.
  //
  // The symbol table (ie. the order of data labels in the list) must not change
  // in between the following two routines.
  //
  generateDataSet( );
  generateIndData( );
  generatePred( fPredEqn_cpp );
  if( myTarget == POP )
    generatePopDriver();
  else
    generateIndDriver();
}

void NonmemTranslator::parsePopAnalysis( DOMElement* pop_analysis )
{
  
  //================================================================================
  // Required attributes
  //================================================================================
  // * approximation = {fo, foce, laplace}
  // * pop_size
  // * is_estimation = {yes, no}

  //
  // Finding out the approximation method
  //
  assert( pop_analysis->hasAttribute( X_APPROXIMATION ) );
  const XMLCh * xml_approx = pop_analysis->getAttribute( X_APPROXIMATION );

  if( XMLString::equals( xml_approx, X_FO ) )
    myApproximation = FO;
  else if( XMLString::equals( xml_approx, X_FOCE ) )
    myApproximation = FOCE;
  else if( XMLString::equals( xml_approx, X_LAPLACE ) )
    myApproximation = LAPLACE;
  else
    {
      assert( false );
    }

  //
  // Finding out the population size
  //
  assert( pop_analysis->hasAttribute( X_POP_SIZE ) );
  const XMLCh * xml_pop_size = pop_analysis->getAttribute( X_POP_SIZE );
  if( !XMLString::textToBin( xml_pop_size, myPopSize ) )
    {
      assert( false );
    }

  //
  // Finding out if parameter estimation is requested.
  //
  assert( pop_analysis->hasAttribute( X_IS_ESTIMATION ) );
  const XMLCh * xml_is_estimation = pop_analysis->getAttribute( X_IS_ESTIMATION );
  myIsEstimate = ( XMLString::equals( xml_is_estimation, X_YES )? true : false );

  //================================================================================
  // Optional attributes
  //================================================================================
  // * is_eta_out = {yes, "no"}
  // * is_restart = {"yes", no}
  myIsEtaOut = false;
  const XMLCh * xml_is_eta_out;
  if( pop_analysis->hasAttribute( X_IS_ETA_OUT ) )
    {
      xml_is_eta_out = pop_analysis->getAttribute( X_IS_ETA_OUT );
      myIsEtaOut = ( XMLString::equals( xml_is_eta_out, X_YES )? true : false );
    }

  myIsRestart = true;
  const XMLCh * xml_is_restart;
  if( pop_analysis->hasAttribute( X_IS_RESTART ) )
    {
      xml_is_restart = pop_analysis->getAttribute( X_IS_RESTART );
      myIsRestart = ( XMLString::equals( xml_is_restart, X_YES )? true : false );
    }
     
  //================================================================================
  // Required elements
  //================================================================================
  // <data_labels>
  // <theta>
  // <omega>+
  // <sigma>+
  DOMNodeList * data_labels_list = pop_analysis->getElementsByTagName( X_DATA_LABELS );
  assert( data_labels_list->getLength() == 1 );
  DOMElement * data_labels = dynamic_cast<DOMElement*>( data_labels_list->item(0) );
  {
     // Required <data_labels> attributes
     // * filename = CDATA
    assert( data_labels->hasAttribute( X_FILENAME ) );
     const XMLCh* xml_data_filename = data_labels->getAttribute( X_FILENAME );
     assert( XMLString::stringLen( xml_data_filename ) > 0 );

     DOMNodeList * labels = data_labels->getElementsByTagName( X_LABEL );
     int nLabels = labels->getLength();
     assert( nLabels > 0 );
     for( int i=0; i<nLabels; i++ )
       {
	 DOMElement * xml_label = dynamic_cast<DOMElement*>( labels->item(i) );
	 // <label> is an empty element

         // required attribute
	 // * name
	 assert( xml_label->hasAttribute( X_NAME ) );
	 const XMLCh* xml_name = xml_label->getAttribute( X_NAME );
	 assert( XMLString::stringLen( xml_name ) > 0 );
         char * c_name = XMLString::transcode( xml_name );
	 Symbol * name = table.findi( c_name );
	 assert( name != Symbol::empty() );
         delete c_name;

	 // optional attribute
	 // * synonym
         if( xml_label->hasAttribute( X_SYNONYM ) )
	   {
	     const XMLCh* xml_synonym = xml_label->getAttribute( X_SYNONYM );
	     char * c_synonym = XMLString::transcode( xml_synonym );
	     // register the synonym to the symbol table
	     name->synonym = string( c_synonym );
	     delete c_synonym;
	   }
       }
  }

  char valueDefault[] = "0.0";

  DOMNodeList * theta_list = pop_analysis->getElementsByTagName( X_THETA );
  assert( theta_list->getLength() == 1 );
  DOMElement * theta = dynamic_cast<DOMElement*>( theta_list->item(0) );
  assert( theta->hasAttribute( X_LENGTH ) );
  const XMLCh* xml_theta_len = theta->getAttribute( X_LENGTH );
  myThetaLen = 0;
  if( !XMLString::textToBin( xml_theta_len, myThetaLen ) )
    {
      assert( myThetaLen > 0 );
    }
  Symbol * sym_theta = table.insertNMVector( "THETA", myThetaLen );
  {
    //<in>
    DOMNodeList * theta_in_list = theta->getElementsByTagName( X_IN );
    assert( theta_in_list->getLength() == 1 );
    DOMElement * theta_in = dynamic_cast<DOMElement*>( theta_in_list->item(0) );

    DOMNodeList * value_list = theta_in->getElementsByTagName( X_VALUE );
    assert( myThetaLen == value_list->getLength() );
    for( int i=0; i<myThetaLen; i++ )
      {
	char str_val[128];
        bool isFixed = false;
	DOMElement * value = dynamic_cast<DOMElement*>( value_list->item(i) );
	if( value->hasAttribute( X_FIXED ) )
	  {
	    const XMLCh* xml_fixed = value->getAttribute( X_FIXED );
	    isFixed = (XMLString::equals( xml_fixed, X_YES )? true : false );
	  }
	const XMLCh* xml_val = value->getFirstChild()->getNodeValue();
	if( XMLString::stringLen( xml_val ) == 0 )
	  strcpy( str_val, valueDefault );
	else
	  {
	    char * tmp_c_val = XMLString::transcode( xml_val );
	    strcpy( str_val, tmp_c_val );
	    delete tmp_c_val;
	  }
	sym_theta->initial[0][i] = str_val;
	sym_theta->fixed[0][i]   = isFixed;
      }
    //<low>
    DOMNodeList * theta_low_list = theta->getElementsByTagName( X_LOW );
    assert( theta_low_list->getLength() == 1 );
    DOMElement * theta_low = dynamic_cast<DOMElement*>( theta_low_list->item(0) );
    value_list = theta_low->getElementsByTagName( X_VALUE );
    assert( myThetaLen == value_list->getLength() );
    for( int i=0; i<myThetaLen; i++ )
      {
	char str_val[128];
	DOMElement * value = dynamic_cast<DOMElement*>( value_list->item(i) );
	const XMLCh* xml_val = value->getFirstChild()->getNodeValue();
	if( XMLString::stringLen( xml_val ) == 0 )
	  strcpy( str_val, valueDefault );
	else
	  {
	    char * tmp_c_val = XMLString::transcode( xml_val );
	    strcpy( str_val, tmp_c_val );
	    delete tmp_c_val;
	  }
	sym_theta->lower[0][i] = str_val;
      }

    //<up>
    DOMNodeList * theta_up_list = theta->getElementsByTagName( X_UP );
    assert( theta_up_list->getLength() == 1 );
    DOMElement * theta_up = dynamic_cast<DOMElement*>( theta_up_list->item(0) );
    value_list = theta_up->getElementsByTagName( X_VALUE );
    assert( myThetaLen == value_list->getLength() );
    for( int i=0; i<myThetaLen; i++ )
      {
	char str_val[128];
	const XMLCh* xml_val = value_list->item(i)->getFirstChild()->getNodeValue();
	if( XMLString::stringLen( xml_val ) == 0 )
	  strcpy( str_val, valueDefault );
	else
	  {
	    char * tmp_c_val = XMLString::transcode( xml_val );
	    strcpy( str_val, tmp_c_val );
	    delete tmp_c_val;
	  }
	sym_theta->upper[0][i] = str_val;
      }
    for( i=0; i<myThetaLen; i++ )
      sym_theta->step[0][i] = ( atof( sym_theta->upper[0][i] ) - atof( sym_theta->lower[0][i] ) ) / 1000.;
  }

  DOMNodeList * omega_list = pop_analysis->getElementsByTagName( X_OMEGA );
  int nOmegaSpecs = omega_list->getLength();
  assert( nOmegaSpecs == 1 );// v0.1 supports only one (full) Omega specification
  DOMElement * omega = dynamic_cast<DOMElement*>( omega_list->item(0) );
  assert( omega->hasAttribute( X_DIMENSION ) );
  const XMLCh* xml_omega_dim = omega->getAttribute( X_DIMENSION );
  if( !XMLString::textToBin( xml_omega_dim, myOmegaDim ) )
    {
      assert( myOmegaDim > 0 );
    }

  assert( omega->hasAttribute( X_STRUCT ) );
  const XMLCh* xml_omega_struct = omega->getAttribute( X_STRUCT );
  if( XMLString::equals( xml_omega_struct, X_DIAGONAL ) )
    {
      myOmegaStruct = Symbol::DIAGONAL;
      myOmegaElemNum = myOmegaDim;
    }
  else if( XMLString::equals( xml_omega_struct, X_BLOCK ) )
    {
      myOmegaStruct = Symbol::TRIANGLE;
      myOmegaElemNum = series( 1, 1, myOmegaDim );
    }
  else
    assert( false );
  Symbol * sym_omega = table.insertNMMatrix( "OMEGA", myOmegaStruct, myOmegaDim );
  {
    //<in>
    DOMNodeList * omega_in_list = omega->getElementsByTagName( X_IN );
    assert( omega_in_list->getLength() == 1 );
    DOMElement * omega_in = dynamic_cast<DOMElement*>( omega_in_list->item(0) );

    DOMNodeList * value_list = omega_in->getElementsByTagName( X_VALUE );
    assert( myOmegaElemNum == value_list->getLength() );
    for( int i=0; i<myOmegaElemNum; i++ )
      {
	char str_val[128];
        bool isFixed = false;
	DOMElement * value = dynamic_cast<DOMElement*>( value_list->item(i) );
	if( value->hasAttribute( X_FIXED ) )
	  {
	    const XMLCh* xml_fixed = value->getAttribute( X_FIXED );
	    isFixed = (XMLString::equals( xml_fixed, X_YES )? true : false );
	  }
	const XMLCh* xml_val = value->getFirstChild()->getNodeValue();

	if( XMLString::stringLen( xml_val ) == 0 )
	  strcpy( str_val, valueDefault );
	else
	  {
	    char * tmp_c_val = XMLString::transcode( xml_val );
	    strcpy( str_val, tmp_c_val );
	    delete tmp_c_val;
	  }
	sym_omega->initial[0][i] = str_val;
	sym_omega->fixed[0][i]   = isFixed;
      }
  }

  DOMNodeList * simga_list = pop_analysis->getElementsByTagName( X_SIGMA );
  int nSigmaSpecs = simga_list->getLength();
  assert( nSigmaSpecs == 1 );// v0.1 supports only one (full) Sigma specification
  DOMElement * sigma = dynamic_cast<DOMElement*>( simga_list->item(0) );
  assert( sigma->hasAttribute( X_DIMENSION ) );
  const XMLCh* xml_sigma_dim = sigma->getAttribute( X_DIMENSION );
  if( !XMLString::textToBin( xml_sigma_dim, mySigmaDim ) )
    {
      assert( mySigmaDim > 0 );
    }

  assert( sigma->hasAttribute( X_STRUCT ) );
  const XMLCh* xml_sigma_struct = sigma->getAttribute( X_STRUCT );
  if( XMLString::equals( xml_sigma_struct, X_DIAGONAL ) )
    {
      mySigmaStruct = Symbol::DIAGONAL;
      mySigmaElemNum = mySigmaDim;
    }
  else if( XMLString::equals( xml_sigma_struct, X_BLOCK ) )
    {
      mySigmaStruct = Symbol::TRIANGLE;
      mySigmaElemNum = series( 1, 1, mySigmaDim );
    }
  else
    assert( false );
  Symbol * sym_sigma = table.insertNMMatrix( "SIGMA", mySigmaStruct, mySigmaDim ); 
  {
    //<in>
    DOMNodeList * sigma_in_list = sigma->getElementsByTagName( X_IN );
    assert( sigma_in_list->getLength() == 1 );
    DOMElement * sigma_in = dynamic_cast<DOMElement*>( sigma_in_list->item(0) );

    DOMNodeList * value_list = sigma_in->getElementsByTagName( X_VALUE );
    assert( mySigmaElemNum == value_list->getLength() );
    for( int i=0; i<mySigmaElemNum; i++ )
      {
	char str_val[128];
        bool isFixed = false;
	DOMElement * value = dynamic_cast<DOMElement*>( value_list->item(i) );
	if( value->hasAttribute( X_FIXED ) )
	  {
	    const XMLCh* xml_fixed = value->getAttribute( X_FIXED );
	    isFixed = (XMLString::equals( xml_fixed, X_YES )? true : false );
	  }
	const XMLCh* xml_val = value->getFirstChild()->getNodeValue();

	if( XMLString::stringLen( xml_val ) == 0 )
	  strcpy( str_val, valueDefault );
	else
	  {
	    char * tmp_c_val = XMLString::transcode( xml_val );
	    strcpy( str_val, tmp_c_val );
	    delete tmp_c_val;
	  }
	sym_sigma->initial[0][i] = str_val;
	sym_sigma->fixed[0][i]   = isFixed;
      }
  }
  
  //----------------------------------------------------------
  // eta
  // NOTE: eta is not given by the user.  
  // eta's initial estimate is set to 0.0 automatically.
  //
  // REVISIT - Sachiko 01/22/04
  // The boundary values must be computed automatically too.
  //-----------------------------------------------------------
  myEtaLen = myThetaLen;
  char etaDefault[] = "0.0";
  Symbol * sym_eta = table.insertNMVector( "ETA", myEtaLen );
  sym_eta->initial[0] = etaDefault;
  sym_eta->fixed[0] = false;

  //================================================================================
  // (Optional) Statistics elements
  //================================================================================
  // <description>  --- ignore!
  // <simulation>
  // <pop_stat>
  myIsSimulate = false;
  mySeed       = 0;
  DOMNodeList * simulations = pop_analysis->getElementsByTagName( X_SIMULATION );
  if( simulations->getLength() > 0 )
    {
      assert( simulations->getLength() == 1 );
      myIsSimulate = true;
      DOMElement* simulation = dynamic_cast<DOMElement*>( simulations->item(0) );
      assert( simulation->hasAttribute( X_SEED ) );
      const XMLCh* xml_seed = simulation->getAttribute( X_SEED );
      if( !XMLString::textToBin( xml_seed, mySeed ) )
	{
	  assert( false );
	}
    }
  
  DOMNodeList * pop_stat_list = pop_analysis->getElementsByTagName( X_POP_STAT );
  myIsStderr      = false;//default
  myIsCorrelation = false;//default
  myIsCov         = false;//default
  myIsInvCov      = false;//default
  myIsConfidence  = false;//default
  myIsCoefficient = false;//default
  // Statistics computation can be done only when the parameter estimation
  // is requested.
  if( pop_stat_list->getLength() > 0 && myIsEstimate )
    {
      assert( pop_stat_list->getLength() == 1 );
      DOMElement * pop_stat = dynamic_cast<DOMElement*>( pop_stat_list->item(0) );
      assert( pop_stat->hasAttribute( X_COVARIANCE_FORM ) );
      const XMLCh* cov_form = pop_stat->getAttribute( X_COVARIANCE_FORM ); // r, rsr, s

      if( pop_stat->hasAttribute( X_IS_ERR_OUT ) )
	{
	  const XMLCh* xml_stderr = pop_stat->getAttribute( X_IS_ERR_OUT );
	  myIsStderr = (XMLString::equals( xml_stderr, X_YES )? true : false );
	}

      if( pop_stat->hasAttribute( X_IS_CORR_OUT ) )
	{
	  const XMLCh* xml_correlation = pop_stat->getAttribute( X_IS_CORR_OUT );
	  myIsCorrelation = (XMLString::equals( xml_correlation, X_YES )? true : false );
	}

      if( pop_stat->hasAttribute( X_IS_COV_OUT ) )
	{
	  const XMLCh* xml_cov = pop_stat->getAttribute( X_IS_COV_OUT );
	  myIsCov = (XMLString::equals( xml_cov, X_YES )? true : false );
	}

      if( pop_stat->hasAttribute( X_IS_INV_COV_OUT ) )
	{
	  const XMLCh* xml_inv_cov = pop_stat->getAttribute( X_IS_INV_COV_OUT );
	  myIsInvCov = (XMLString::equals( xml_inv_cov, X_YES )? true : false );
	}

      if( pop_stat->hasAttribute( X_IS_CONF_OUT ) )
	{
	  const XMLCh* xml_conf = pop_stat->getAttribute( X_IS_CONF_OUT );
	  myIsConfidence = (XMLString::equals( xml_conf, X_YES )? true : false );
	}

      if( pop_stat->hasAttribute( X_IS_COEF_OUT ) )
	{
	  const XMLCh* xml_coef = pop_stat->getAttribute( X_IS_COEF_OUT );
	  myIsCoefficient = (XMLString::equals( xml_coef, X_YES )? true : false );
	}
    }
  myIsStat = myIsStderr || myIsCorrelation || myIsCov || myIsInvCov || myIsConfidence || myIsCoefficient;

  return;
}
void NonmemTranslator::parseIndAnalysis( DOMElement* ind_analysis )
{
  //================================================================================
  // Required attributes
  //================================================================================
  // * is_estimation = {yes, no}
  const XMLCh * xml_is_estimation = ind_analysis->getAttribute( X_IS_ESTIMATION );
  assert( XMLString::stringLen( xml_is_estimation ) > 0 );
  myIsEstimate = ( XMLString::equals( xml_is_estimation, X_YES )? true : false );

  //================================================================================
  // Optional attributes
  //================================================================================
  // * mitr   --- required when is_estimation == "yes"
  // * is_restart = {"yes", no}
  myIsRestart = true;
  myIndMitr = 0;
  const XMLCh * xml_is_restart = ind_analysis->getAttribute( X_IS_RESTART );
  if( XMLString::stringLen( xml_is_restart ) )
      myIsRestart = ( XMLString::equals( xml_is_restart, X_YES )? true : false );
  if( myIsEstimate )
    {
      const XMLCh* xml_mitr = ind_analysis->getAttribute( X_MITR );
      assert( XMLString::stringLen( xml_mitr ) > 0 );
      if( !XMLString::textToBin( xml_mitr, myIndMitr ) )
	assert( xml_mitr > 0 );
    }
  //================================================================================
  // Required elements
  //================================================================================
  // <data_labels>
  // <theta>
  // <omega>+
  DOMNodeList * data_labels_list = ind_analysis->getElementsByTagName( X_DATA_LABELS );
  assert( data_labels_list->getLength() == 1 );
  DOMElement * data_labels = dynamic_cast<DOMElement*>( data_labels_list->item(0) );
  {
     // Required <data_labels> attributes
     // * filename = CDATA
     const XMLCh* xml_data_filename = data_labels->getAttribute( X_FILENAME );
     assert( XMLString::stringLen( xml_data_filename ) > 0 );

     DOMNodeList * labels = data_labels->getElementsByTagName( X_LABEL );
     int nLabels = labels->getLength();
     assert( nLabels > 0 );
     for( int i=0; i<nLabels; i++ )
       {
	 DOMElement * xml_label = dynamic_cast<DOMElement*>( labels->item(i) );
	 // <label> is an empty element

         // required attribute
	 // * name
	 const XMLCh* xml_name = xml_label->getAttribute( X_NAME );
	 assert( XMLString::stringLen( xml_name ) > 0 );
	 char * c_name = XMLString::transcode( xml_name );
	 Symbol * name = table.findi( c_name );
	 assert( name != Symbol::empty() );
	 delete c_name;

	 // optional attribute
	 // * synonym
         const XMLCh* xml_synonym = xml_label->getAttribute( X_SYNONYM );
	 if( XMLString::stringLen( xml_synonym ) > 0 )
	   {
	     char * c_synonym = XMLString::transcode( xml_synonym );
	     // register the synonym to the symbol table
	     name->synonym = c_synonym;
	     delete c_synonym;
	   }
       }
  }

  DOMNodeList * theta_list = ind_analysis->getElementsByTagName( X_THETA );
  assert( theta_list->getLength() == 1 );
  DOMElement * theta = dynamic_cast<DOMElement*>( theta_list->item(0) );
  const XMLCh* xml_theta_len = theta->getAttribute( X_LENGTH );
  assert( XMLString::stringLen( xml_theta_len ) > 0 );
  myThetaLen = 0;
  if( !XMLString::textToBin( xml_theta_len, myThetaLen ) )
    {
      assert( myThetaLen > 0 );
    }
  Symbol * sym_theta = table.insertNMVector( "THETA", myThetaLen );
  {
    //<in>
    DOMNodeList * theta_in_list = theta->getElementsByTagName( X_IN );
    assert( theta_in_list->getLength() == 1 );
    DOMElement * theta_in = dynamic_cast<DOMElement*>( theta_in_list->item(0) );

    DOMNodeList * value_list = theta_in->getElementsByTagName( X_VALUE );
    assert( myThetaLen == value_list->getLength() );
    for( int i=0; i<myThetaLen; i++ )
      {
	char str_val[128];
        bool isFixed = false;
	DOMElement * value = dynamic_cast<DOMElement*>( value_list->item(i) );
        const XMLCh* xml_fixed = value->getAttribute( X_FIXED );
	if( XMLString::stringLen( xml_fixed ) != 0 )
	  {
	    isFixed = (XMLString::equals( xml_fixed, X_YES )? true : false );
	  }
	const XMLCh* xml_val = value->getFirstChild()->getNodeValue();
	if( XMLString::stringLen( xml_val ) == 0 )
	  strcpy( str_val, "0.0" );
	else
	  {
	    char * tmp_c_val = XMLString::transcode( xml_val );
	    strcpy( str_val, tmp_c_val );
	    delete tmp_c_val;
	  }
	sym_theta->initial[0][i] = str_val;
	sym_theta->fixed[0][i]   = isFixed;
      }
    //<low>
    DOMNodeList * theta_low_list = theta->getElementsByTagName( X_LOW );
    assert( theta_low_list->getLength() == 1 );
    DOMElement * theta_low = dynamic_cast<DOMElement*>( theta_low_list->item(0) );
    value_list = theta_low->getElementsByTagName( X_VALUE );
    assert( myThetaLen == value_list->getLength() );
    for( int i=0; i<myThetaLen; i++ )
      {
	char str_val[128];
	DOMElement * value = dynamic_cast<DOMElement*>( value_list->item(i) );
	const XMLCh* xml_val = value->getFirstChild()->getNodeValue();
	if( XMLString::stringLen( xml_val ) == 0 )
	  strcpy( str_val, "0.0" );
	else
	  {
	    char * tmp_c_val = XMLString::transcode( xml_val );
	    strcpy( str_val, tmp_c_val );
	    delete tmp_c_val;
	  }
	sym_theta->lower[0][i] = str_val;
      }

    //<up>
    DOMNodeList * theta_up_list = theta->getElementsByTagName( X_UP );
    assert( theta_up_list->getLength() == 1 );
    DOMElement * theta_up = dynamic_cast<DOMElement*>( theta_up_list->item(0) );
    value_list = theta_up->getElementsByTagName( X_VALUE );
    assert( myThetaLen == value_list->getLength() );
    for( int i=0; i<myThetaLen; i++ )
      {
	char str_val[128];
	const XMLCh* xml_val = value_list->item(i)->getFirstChild()->getNodeValue();
	if( XMLString::stringLen( xml_val ) == 0 )
	  strcpy( str_val, "0.0" );
	else
	  {
	    char * tmp_c_val = XMLString::transcode( xml_val );
	    strcpy( str_val, tmp_c_val );
	    delete tmp_c_val;
	  }
	sym_theta->upper[0][i] = str_val;
      }
    }

  DOMNodeList * omega_list = ind_analysis->getElementsByTagName( X_OMEGA );
  int nOmegaSpecs = omega_list->getLength();
  assert( nOmegaSpecs == 1 );// v0.1 supports only one (full) Omega specification
  DOMElement * omega = dynamic_cast<DOMElement*>( omega_list->item(0) );
  const XMLCh* xml_omega_dim = omega->getAttribute( X_DIMENSION );
  assert( XMLString::stringLen( xml_omega_dim ) > 0 );
  if( !XMLString::textToBin( xml_omega_dim, myOmegaDim ) )
    {
      assert( myOmegaDim > 0 );
    }
  const XMLCh* xml_omega_struct = omega->getAttribute( X_STRUCT );
  assert( XMLString::stringLen( xml_omega_struct ) > 0 );
  if( XMLString::equals( xml_omega_struct, X_DIAGONAL ) )
    {
      myOmegaStruct = Symbol::DIAGONAL;
      myOmegaElemNum = myOmegaDim;
    }
  else if( XMLString::equals( xml_omega_struct, X_BLOCK ) )
    {
      myOmegaStruct = Symbol::TRIANGLE;
      myOmegaElemNum = series( 1, 1, myOmegaDim );
    }
  else
    assert( false );
  Symbol * sym_omega = table.insertNMMatrix( "OMEGA", myOmegaStruct, myOmegaDim );
  {
    //<in>
    DOMNodeList * omega_in_list = omega->getElementsByTagName( X_IN );
    assert( omega_in_list->getLength() == 1 );
    DOMElement * omega_in = dynamic_cast<DOMElement*>( omega_in_list->item(0) );

    DOMNodeList * value_list = omega_in->getElementsByTagName( X_VALUE );
    assert( myOmegaElemNum == value_list->getLength() );
    for( int i=0; i<myOmegaElemNum; i++ )
      {
	char str_val[128];
        bool isFixed = false;
	DOMElement * value = dynamic_cast<DOMElement*>( value_list->item(i) );
        const XMLCh* xml_fixed = value->getAttribute( X_FIXED );
	if( XMLString::stringLen( xml_fixed ) != 0 )
	  {
	    isFixed = (XMLString::equals( xml_fixed, X_YES )? true : false );
	  }
	const XMLCh* xml_val = value->getFirstChild()->getNodeValue();

	if( XMLString::stringLen( xml_val ) == 0 )
	  strcpy( str_val, "0.0" );
	else
	  {
	    char * tmp_c_val = XMLString::transcode( xml_val );
	    strcpy( str_val, tmp_c_val );
	    delete tmp_c_val;
	  }
	sym_omega->initial[0][i] = str_val;
	sym_omega->fixed[0][i]   = isFixed;
      }
  }

  //================================================================================
  // Optional elements
  //================================================================================
  // <description>  --- ignore!
  // <simulation>
  // <ind_stat>
  myIsSimulate = false;
  mySeed = 0;
  DOMNodeList * simulations = ind_analysis->getElementsByTagName( X_SIMULATION );
  if( simulations->getLength() > 0 )
    {
      assert( simulations->getLength() == 1 );
      myIsSimulate = true;
      DOMElement* simulation = dynamic_cast<DOMElement*>( simulations->item(0) );
      const XMLCh* xml_seed = simulation->getAttribute( X_SEED );
      assert( XMLString::stringLen( xml_seed ) > 0 );
      if( !XMLString::textToBin( xml_seed, mySeed ) )
	{
	  assert( false );
	}
    }

  DOMNodeList * ind_stat_list = ind_analysis->getElementsByTagName( X_IND_STAT );
  myIsStderr      = false;//default
  myIsCorrelation = false;//default
  myIsCov         = false;//default
  myIsInvCov      = false;//default
  myIsConfidence  = false;//default
  myIsCoefficient = false;//default

  // Statistics computation can be done only when the parameter estimation
  // is requested.
  if( ind_stat_list->getLength() > 0 && myIsEstimate )
    {
      assert( ind_stat_list->getLength() == 1 );
      DOMElement * ind_stat = dynamic_cast<DOMElement*>( ind_stat_list->item(0) );
      const XMLCh* xml_stderr = ind_stat->getAttribute( X_IS_ERR_OUT );
      if( XMLString::stringLen( xml_stderr ) > 0 )
      {
	myIsStderr = (XMLString::equals( xml_stderr, X_YES )? true : false );
      }
      const XMLCh* xml_correlation = ind_stat->getAttribute( X_IS_CORR_OUT );
      if( XMLString::stringLen( xml_correlation ) > 0 )
      {
	myIsCorrelation = (XMLString::equals( xml_correlation, X_YES )? true : false );
      }
      const XMLCh* xml_cov = ind_stat->getAttribute( X_IS_COV_OUT );
      if( XMLString::stringLen( xml_cov ) > 0 )
      {
	myIsCov = (XMLString::equals( xml_cov, X_YES )? true : false );
      }
      const XMLCh* xml_inv_cov = ind_stat->getAttribute( X_IS_INV_COV_OUT );
      if( XMLString::stringLen( xml_inv_cov ) > 0 )
      {
	myIsInvCov = (XMLString::equals( xml_inv_cov, X_YES )? true : false );
      }
      const XMLCh* xml_conf = ind_stat->getAttribute( X_IS_CONF_OUT );
      if( XMLString::stringLen( xml_conf ) > 0 )
      {
	myIsConfidence = (XMLString::equals( xml_conf, X_YES )? true : false );
      }
      const XMLCh* xml_coef = ind_stat->getAttribute( X_IS_COEF_OUT );
      if( XMLString::stringLen( xml_coef ) > 0 )
      {
	myIsCoefficient = (XMLString::equals( xml_coef, X_YES )? true : false );
      }
    }
  myIsStat = myIsStderr || myIsCorrelation || myIsCov || myIsInvCov || myIsConfidence || myIsCoefficient;

  return;
}
void NonmemTranslator::parsePred( DOMElement * pred )
{
  char * c_equations = NULL;
  const XMLCh* xml_pred_def = pred->getFirstChild()->getNodeValue();
  int size = XMLString::stringLen( xml_pred_def );

  if( size > 0 )
    c_equations = XMLString::transcode( xml_pred_def );

  nm_in = fopen( fPredEqn_fortran, "w" );
  fprintf( nm_in, "%s", c_equations );
  fclose( nm_in );
  delete c_equations;

  nm_in = fopen( fPredEqn_fortran, "r" );
  gSpkExpOutput = fopen( fPredEqn_cpp, "w" );
  gSpkExpSymbolTable = &table;

  try{
    nm_parse();
  }
  catch( ... )
    {
      assert( false );
    }

  fclose( nm_in );
  fclose( gSpkExpOutput );
  remove( fPredEqn_fortran );
}
//=========================================================================================
// Generate the declaration and the definition files for each
// IndData class and IndDataSet class.
//=========================================================================================
void NonmemTranslator::generateIndData( ) const
{
  // The constructor of IndData takes a data record as arguments.
  // The constructor initializer associates Label vs. Synonym.
  // The data items are all public.
  const Symbol * pID = table.findi( "id" );

  //
  // The order in which the label strings appear is crutial.
  // So, get a constant pointer to the list and the iterator
  // for throughout use.
  //
  const vector<string> * labels = table.getLabels();
  vector<string>::const_iterator pLabel;

  // 
  // rawTable points to the actual std::map object that
  // mapps the label strings and its associated data values.
  //
  const map<const string, Symbol> * const rawTable = table.getTable();
  map<const string, Symbol>::const_iterator pRawTable;

  //
  // Declare and define IndData template class.
  // For name binding reason, the declaration and the definition
  // are both stored in a single file: IndData.h
  //
  ofstream oIndData_h( fIndData_h );
  if( oIndData_h.good() )
    {
      oIndData_h << BURNER << " <" << __FILE__ << ">" << endl;

      oIndData_h << "#ifndef INDDATA_H" << endl;
      oIndData_h << "#define INDDATA_H" << endl;
      oIndData_h << "#include <valarray>" << endl;
      oIndData_h << endl;

      //-----------------------------------------------
      // Declaration
      //-----------------------------------------------
      oIndData_h << "template <class T>" << endl;
      oIndData_h << "class IndData{" << endl;

      //
      // Public member declaration
      //
      oIndData_h << "public:" << endl;

      //
      // The only legal constructor interface declaration.
      // The constructor takes a list of valarray objects as arguments.
      // The arguments are for the variables whose names
      // are defined as *the data labels* in the NONMEM term.
      //
      oIndData_h << "IndData( int nIn";
      pLabel = labels->begin();
      for( ; pLabel != labels->end(); pLabel++ )
	{
          bool isID = ( *pLabel == pID->name );
	  oIndData_h << "," << endl;
	  
	  //
	  // If the label is of "ID", then, the data type is char*.
	  // Otherwise, all others are double.
	  //
	  oIndData_h << '\t' << "const std::valarray<" << (isID? "char*":"T") << ">";
          oIndData_h << " & " << *pLabel << "In";
	}
      oIndData_h << ");" << endl;
      oIndData_h << endl;

      // 
      // Declare the valarray variables, both *the data labels* and *the synonyms*.
      //
      string synonym;
      pLabel = labels->begin();
      for( ; pLabel != labels->end(); pLabel++ )
	{
	  //
	  // If the label string is of "ID", then the data type is char*.
	  // Otherwise, double.
	  //
          bool isID = ( *pLabel == pID->name );
	  oIndData_h << "const std::valarray<" << (isID? "char*":"T") << ">";
          oIndData_h << " " << *pLabel << ";" << endl;
	  if( ( synonym = table.findi( *pLabel )->synonym ) != "" )
	  {
             oIndData_h << "const std::valarray<" << (isID? "char*":"T") << ">";
             oIndData_h << " " << synonym << ";" << endl;
          }
	}

      //
      // Declare the user defined variables that appear in the equations.
      // These are all double-precision floating point numbers.
      //
      pRawTable = rawTable->begin();
      for( ; pRawTable != rawTable->end(); pRawTable++ )
	{
	    if( find( labels->begin(), labels->end(), pRawTable->second.name ) == labels->end() )
	    {
	      oIndData_h << "std::valarray<T> " << pRawTable->second.name << ";" << endl;
	      oIndData_h << "std::valarray<T> " << pRawTable->second.name << "_tmp;" << endl;
	    }
	}

      oIndData_h << endl;
      oIndData_h << "~IndData();" << endl;

      // 
      // Protected member declarations.
      //
      oIndData_h << "protected:" << endl;
      oIndData_h << "IndData();" << endl;
      oIndData_h << "IndData( const IndData& );" << endl;
      oIndData_h << "IndData& operator=( const IndData& );" << endl;
      oIndData_h << endl;

      //
      // Private member declarations.
      //
      oIndData_h << "private:" << endl;
      oIndData_h << "const int n; // #of measurements." << endl;

      oIndData_h << "};" << endl;


      //-----------------------------------------------
      // Definition
      //-----------------------------------------------
      //
      // Definition of the constructor that takes a list of
      // valarray objects as arguments.
      // The order must be consistant with the declaration.
      //
      oIndData_h << "template <class T>" << endl;
      oIndData_h << "IndData<T>::IndData( int nIn";
      pLabel = labels->begin();
      for( ; pLabel != labels->end(); pLabel++ )
	{
          bool isID = ( *pLabel == pID->name );
	  oIndData_h << "," << endl;

	  //
	  // If the label string is of "ID", then the data type is char*.
	  // Othewise, double.
	  //
	  oIndData_h << "const std::valarray<" << (isID? "char*":"T") << "> ";
          oIndData_h << "& " << *pLabel << "In";
	}
      oIndData_h << ")" << endl;
      oIndData_h << ": n( nIn )";


      //
      // The constructor initialization.
      // Assign the argument values to the internal valarray variables.
      // Also assign the same values to equivalent (synonym) variables
      // if the variable has a synonym defined.
      //
      pLabel = labels->begin();
      for( ; pLabel != labels->end(); pLabel++ )
	{
	  oIndData_h << "," << endl;
	  oIndData_h << *pLabel << "( " << *pLabel << "In" << " )";

	  //
	  // If the label has a synonym, apply the same value to the synonym.
	  //
	  if( ( synonym = table.findi( *pLabel )->synonym ) != "" )
	    {
	      oIndData_h << "," << endl;
	      oIndData_h << synonym << "( " << *pLabel << "In" << " )";
	    }
	}

      //
      // The constructor body.
      // Initialize the sizes of the user defined variables that
      // appear in the model definition.
      // We don't know the values yet, so just assign the size,
      // which is the same as the number of data records for a subject.
      //
      // These arrays will be internally (ie. PRED routine) used to store 
      // intermediate values.  The intermediate values are
      // returned to the user for tabular display or plot display.
      // They need corresponding shadow placeholders so that
      // if an iteration fails, the system can return the previously
      // successfully computed values.
      //
      pRawTable = rawTable->begin();
      for( ; pRawTable != rawTable->end(); pRawTable++ )
	{
	    if( find( labels->begin(), labels->end(), pRawTable->second.name ) == labels->end() )
	    {
	      oIndData_h << "," << endl;

	      //
	      // The place holders for completely (throughout an iteration)
	      // computed values.
	      //
 	      oIndData_h << pRawTable->second.name << "( nIn )";
              oIndData_h << "," << endl;

	      //
	      // The place holders for currently (ie. in-process-iteration)
	      // computed values.
	      //
	      oIndData_h << pRawTable->second.name << "_tmp( nIn )";
	    }
	}

      oIndData_h << endl;
      oIndData_h << "{" << endl;
      oIndData_h << "}" << endl;

      oIndData_h << endl;
      oIndData_h << "template <class T>" << endl;
      oIndData_h << "IndData<T>::~IndData(){}" << endl;

      oIndData_h << "template <class T>" << endl;
      oIndData_h << "IndData<T>::IndData(){}" << endl;

      oIndData_h << "template <class T>" << endl;
      oIndData_h << "IndData<T>::IndData( const IndData<T>& ){}" << endl;

      oIndData_h << "template <class T>" << endl;
      oIndData_h << "IndData<T>& IndData<T>::operator=( const IndData<T>& ){}" << endl;

      oIndData_h << "#endif" << endl;
    }
    else
    {
      assert( false );
    }
  oIndData_h.close();
}
void NonmemTranslator::generateDataSet( ) const
{
  const map<const string, Symbol> * t = table.getTable();
  const vector<string> *labels = table.getLabels();
  vector<string>::const_iterator pLabel;
  int nLabels = labels->size();
  const Symbol * pID = table.findi( "id" );

  //
  // Declare and define DataSet template class.
  // For name binding reason, the declaration and the definition
  // are both stored in a single file: DataSet.h
  // 
  // The only legal constructor is the default constructor.
  // The constructor initializes the array of IndData objects,
  // each contains the entire data set for a subject.
  //
  // The order in which the arguments to the IndData 
  // constructor appear is critical.  The order must
  // match with the IndData constructor's interface.
  // It relizes on the order of strings stored in the list 
  // returned by "SymbolTable::getLabels()".
  // Thus, in between the time when the DataSet constructor
  // is defined and the time when the IndData constructor
  // is declared/defined, the SymbolTable object
  // may NOT be modified.
  //  const Symbol* pID = table.findi("id");
  //
  ofstream oDataSet_h( fDataSet_h );
  if( oDataSet_h.good() )
    {
      oDataSet_h << BURNER << " <" << __FILE__ << ">" << endl;

      oDataSet_h << "#ifndef DATASET_H" << endl;
      oDataSet_h << "#define DATASET_H" << endl;

      oDataSet_h << "#include <vector>" << endl;
      oDataSet_h << "#include \"IndData.h\"" << endl;
      oDataSet_h << endl;

      //-----------------------------------------------
      // Declaration
      //-----------------------------------------------
      oDataSet_h << "template <class T>" << endl;
      oDataSet_h << "class DataSet" << endl;
      oDataSet_h << "{" << endl;
      

      oDataSet_h << "public:" << endl;
      oDataSet_h << "DataSet();" << endl;
      oDataSet_h << "~DataSet();" << endl;
      oDataSet_h << endl;

      oDataSet_h << "std::vector<IndData<T>*> data;" << endl;
      oDataSet_h << endl;

      oDataSet_h << "protected:" << endl;
      oDataSet_h << "DataSet( const DataSet& );" << endl;
      oDataSet_h << "DataSet& operator=( const DataSet& );" << endl;
      oDataSet_h << endl;

      oDataSet_h << "};" << endl;


      //-----------------------------------------------
      // Defintion
      //-----------------------------------------------
      oDataSet_h << "template <class T>" << endl;
      oDataSet_h << "DataSet<T>::DataSet()" << endl;
      oDataSet_h << ": data(" << myPopSize << ")" << endl;
      oDataSet_h << "{" << endl;

      for( int who=0; who < myPopSize; who++ )
	{
          char c_who[256];
          sprintf( c_who, "%d", who );
          int nRecords = pID->initial[who].size();
          const string id = pID->initial[who][0];

          //
          // The order in which the labels appear must be consistent
          // with the order in the constructor declaration.
          // By using the iterator in both places, here and up there,
          // they shall match.  However, this should be tested in
          // the corresponding unit tests.
          //
          oDataSet_h << "//------------------------------------" << endl;
          oDataSet_h << "// Subject <" << id << "> " << endl;
	  oDataSet_h << "// # of sampling points = " << nRecords << endl;
          oDataSet_h << "//------------------------------------" << endl;
	  
	  //
	  // Initialize C arrays with data values.
	  // The C arrays are passed to the valarray's constructor.
	  //
	  pLabel = labels->begin();
	  for( int i=0; pLabel != labels->end(), i<nLabels; i++, pLabel++ )
	    {
	      const Symbol * s = table.findi( *pLabel );
              bool isID = (*pLabel == pID->name);
              string carray_name   = s->name + "_" + c_who + "_c";
              string valarray_name = s->name + "_" + c_who;

              oDataSet_h << (isID? "char*":"T") << " " << carray_name << "[] = { ";
	      for( int j=0; j<nRecords; j++ )
		{
		  if( j > 0 )
		    oDataSet_h << ", ";
                  if( *pLabel == pID->name )
                     oDataSet_h << "\"" << s->initial[who][j] << "\"";
                  else
		     oDataSet_h << s->initial[who][j];
		}
	      oDataSet_h << " };" << endl;
	      oDataSet_h << "std::valarray<" << (isID? "char*":"T") << "> ";
              oDataSet_h << valarray_name << "(" << carray_name << ", " << nRecords << ");" << endl;
	    }

	  //
	  // Create an IndData object.  The order in which the arguments
	  // are passed to the IndData constructor must be strictly
	  // compliant to the order in which the label strings are stored
	  // in the list returned by SymbolTable::getLabels().
	  //
	  oDataSet_h << "data[" << who << "] = new IndData<T>";
          oDataSet_h << "( " << nRecords << ", ";
	  pLabel = labels->begin();
	  for( int i=0; pLabel != labels->end(), i<nLabels; i++, pLabel++ )
	    {
	      if( i>0 )
		oDataSet_h << ", ";
	      const Symbol * s = table.findi( *pLabel );
              string valarray_name = s->name + "_" + c_who;
              oDataSet_h << valarray_name;
	    }
	  
	  oDataSet_h << " );" << endl;
          oDataSet_h << endl;
	}

      oDataSet_h << "}" << endl;

      oDataSet_h << "template <class T>" << endl;
      oDataSet_h << "DataSet<T>::~DataSet()" << endl;
      oDataSet_h << "{" << endl;
      oDataSet_h << "   const int n = data.size();" << endl;
      oDataSet_h << "   for( int i=0; i<n; i++ )" << endl;
      oDataSet_h << "   {" << endl;
      oDataSet_h << "      delete data[i];" << endl;
      oDataSet_h << "   }" << endl;
      oDataSet_h << "}" << endl;

      oDataSet_h << "template <class T>" << endl;
      oDataSet_h << "DataSet<T>::DataSet( const DataSet<T>& ){}" << endl;

      oDataSet_h << "template <class T>" << endl;
      oDataSet_h << "DataSet<T>& DataSet<T>::operator=( const DataSet<T>& ){}" << endl;

      oDataSet_h << "#endif" << endl;
    }
  else
    {
      assert( false );
    }
  oDataSet_h.close();
}
void NonmemTranslator::generatePred( const char* fPredEqn_cpp ) const
{
  const vector<string> * labels = table.getLabels();
  const int nLabels = labels->size();
  vector<string>::const_iterator pLabel;

  const map<const string, Symbol> * rawTable = table.getTable();
  map<const string, Symbol>::const_iterator pRawTable;

  const string sTHETA = ( table.findi("theta")->name );
  const string sETA   = ( table.findi("eta")->name );
  const string sEPS   = ( table.findi("eps")->name );

  //
  // Declare and define Pred template class.
  // For name binding reason, the declaration and the definition
  // are both stored in a single file: Pred.h
  // 
  ofstream oPred_h( fPred_h );
  if( oPred_h.good() )
    {
      // headers
      oPred_h << BURNER << endl;
      oPred_h << "#ifndef PRED_H" << endl;
      oPred_h << "#define PRED_H" << endl;
      oPred_h << endl;

      oPred_h << "#include <string>" << endl;
 
      //----------------------------------------------
      // Declaration
      //----------------------------------------------
      oPred_h << "template <class T>" << endl;
      oPred_h << "class Pred" << endl;
      oPred_h << "{" << endl;
      
      oPred_h << "public:" << endl;
      oPred_h << "Pred( const DataSet<T>* dataIn );" << endl;
      oPred_h << "~Pred();" << endl;
      oPred_h << "bool eval( T theta[], " << endl;
      oPred_h << "           int nTheta, " << endl;
      oPred_h << "           T eta[], " << endl;
      oPred_h << "           int nEta, " << endl;
      oPred_h << "           T eps[], " << endl;
      oPred_h << "           int nEps," << endl;
      oPred_h << "           int spk_i, " << endl;
      oPred_h << "           int spk_j, " << endl;
      oPred_h << "           T & f, " << endl;
      oPred_h << "           T & y );" << endl;
      oPred_h << endl;

      oPred_h << "protected:" << endl;
      oPred_h << "Pred();" << endl;
      oPred_h << "Pred( const Pred& );" << endl;
      oPred_h << "Pred & operator=( const Pred& );" << endl;

      oPred_h << "private:" << endl;
      oPred_h << "const DataSet<T> *data;" << endl;
      oPred_h << "mutable int prev_i;" << endl;
      oPred_h << "mutable int prev_j;" << endl;

      // The data items
      const Symbol * pID = table.findi( "id" );
      pLabel = labels->begin();
      for( int i=0; i<nLabels, pLabel != labels->end(); i++, pLabel++ )
	{
          bool isID = (*pLabel == pID->name);

	  const Symbol* s = table.findi( *pLabel );
	  oPred_h << "mutable " << ( isID? "std::string" : "T" );
          oPred_h << " " << SymbolTable::key( s->name ) << ";" << endl;
          if( !s->synonym.empty() )
	    {
	      oPred_h << "mutable " << ( isID? "std::string" : "T" );
	      oPred_h << " " << SymbolTable::key( s->synonym ) << ";" << endl;
	    }
	}
      // The user defined scalar variables
      for( pRawTable = rawTable->begin(); pRawTable != rawTable->end(); pRawTable++ )
	{
	  if( pRawTable->second.name != sTHETA && pRawTable->second.name != sETA 
		  && pRawTable->second.name != sEPS )
	    {
	      if( find( labels->begin(), labels->end(), pRawTable->second.name ) == labels->end() )
		{
		  oPred_h << "mutable T " << SymbolTable::key( pRawTable->second.name ) << ";" << endl;
		}
	    }
	}

      // footer
      oPred_h << "};" << endl;

      //----------------------------------------------
      // Definition
      //----------------------------------------------
      oPred_h << "template <class T>" << endl;
      oPred_h << "Pred<T>::Pred( const DataSet<T>* dataIn )" << endl;
      oPred_h << ": data(dataIn)" << endl;
      oPred_h << "{" << endl;
      oPred_h << "}" << endl;

      oPred_h << "template <class T>" << endl;
      oPred_h << "Pred<T>::~Pred()" << endl;
      oPred_h << "{" << endl;
      oPred_h << "}" << endl;

      oPred_h << "template <class T>" << endl;
      oPred_h << "bool Pred<T>::eval( T theta[], " << endl;
      oPred_h << "           int nTheta, " << endl;
      oPred_h << "           T eta[], " << endl;
      oPred_h << "           int nEta, " << endl;
      oPred_h << "           T eps[], " << endl;
      oPred_h << "           int nEps," << endl;
      oPred_h << "           int spk_i, " << endl;
      oPred_h << "           int spk_j, " << endl;
      oPred_h << "           T & f, " << endl;
      oPred_h << "           T & y )" << endl;
      oPred_h << "{" << endl;

      // Assign the current values (i,j) of data to appropriate scalar variables
      for( pLabel = labels->begin(); pLabel != labels->end(); pLabel++ )
      {
         const Symbol *s = table.findi( *pLabel );
         // label
         oPred_h << SymbolTable::key( s->name ) << " = data->data[spk_i]->" << s->name << "[spk_j];" << endl;
         // synonym
         if( !s->synonym.empty() )
         {
            oPred_h << SymbolTable::key( s->synonym ) << " = data->data[spk_i]->" << s->synonym << "[spk_j];" << endl;
         }
      }
      
      oPred_h << "//=========================================" << endl;
      oPred_h << "// Begin User Code                         " << endl;
      oPred_h << "//-----------------------------------------" << endl;
      char ch;
      ifstream iPredEqn( fPredEqn_cpp );
      assert( iPredEqn.good() );
      while( iPredEqn.get(ch) )
	oPred_h.put(ch);
      iPredEqn.close();
      oPred_h << "//-----------------------------------------" << endl;
      oPred_h << "// End User Code                           " << endl;
      oPred_h << "//=========================================" << endl;
      
      oPred_h << "}" << endl;

      oPred_h << "template <class T>" << endl;
      oPred_h << "Pred<T>::Pred()" << endl;
      oPred_h << "{" << endl;
      oPred_h << "}" << endl;

      oPred_h << "template <class T>" << endl;
      oPred_h << "Pred<T>::Pred( const Pred<T>& )" << endl;
      oPred_h << "{" << endl;
      oPred_h << "}" << endl;

      oPred_h << "template <class T>" << endl;
      oPred_h << "Pred<T> & Pred<T>::operator=( const Pred<T>& )" << endl;
      oPred_h << "{" << endl;
      oPred_h << "}" << endl;

      oPred_h << "#endif" << endl;
    }
  else
    {
      assert( false );
    }
  oPred_h.close();
}

void NonmemTranslator::generateIndDriver( ) const
{
  //==================================================================
  // Generate the driver
  //==================================================================
  ofstream oDriver ( fDriver_cpp );
  assert( oDriver.good() );
  
  oDriver << "#include <iostream>" << endl;
  oDriver << "#include <fstream>" << endl;
  oDriver << "#include <sys/time.h>" << endl;
  oDriver << "#include \"IndData.h\"" << endl;
  oDriver << "#include \"DataSet.h\"" << endl;
  oDriver << "#include \"Pred.h\"" << endl;
  oDriver << "#include \"Omega.h\"" << endl;
  oDriver << endl;

  oDriver << "#include <spk/SpkValarray.h>" << endl;
  oDriver << "#include <spk/SpkException.h>" << endl;
  oDriver << "#include <spk/NonmemdModels.h>" << endl;
  if( myIsEstimate )
  {
     oDriver << "#include <spk/fitIndividual.h>" << endl;
     oDriver << "#include <spk/Optimizer.h>" << endl;
  }
  if( myIsEstimate && myIsStat )
     oDriver << "#include <spk/indStatistics.h>" << endl;
  if( myIsSimulate )
     oDriver << "#include <spk/simulation.h>" << endl;
  oDriver << endl;

  oDriver << "using SPK_VA;" << endl;
  oDriver << "int main( int argc, const char argv[] )" << endl;
  oDriver << "{" << endl;

  oDriver << "DataSet<double> set;" << endl;
  oDriver << "Pred<double> mPred(&set);" << endl;
  oDriver << "Omega mOmega;" << endl;
  oDriver << "NonmemPredBasedModel model( set, mPred, mOmega... );" << endl;

  oDriver << "const int nB = " << myThetaLen << ";" << endl;
  oDriver << "const int nY = " << myRecordNums.sum() << ";" << endl;
  if( myIsSimulate )
    oDriver << "const unsigned int seed = " << mySeed << ";" << endl;
  oDriver << endl;

  const Symbol* pTheta = table.findi("theta");
  oDriver << "double c_bIn[nB] = { ";
  for( int j=0; j<myThetaLen; j++ )
    {
      if( j>0 )
	oDriver << ", ";
      oDriver << atof( pTheta->initial[0][j].c_str() );
    }
  oDriver << " };" << endl;
  if( myIsSimulate )
    {
      oDriver << "valarray<double> bIn ( nB );" << endl;
    }
  else
    {
      oDriver << "const valarray<double> bIn ( nB, c_bIn );" << endl;
    }
  oDriver << endl;
  
  oDriver << "double c_bUp[nB] = { ";
  for( int j=0; j<myThetaLen; j++ )
  {
     if( j>0 )
        oDriver << ", ";
     oDriver << atof( pTheta->upper[0][j].c_str() );
  }
  oDriver << " };" << endl;
  oDriver << "const valarray<double> bUp  ( c_bUp, nB );" << endl;
  oDriver << endl;

  oDriver << "double c_bLow[nB] = { ";
  for( int j=0; j<myThetaLen; j++ )
  {
     if( j>0 )
	oDriver << ", ";
     oDriver << atof( pTheta->lower[0][j].c_str() );
  }
  oDriver << " };" << endl;
  oDriver << "const valarray<double> bLow ( c_bLow, nB );" << endl;
  oDriver << endl;

  if( myIsEstimate )
    {
      oDriver << "double c_bStep[nB] = { ";
      for( int j=0; j<myThetaLen; j++ )
	{
	  if( j>0 )
	    oDriver << ", ";
	  oDriver << atof( pTheta->step[0][j].c_str() );
	}
      oDriver << " };" << endl;
      oDriver << "const valarray<double> bStep( c_bStep, nB );" << endl;
    }
  oDriver << endl;

  oDriver << "valarray<double> bOut( nB );" << endl;

  // do data simulation first to replace DV data in IndData objects
  if( myIsSimulate )
    {
       oDriver << "valarray<double> y   ( nY );" << endl;
       oDriver << "valarray<double> yOut( nY );" << endl;
       oDriver << "try" << endl;
       oDriver << "{" << endl;
       oDriver << "   simulate( model, seed, nY, bLow, bUp, yOut, bOut );" << endl;
       if( myIsEstimate )
	 {
	   oDriver << "   bIn = bOut;" << endl;
	   oDriver << "   y   = yOut;" << endl;
	 }
       oDriver << "}" << endl;
       oDriver << "catch( const SpkException& e )" << endl;
       oDriver << "{" << endl;
       oDriver << "   cerr << e << endl;" << endl;
       oDriver << "   return 1;" << endl;
       oDriver << "}" << endl;
       oDriver << "catch( ... )" << endl;
       oDriver << "{" << endl;
       oDriver << "   cerr << \"Unknown exception: failed in data simulation!!!\" << endl;" << endl;
       oDriver << "   return 1;" << endl;
       oDriver << "}" << endl;
    }
  else
    {
      const Symbol* pDV = table.findi("dv");
      if( pDV == Symbol::empty() )
	{
	  // "DV" may be registered as a synonym.  
	  // In that case, have to search through the entries
	  // in the map.
	  const map<const string,Symbol> *t = table.getTable();
          map<const string,Symbol>::const_iterator itr = t->begin();
          for( ; itr != t->end(); itr++ )
	    {
	      if( lower( itr->second.synonym ) == "dv" )
		{
		  pDV = &itr->second;
		  break;
		}
	    }
	}
      assert( pDV != Symbol::empty() );
      oDriver << "double c_y[nY] = { ";
	  for( int j=0; j<myRecordNums[0]; j++ )
	    {
	      if( j > 0 )
		oDriver << ", ";
	      oDriver << atof( pDV->initial[0][j].c_str() );
	    }
      oDriver << " };" << endl;
      oDriver << "valarray<double> y( nY, c_y );" << endl; 
      oDriver << endl;
    }
  if( myIsEstimate )
    {
       oDriver << "double           bObjOut;" << endl;
       oDriver << "valarray<double> bObj_bOut( nB );" << endl;
       oDriver << "valarray<double> bObj_b_bOut( nB * nB );" << endl;
       oDriver << endl;
       oDriver << "const double eps   = " << myIndEpsilon    << ";" << endl;
       oDriver << "const int    mitr  = " << myIndMitr       << ";" << endl;
       oDriver << "const int    trace = " << myIndTraceLevel << ";" << endl;
       oDriver << "Optimizer    opt( eps, mitr, trace );" << endl;
       oDriver << endl;
       oDriver << "timeval optBegin, optEnd;" << endl;
       oDriver << "gettimeofday( &optBegin, NULL );" << endl;
       oDriver << "try" << endl;
       oDriver << "{" << endl;
       oDriver << "   fitIndividual( model," << endl;
       oDriver << "                  y," << endl;
       oDriver << "                  opt," << endl;
       oDriver << "                  bLow," << endl;
       oDriver << "                  bUp," << endl;
       oDriver << "                  bIn," << endl;
       oDriver << "                  bStep," << endl;
       oDriver << "                 &bOut," << endl;
       oDriver << "                 &bObjOut," << endl;
       oDriver << "                 &bObj_bOut," << endl;
       oDriver << "                 &bObj_b_bOut," << endl;
       oDriver << "                  true);" << endl;
       oDriver << "}" << endl;
       oDriver << "catch( const SpkException& e )" << endl;
       oDriver << "{" << endl;
       oDriver << "   cerr << e << endl;" << endl;
       oDriver << "   return 1;" << endl;
       oDriver << "}" << endl;
       oDriver << "catch( ... )" << endl;
       oDriver << "{" << endl;
       oDriver << "   cerr << \"Unknown exception: failed in parameter estimation!!!\" << endl;" << endl;
       oDriver << "   return 1;" << endl;
       oDriver << "}" << endl;
       oDriver << "gettimeofday( &optEnd, NULL );" << endl;
       oDriver << "double optTimeSec = difftime( optEnd.tv_sec, optBegin.tv_sec );" << endl;

       // Statistics can be only computed when the parameter estimation has been done.
       if( myIsStat )
       {
  	  oDriver << "timeval statBegin, statEnd;" << endl;
          if( myIsCov )
	    oDriver << "valarray<double> covOut( nB * nB );" << endl;
	  if( myIsStderr )
	    oDriver << "valarray<double> seOut( nB );" << endl;
	  if( myIsCorrelation )
	    oDriver << "valarray<double> correlationOut( nB * nB );" << endl;
	  if( myIsCoefficient )
	    oDriver << "valarray<double> coefficientOut( nB );" << endl;
	  if( myIsConfidence )
	    oDriver << "valarray<double> confidenceOut( 2 * nB );" << endl;
	  if( myIsInvCov )
	    oDriver << "valarray<double> invCov( nB * nB );" << endl;

          // indStatistics
	  oDriver << "gettimeofday( &statBegin, NULL );" << endl;
          oDriver << "try" << endl;
          oDriver << "{" << endl;
          oDriver << "   indStatistics( model, " << endl;
	  oDriver << "                  bOut, " << endl;
          oDriver << "                  " << (myIsCov?         "covOut"        :"NULL") << ", " << endl;
          oDriver << "                  " << (myIsStderr?      "seOut"         :"NULL") << ", " << endl;
          oDriver << "                  " << (myIsCorrelation? "correlationOut":"NULL") << ", " << endl;
          oDriver << "                  " << (myIsCoefficient? "coeficientOut" :"NULL") << ", " << endl;
          oDriver << "                  " << (myIsConfidence?  "confidenceOut" :"NULL") << " );" << endl;
          oDriver << "}" << endl;
          oDriver << "catch( const SpkException& e )" << endl;
          oDriver << "{" << endl;
          oDriver << "   cerr << e << endl;" << endl;
          oDriver << "   return 1;" << endl;
          oDriver << "}" << endl;
          oDriver << "catch( ... )" << endl;
          oDriver << "{" << endl;
          oDriver << "   cerr << \"Unknown exception: failed in statistics calculation!!!\" << endl;" << endl;
          oDriver << "   return 1;" << endl;
          oDriver << "}" << endl;

	  if( myIsInvCov )
	    {
	      oDriver << "try" << endl;
	      oDriver << "{" << endl;
	      oDriver << "   invCovOut = inverse( covOut, nB );" << endl;
	      oDriver << "}" << endl;
	      oDriver << "catch( const SpkException& e )" << endl;
	      oDriver << "{" << endl;
	      oDriver << "   cerr << e << endl;" << endl;
	      oDriver << "   return 1;" << endl;
	      oDriver << "}" << endl;
	      oDriver << "catch( ... )" << endl;
	      oDriver << "{" << endl;
	      oDriver << "   cerr << \"Unknown exception: failed to invert the covariance of the final estimate of individual parameter!!!\" << endl;" << endl;
	      oDriver << "   return 1;" << endl;
	      oDriver << "}" << endl;
	    }
	  oDriver << "gettimeofday( &statEnd, NULL );" << endl;
	  oDriver << "double statTimeSec = difftime( statEnd.tv_sec, statBegin.tv_sec );" << endl;
       }
    }


  //
  // Results assembly
  //
  oDriver << "ofstream oResults( \"result.xml\" );" << endl;
  oDriver << "if( !oResults.good() )" << endl;
  oDriver << "{" << endl;
  oDriver << "   cerr << \"Failed to open a file, result.xml!!!\" << endl;" << endl;
  oDriver << "   return 1;" << endl;
  oDriver << "}" << endl;

  oDriver << "oResults << \"<spkreportML>\" << endl;" << endl;

  oDriver << "oResults << \"<ind_analysis_result>\" << endl;" << endl;

  if( myIsEstimate )
    {
      oDriver << "oResults << \"<ind_opt_result elapsedtime=\\\"\" << optTimeSec << \"\\\">\" << endl;" << endl;
      oDriver << "oResults << \"<ind_obj_out>\" << endl;" << endl;
      oDriver << "oResults << \"<value>\" << bObjOut << \"</value>\" << endl;" << endl;
      oDriver << "oResults << \"</ind_obj_out>\" << endl;" << endl;
      oDriver << "oResults << \"<theta_out>\" << endl;" << endl;
      // theta (b)
      oDriver << "for( int i=0; i<nB; i++ )" << endl;
      oDriver << "{" << endl;
      oDriver << "   oResults << \"<value>\" << bOut[i] << \"</value>\" << endl;" << endl;
      oDriver << "}" << endl;
      oDriver << "oResults << \"</theta_out>\" << endl;" << endl;
      oDriver << "oResults << \"<omega_out>\" << endl;" << endl;
      // omega 
      oDriver << "oResults << \"</omega_out>\" << endl;" << endl;
      oDriver << "oResults << \"</ind_opt_result>\" << endl;" << endl;
      if( myIsStat )
	{
	  oDriver << "oResults << \"<ind_stat_result elapsedtime=\\\"\" << statTimeSec << \"\\\">\" << endl;" << endl;
	  oDriver << "int covElemNum = " << series( 1, 1, myThetaLen ) << ";" << endl;
	  if( myIsCov )
	    {
	      oDriver << "oResults << \"<ind_covariance_out struct=\\\"block\\\" dimension=\\\"\" << nB << \"\\\">\" << endl;" << endl;
	      oDriver << "for( int i=0; i<covElemNum; i++ )" << endl;
	      oDriver << "{" << endl;
	         oDriver << "oResults << \"   <value>\" << covOut[i] << \"</value>\" << endl;" << endl;
	      oDriver << "}" << endl;

	      oDriver << "oResults << \"</ind_covariance_out>\" << endl;" << endl;
	    }
	  if( myIsInvCov )
	    {
	      oDriver << "oResults << \"<ind_inverse_covariance_out struct=\\\"block\\\" dimension=\\\"\" << nB << \"\\\">\" << endl;" << endl;
	      oDriver << "for( int i=0; i<covElemNum; i++ )" << endl;
	      oDriver << "{" << endl;
	         oDriver << "oResults << \"   <value>\" << invCovOut[i] << \"</value>\" << endl;" << endl;
	      oDriver << "}" << endl;

	      oDriver << "oResults << \"</ind_inverse_covariance_out>\" << endl;" << endl;
	    }
	  if( myIsStderr )
	    {
	      oDriver << "oResults << \"<ind_stderror_out length=\\\"\" << nB << \"\\\">\" << endl;" << endl;
	      oDriver << "for( int i=0; i<nB; i++ )" << endl;
	      oDriver << "{" << endl;
	         oDriver << "oResults << \"   <value>\" << seOut[i] << \"</value>\" << endl;" << endl;
	      oDriver << "}" << endl;

	      oDriver << "oResults << \"</ind_stderror_out>\" << endl;" << endl;
	    }
	  if( myIsCorrelation )
	    {
	      oDriver << "oResults << \"<ind_correlation_out struct=\\\"block\\\" dimension=\\\"\" << nB << \"\\\">\" << endl;" << endl;
	      oDriver << "for( int i=0; i<covElemNum; i++ )" << endl;
	      oDriver << "{" << endl;
	         oDriver << "oResults << \"   <value>\" << correlationOut[i] << \"</value>\" << endl;" << endl;
	      oDriver << "}" << endl;

	      oDriver << "oResults << \"</ind_correlation_out>\" << endl;" << endl;
	    }
	  if( myIsCoefficient )
	    {
	      oDriver << "oResults << \"<ind_coefficient_out length=\\\"\" << nB << \"\\\">\" << endl;" << endl;
	      oDriver << "for( int i=0; i<nB; i++ )" << endl;
	      oDriver << "{" << endl;
	         oDriver << "oResults << \"   <value>\" << coefficientOut[i] << \"</value>\" << endl;" << endl;
	      oDriver << "}" << endl;

	      oDriver << "oResults << \"</ind_coefficient_out>\" << endl;" << endl;
	    }
	  if( myIsConfidence )
	    {
	      oDriver << "oResults << \"<ind_confidence_out length=\\\"\" << nB*2 << \"\\\">\" << endl;" << endl;
	      oDriver << "for( int i=0; i<nB*2; i++ )" << endl;
	      oDriver << "{" << endl;
	         oDriver << "oResults << \"   <value>\" << confidenceOut[i] << \"</value>\" << endl;" << endl;
	      oDriver << "}" << endl;

	      oDriver << "oResults << \"</ind_confidence_out>\" << endl;" << endl;
	    }
	  oDriver << "oResults << \"</ind_stat_result>\" << endl;" << endl;
	}
    }

  oDriver << "oResults << \"</ind_analysis_result>\" << endl;" << endl;

  //=============================================================================
  // LABELS
  //
  const map<const string, Symbol> * t = table.getTable();
  const Symbol * pID = table.findi("id");
  assert( pID != Symbol::empty() );

  map<const string, Symbol>::const_iterator pEntry = t->begin();
  vector<string>::const_iterator pLabelBegin = table.getLabels()->begin();
  vector<string>::const_iterator pLabelEnd   = table.getLabels()->end();
  vector<string> whatGoesIn;  // will hold those labels in the order that actually go into the data section.

  oDriver << "oResults << \"<presentation_data>\" << endl;" << endl;
  oDriver << "oResults << \"<data_labels>\" << endl;" << endl;

  // ID must come first no matter what
  whatGoesIn.push_back( pID->name );
  oDriver << "oResults << \"<label name=\\\"" << pID->name << "\\\"/>\" << endl;" << endl;

  // ...aaand, following ID is, all the left hand side quantities in the model definition.
  for( ; pEntry!=t->end(); pEntry++ )
    {
      if( pEntry->first != "id" || ( find( pLabelBegin, pLabelEnd, pEntry->second.name )==pLabelEnd ) )
	{
	  whatGoesIn.push_back( pEntry->second.name );
	  oDriver << "oResults << \"<label name=\\\"" << pEntry->second.name << "\\\"/>\" << endl;" << endl;
	}
    }
  oDriver << "oResults << \"</data_labels>\" << endl;" << endl;
  oDriver << "oResults << \"</presentation_data>\" << endl;" << endl;
  //
  //=============================================================================
  vector<string>::const_iterator pWhatGoesIn;
  oDriver << "int n = " << myPopSize << ";" << endl;
  oDriver << "for( int j=0, cnt=0; j<n; j++ )" << endl;
  oDriver << "{" << endl;
  oDriver << "   for( int i=0; i<nY; i++, cnt++ )" << endl;
  oDriver << "   {" << endl;
  oDriver << "      oResults << \"<row>\" << endl;" << endl;
  for( pWhatGoesIn = whatGoesIn.begin(); pWhatGoesIn!=whatGoesIn.end(); pWhatGoesIn++ )
    {
      oDriver << "      oResults << \"<value>\" << "; 
      if( *pWhatGoesIn == "SIMDV" )
	{
	  oDriver << "yOut[cnt]";
	}
      else
	{
	  oDriver << "set.data[j]->" << *pWhatGoesIn << "[i]";
	}
      oDriver << " << \"</value>\" << endl;" << endl;
    }
  oDriver << "      oResults << \"</row>\" << endl;" << endl;
  oDriver << "   }" << endl;
  oDriver << "}" << endl;

  oDriver << "oResults << \"</spkreportML>\" << endl;" << endl;

  oDriver << "oResults.close();" << endl;

  oDriver << "return 0;" << endl;
  oDriver << "}" << endl;
  oDriver.close();
}
void NonmemTranslator::generatePopDriver() const
{
}
