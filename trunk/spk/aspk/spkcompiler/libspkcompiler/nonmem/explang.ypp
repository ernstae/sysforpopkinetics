/**
 * @file explang.y
 * @brief This is a syntax analyzer specification file (BISON) for NMTRAN->C++.
*/
%{
//
// int yyparse( void )
//
//  Tree-generator for NONMEM abbriviated code
//
// The source language allows only the following statements:
// * assignment
// * if conditional statement in the form of either if-assign or if-then-else
//
// The functions and operators it supports are:
// * sqrt, log, log10, exp
// * + (addition), - (subtraction), * (multiplication), / (division), ** (power)
//
// The primitive data types it supports are:
// * real (eq. float)
// * double real (eq. double)
// * integer (eq. int) for indexing arrays
// * logical (eq. bool)
//
// The types of data containers allowed are:
// * scalar
// * one dimensional array
// * two dimensional array
//
// The methods to access array elements of a dimensional space are:
// * by constant scalar indexing
// * by providing constant start and end indeces
// * by providing constant start and end indeces and a stride
// (thus, for a vector, you have a(start:end:stride) and for a matrix, A(start:end:stride, start:end:stride).
//
//
#include <iostream>
#include <fstream>
#include <string>
#include "SymbolTable.h"

using namespace std;

/**
 * Global counter for errors that encountered during parsing.
 */
int gSpkExpErrors = 0;

/**
 * Global counter for lines that have been read so far during parsing.
 */
int gSpkExpLines  = 0;

/**
 * Global pointer to a SymbolTable object.
 *
 * This pointer has to be initialized to point to a valid object
 * in the caller (of yyparse()) space.  The allocated resource
 * must be released by the caller too.
 *
 * @note If the pointer is found to be pointing to NULL at
 * the very beginning of parsing, yyparse() will call
 * yyerror() and probably terminate the program execution completely.
 */
SymbolTable * gSpkExpSymbolTable;

extern "C"{
  int yyparse(void);
  int yylex(void);  
  int yywrap()
  {
    return 1;
  }
  int yyerror( char * s )
  { 
    ++gSpkExpErrors;
    cerr <<  "!!! Error (" << gSpkExpErrors << ") at line " << gSpkExpLines << ": " << endl;
    cerr << "\t" << s << endl;
    
    return -1;
  int YYACCEPT;
  int YYABORT;
  }

/**
 * Global pointer to a FILE handler to which output is redirected.
 */
FILE * gSpkExpOutput;
};

  static const char * const STR_TYPE     = "type";
  static const char * const STR_VALUE    = "value";
  static const char * const STR_NAME     = "name";
  static const char * const STR_OPERATOR = "operator";
  static const char * const STR_OPERAND  = "operand";
  static const char * const STR_SIGN     = "sign";
  static const char * const STR_ROWS     = "rows";
  static const char * const STR_COLS     = "cols";
  static const char * const STR_LHS      = "lhs";
  static const char * const STR_RHS      = "rhs";
  static const char * const STR_BINARY   = "binary";
  static const char * const STR_UNARY    = "unary";
  static const char * const STR_FUNCTION = "function";
  static const char * const STR_ARGC     = "argc";
  static const char * const STR_STRUCTURE= "structure";
  static const char * const STR_INDEX    = "index";
  static const char * const STR_START    = "start";
  static const char * const STR_END      = "end";
  static const char * const STR_STRIDE   = "stride";
  static const char * const STR_CONSTANT = "constant";
  static const char * const STR_TRUE     = "true";
  static const char * const STR_FALSE    = "false";
  static const char * const STR_COMMENT  = "comment";
  static const char * const STR_EXIT     = "exit";

  static const char * const STR_ASSIGN   = "assign";
  static const char * const STR_ARRAY_ELEMENT_LIST = "array_element_list";
  static const char * const STR_VARIABLE = "variable";
  static const char * const STR_PRIORITIZED = "prioritized";
  static const char * const STR_IF       = "if";
  static const char * const STR_ELSE     = "else";
  static const char * const STR_THEN     = "then";
  static const char * const STR_CONDITION= "condition";
  static const char * const STR_BLOCK    = "block";

  static const char * const STR_SQRT     = "sqrt";
  static const char * const STR_EXP      = "exp";
  static const char * const STR_LOG      = "log";
  static const char * const STR_LOG10    = "log10";
  static const char * const STR_ADD      = "add";
  static const char * const STR_SUBTRACT = "subtract";
  static const char * const STR_MULTIPLY = "multiply";
  static const char * const STR_DIVIDE   = "divide";
  static const char * const STR_POWER    = "power";
  static const char * const STR_MINUS    = "minus";
  static const char * const STR_PLUS     = "plus";

  static const char * const STR_EQ       = "eq";
  static const char * const STR_NE       = "ne";
  static const char * const STR_LT       = "lt";  
  static const char * const STR_LE       = "le";
  static const char * const STR_GT       = "gt";
  static const char * const STR_GE       = "ge";
  static const char * const STR_NXOR     = "nxor";
  static const char * const STR_XOR      = "xor";
  static const char * const STR_OR       = "or";
  static const char * const STR_AND      = "and";
  static const char * const STR_NEGATE   = "negate";

  static const char * const STR_SEMICOLON= ";";
  static const char * const STR_NEWLINE  = "\n";
  static const char * const STR_TAB      = "\t";
  static bool inRHS = false;
  static bool inConditional = false;

%}

%union{
  char   ch;
  char*  c_str;
}

//
// Char* type tokens / non-terminals
//
%token <c_str>  NAME 
%token <c_str>  OPEN_ARRAY_ELEM_LIST
%token <c_str>  CLOSE_ARRAY_ELEM_LIST
%token <c_str>  POWER_OP
%token <c_str>  DEFINED_UNARY_FUNCTION
%token <c_str>  DIGIT_STRING
%token <c_str>  ENG_NOTATION
%token <c_str>  SIGNIFICAND
%token <c_str>  COMMENT

//
// char type tokens / non-terminals
//
%token <ch>   EQ_OP
%token <ch>   NE_OP
%token <ch>   LT_OP
%token <ch>   LE_OP
%token <ch>   GT_OP
%token <ch>   GE_OP
%token <ch>   AND_OP
%token <ch>   OR_OP
%token <ch>   NOT_OP
%token <ch>   EQV_OP
%token <ch>   NEQV_OP
%token <ch>   EXIT
%token <ch>   IF
%token <ch>   THEN
%token <ch>   ELSE
%token <ch>   ENDIF
%token <ch>   TRUE FALSE
%token <ch>   EOF_MARKER

%type  <c_str> input
%type  <c_str> statement
%type  <c_str> if_stmt_or_block
%type  <c_str> if_construct
%type  <c_str> if_then_stmt
%type  <c_str> if_then_clause
%type  <c_str> else_clause
%type  <c_str> block
%type  <c_str> line
%type  <c_str> assignment_stmt
%type  <c_str> variable
%type  <c_str> whole_object
%type  <c_str> subobject
%type  <c_str> literal_constant
%type  <c_str> int_literal_constant 
%type  <c_str> real_literal_constant
%type  <c_str> logical_constant
%type  <c_str> int_expr 
%type  <c_str> start_subscript 
%type  <c_str> end_subscript 
%type  <c_str> stride
%type  <c_str> slice
%type  <c_str> vector_section_variable 
%type  <c_str> matrix_section_variable
%type  <c_str> relational_expr
%type  <c_str> logical_expr
%type  <c_str> if_stmt 
%type  <c_str> expr
%type  <c_str> arithmatic_expr
%type  <c_str> primary 
%type  <c_str> array_constructor 
%type  <c_str> array_element_list 
%type  <c_str> function_ref
%type  <c_str> exit_stmt

%right '='
%nonassoc EQV_OP NEQV_OP
%nonassoc OR_OP
%nonassoc AND_OP
%nonassoc NOT_OP
%nonassoc EQ_OP NE_OP LT_OP LE_OP GT_OP GE_OP
%left '+' '-'
%nonassoc SIGN
%left '*' '/'
%right POWER_OP

%start input

%%
//==================================================================================
//
// input
//
// This is the fundamental unit that this parser accepts.
// An input is the root of the entire tree and
// can have any number of *line*s (each of which is an assignment statement)
// or if_stmt_or_block (which is either an if-stmt or if-construct).
//
//==================================================================================*/
input: 
//
// A unit can be empty.
// Return NULL.
//
/* empty */ {
   
   $$ = NULL;
}
| 
//
// A unit can contain lines.
// Unless the left hand side, "input", is empty, concatinate
// the right hand side, "line", which is terminated with a new line character.
// If "input" is empty, just return the "line".
//
input line {
  
//   printf( "%s", $2 ); 
   fprintf( gSpkExpOutput, "%s\n", $2 );
   delete $2;
   $$ = NULL;
}
|
//
// A unit can contain if-constructs (if-then-else).
// Unless the left hand side, "input", is empty, concatinate
// the right hand side, "if_stmt_or_block", which is termianted
// with a new line character.
// If "input" is empty, just return the block.
// 
input { inConditional=true; } if_stmt_or_block { inConditional=false; } {

//   printf( "%s", $3 );
   fprintf( gSpkExpOutput, "%s\n", $3 );
   delete $3;
   $$ = NULL;
}
|
//
// End of file detected.
//
input EOF_MARKER {

  YYACCEPT;
}

;

//==================================================================================
//
// if_stmt_or_block
//
// Either an if statement or a set of if-then-else clauses.
// One might argue an if statement is a statement, therefore it should be
// part of "statement" non-terminal. It is true.  However, Bison, wich uses only 
// a single lookahead token, cannot distinguish if-stmt and if-construct since
// both begin with the IF token.  This is to trick Bison so that it won't 
// produce a shift/reduce conflict.
//
//==================================================================================
if_stmt_or_block :
if_stmt {
   
   $$ = $1;
}
| if_construct 
{
   $$ = $1;
}
;

//==================================================================================
//
// line
//
// A sequence of (may be empty) strings terminated by a new line character ('\n').
// When a legal "line" is detected, the line count is incremented by one.
//
//==================================================================================
line : 

//
// An empty line.  
//  
'\n'  { 
  gSpkExpLines++; 
  char buf[2];
  sprintf( buf, "\n" );
  $$ = (char*)strdup(buf);
} 
| 
//
// A comment only line.
// Replace the comment marker with C++ equivalent.
// Increment the line counter and return the comment terminated
// with a new line character.
//
COMMENT '\n' {
  gSpkExpLines++;
  
  char buf[ strlen( $1 ) + strlen( "// " ) + strlen( STR_NEWLINE ) + 1 ];
  sprintf( buf, "// %s\n", $1 );
  delete $1;
  $$ = (char*)strdup(buf);
}
|
statement '\n' {
  gSpkExpLines++;
  char buf[ strlen( $1 ) + strlen( STR_NEWLINE ) + 1 ];
  sprintf( buf, "%s\n", $1 );
  delete $1;
  $$ = (char*)strdup(buf);
}
|
//
// A statement followed by a comment.
// Replace the comment marker in COMMENT and concatinate
// it to "statement", and return the string.
// 
statement COMMENT '\n' {

  gSpkExpLines++;

  char buf[ strlen( $1 ) + strlen( STR_TAB ) + strlen( "// " ) 
          + strlen( STR_NEWLINE ) + strlen( $2 ) + 1 ];
  sprintf( buf, "%s\t// %s\n", $1, $2 );
  delete $1;
  delete $2;
  $$ = (char*)strdup(buf);
}
;

//==================================================================================
//
// statement
//
// A statement may be an assignement_stmt, if_stmt or exit_stmt.
//
//==================================================================================
statement : 
assignment_stmt {
  $$ = $1;
}
|
exit_stmt {

  char buf[ strlen( $1 ) + 1 ];
  sprintf( buf, "%s;", $1 );
  delete $1;
  $$ = (char*)strdup(buf);
}
;

//==================================================================================
//
// exit_stmt
//
// An exit_stmt has three forms; 1) the terminal EXIT only, 2) the terminal
// followed by a number and 3) the terminal followed by two numbers.
//
//
// The first number is a PRED exit code (default 1 or 2) and
// the second number is the user error code, which must be 0-999.  The default is 0.
// 
// Attention!  The NONMEM abbriviated code's EXIT means something different from
// that of Fortran.
//
// NONMEM's EXIT statement shall cause an immediate exit from the routine,
// and, if PREDPP is being used, an immediate exit from PREDPP.  
// It is typically used in an IF statement to avoid computing further.
// (see p79, NONMEM User's Guide Part VIII for complete specification)
//
// This construct produces code like:
//
//   nonmem_exit( int pred_exit_code, int user_exit_code );
//
// The above function, nonmem_exit(), must be defined in the domain.
//
//==================================================================================
exit_stmt :
EXIT {
   
   char *buf = "nonmem_exit( 1, 0 );";
   $$ = (char*)strdup(buf);
}
|
EXIT DIGIT_STRING {

   char buf[ strlen( $2 ) + strlen("nonmem_exit( , 0 );") + 1 ];
   sprintf( buf, "nonmem_exit( %s, 0 );", $2 );
   delete $2;
   $$ = (char*)strdup(buf);
}
|
EXIT DIGIT_STRING DIGIT_STRING {

   char buf[ strlen( $2 ) + strlen( $3 ) + strlen("nonmem_exit( ,  );") + 1 ];
   sprintf( buf, "nonmem_exit( %s, %s );", $2, $3 );
   delete $2;
   delete $3;
   $$ = (char*)strdup(buf);
}
;

//==================================================================================
//
// assignment_stmt
//
//==================================================================================
assignment_stmt :
{inRHS=false;} variable '=' {inRHS=true;} expr {inRHS=false;}{
   
   char buf[ strlen($2) + strlen(" = ") + strlen($5) + strlen(";") + 1 ];
   sprintf( buf, "%s = %s;", $2, $5 );
   delete $2;
   delete $5;
   $$ = (char*)strdup(buf);

}
;

//==================================================================================
//
// variable
//
// A variable is a named object that may represents a whole object or
// subset of a whole object.
//
//==================================================================================
variable :
whole_object { 

  $$ = $1; 
} // this includes scalar objects and whole array (vector/matrix) objects
|
subobject {

  // NOT SUPPORTED YET!
  $$ = $1;
}
;
whole_object :
NAME { 

  $$ = $1;
}
;

subobject :
vector_section_variable {
  $$ = $1;
}
|
matrix_section_variable {
  $$ = $1;
}
;

//==================================================================================
//
// vector_section_variable
//
// A variable that is a subset of a vector.
//
// NOTE!!!  Indexing is only allowed by arithmatic expressions for now,
//          No valarray slice or gslice!!!
// 
//==================================================================================
vector_section_variable : 
NAME '(' slice ')' { 

   //
   // Assumption: $3 is an arithmatic expression or a mere integer for now.
   //
   char buf[ strlen( $1 ) + strlen( "[ (  ) - 1 ]" ) + 1 ];
   sprintf( buf, "%s[ ( %s ) - 1 ]", $1, $3 );
   delete $1;
   delete $3;
   $$ = (char*)strdup(buf);
}
;

//==================================================================================
//
// matrix_section_variable
//
// A variable that is a subset of a matrix.
// 
// NOTE!!!  Not supported for now!
//==================================================================================
matrix_section_variable :
NAME '(' slice ',' slice ')' {
 
   // NOT SUPPORTED YET!
   $$ = (char*)strdup("not supported");
}
;


//==================================================================================
//
// slice
//
// A slice is a tree describing how to access an array (both vector and matrix).
//
//==================================================================================
slice :
int_expr { 

   $$ = $1;
}
|
start_subscript ':' end_subscript { 

   // NOT SUPPORTED YET!
   $$ = (char*)strdup("not supported");
}
|
start_subscript ':' end_subscript ':' stride {

   // NOT SUPPORTED YET!
   $$ = (char*)strdup("not supported");
}
;

//==================================================================================
//
// start_subscript
//
// A start_subscript is an int_expr.
//
//==================================================================================
start_subscript :
int_expr {
 
  $$ = $1;
}
;

//==================================================================================
//
// end_subscript
//
// An end_subscript is an int_expr.
//
//==================================================================================
end_subscript :
int_expr {

  $$ = $1;
}
;

//==================================================================================
// 
// stride
//
// A stride is an int_expr.
//
//==================================================================================
stride :
int_expr {

  $$ = $1;
}
;

//==================================================================================
//
// int_expr
//
// An int_expr is an expression of type integer.
//
//==================================================================================
int_expr : 
arithmatic_expr {

  $$ = $1;
}
;

//==================================================================================
//
// primary
//
// A primary object is one of the followings:
//
// 1) literal_constant (ex. 1234, 1234.56)
// 2) variable (ex. A, A(i:j), A(i:j:h, i:j:h))
// 3) array_constructor (ex. (/1,2,3/))
// 4) function_ref (ex. log(a))
// 5) parenthesized expression (i.e. ( expr ) )
//
// In the form (5), the expression tree is appended as the only child of 
// "prioritized" tree which is going to be returned by this production.
//
//==================================================================================
primary :
literal_constant { 

   $$ = $1; 
}
|
variable { 

   $$ = $1; 
}
|
array_constructor { 

   $$ = (char*)strdup("not supported"); 
}
|
function_ref {
 
   $$ = $1; 
}
|
'(' expr ')' { 

   char buf[ strlen( $2 ) + strlen( "(  )" ) + 1 ];
   sprintf( buf, "( %s )", $2 );
   delete $2;
   $$ = (char*)strdup(buf);
}
;

//==================================================================================
//
// expr
//
// An "expr" is a logical_expr.
//
//==================================================================================
expr :
logical_expr { 
  $$ = $1;
}
;

//==================================================================================
//
// if_stmt
//
//
//==================================================================================
if_stmt :
IF '(' logical_expr ')' assignment_stmt { 

   //
   // A logical_expr can be an arithmatic_expr by syntactic rule
   // but here we expect only an expression that evaluates to true or false.
   // FORTRAN does not treat a numeric value (like 0 or 1) as a logical value.
   // So, we kicks out arithmatic expressions here.
   // 
   char buf[ strlen( "if(  ){}" ) + strlen( STR_NEWLINE ) * 3 + strlen( $3 ) + strlen( $5 ) + 1 ];
   sprintf( buf, "if( %s )\n{\n%s\n}", $3, $5 );
   delete $3;
   delete $5;
   $$ = (char*)strdup(buf);

}
;
//==================================================================================
//
// if_construct
//
//==================================================================================

if_construct :
if_then_clause ENDIF '\n' { 
  char buf[ strlen( $1 ) + strlen( STR_NEWLINE ) + 1 ];
  sprintf( buf, "%s\n", $1 );
  delete $1;
  $$ = (char*)strdup(buf); 
} 

| if_then_clause else_clause ENDIF '\n' {

  char buf[ strlen( $1 ) + strlen( $2 ) + strlen( STR_NEWLINE) * 2 + 1 ];
  sprintf( buf, "%s\n%s\n", $1, $2 );
  delete $1;
  delete $2;
  $$ = (char*)strdup(buf);
}
;

if_then_clause :
if_then_stmt '\n' { inConditional = true; } block  { inConditional = false; } {

  char buf[ strlen( $1 ) + strlen( "{}" ) + strlen( STR_NEWLINE ) * 3 + strlen( $4 ) + 1 ];
  sprintf( buf, "%s\n{\n%s\n}", $1, $4 );
  delete $1;
  delete $4;

  $$ = (char*)strdup(buf);
}
;
else_clause :
ELSE '\n' { inConditional = true; } block  { inConditional = false; } {

  char buf[ strlen( "else" ) + strlen( STR_NEWLINE ) * 3 + strlen( "{}" ) + strlen( $4 ) + 1 ];
  sprintf( buf, "else\n{\n%s\n}", $4 );
  delete $4;
  $$ = (char*)strdup(buf);
}
;

//==================================================================================
//
// if_then_stmt
//
// An if_then_stmt is a portion of if_construct that extracts and returns 
// the conditional statement.
//
//==================================================================================
if_then_stmt :
IF '(' logical_expr ')' THEN { 
  //
  // A logical_expr can be an arithmatic_expr by syntactic rule
  // but here we expect only an expression that evaluates to true or false.
  // FORTRAN does not treat a numeric value (like 0 or 1) as a logical value.
  // So, we kicks out arithmatic expressions here.
  // 
  char buf[ strlen( "if(  )" ) + strlen( $3 ) + 1 ];
  sprintf( buf, "if( %s )", $3 );
  delete $3;
  $$ = (char*)strdup(buf);
}
;

//==================================================================================
//
// block
//
// A block is a set of expressions and blank lines. it can be made of only blanks.
//
//==================================================================================
block :
/* empty */
{ 
   $$ = NULL;
}
|
block line {

   if( $1 == NULL )
   {
      char buf[ strlen( $2 ) + strlen( STR_NEWLINE ) + 1 ];
      sprintf( buf, "%s\n", $2 );
      delete $2; 
      $$ = (char*)strdup(buf);
   }	
   else
   {
      char buf[ strlen( $1 ) + strlen( $2 ) + strlen( STR_NEWLINE ) + 1 ];
      sprintf( buf, "%s%s\n", $1, $2 );
      delete $1;
      delete $2; 
      $$ = (char*)strdup(buf);
   }
}
;

//==================================================================================
//
// literal_constant
//
// A literal_constant can be either integer type or real type.
//
//==================================================================================
literal_constant :
int_literal_constant  { 
  $$ = $1; 
}
|
real_literal_constant { 
  $$ = $1; 
}
;

//==================================================================================
//
// int_literal_constant
//
// An int_literal_constant is a literal constant (ex. 1234) of type integer.
//
//==================================================================================
int_literal_constant :
DIGIT_STRING { 

  //
  // This is an integer constant.
  //
  $$ = $1;
}
;

//==================================================================================
//
// real_literal_constant
//
// An real_literal_constant is a literal constant (ex. 12.34) of type real.
//
//==================================================================================
real_literal_constant :
SIGNIFICAND { 
  //
  // This is a real constant in the form of "0.0".
  //
  $$ = $1;
}
|
ENG_NOTATION { 
  // 
  // This is a real constant in the form of "0.0E0"
  //
  $$ = $1;
}
;

//==================================================================================
//
// logical_constant
//
// A logical_constant is a literal constant of type logical (boolean).
// It has two values: TRUE or FALSE.
//
//==================================================================================
logical_constant :
TRUE { 
  //
  // This is a boolean value "true".
  //  
  $$ = (char*)strdup("true");
}
|
FALSE {
  //
  // This is a boolean value "false".
  //
  $$ = (char*)strdup("false");
}
;


//==================================================================================
//
// array_constructor
//
// An array_constructor is a list of array initials enclosed by "(/" and "/)".
//
//==================================================================================
array_constructor :
OPEN_ARRAY_ELEM_LIST array_element_list CLOSE_ARRAY_ELEM_LIST {
  
  // NOT SUPPORTED YET!
  $$ = (char*)strdup("not supported");  
}
;

//==================================================================================
//
// array_element_list
//
// An array_element_list is a list of values or expressions that initialize
// an array.  
// 
//==================================================================================
array_element_list :
expr {

   // NOT SUPPORTED YET!
   $$ = (char*)strdup("not supported");
}
|
array_element_list ',' expr {

   // NOT SUPPORTED YET!
   $$ = (char*)strdup("not supported");
}
;

//==================================================================================
//
// function_ref
//
// A function_ref is a reference to an existing function.
// NONMEM abbriviated code supports only sqrt, exp, log and log10.
// It retrurns a tree topped with label "function".
//
//==================================================================================
function_ref :
DEFINED_UNARY_FUNCTION '(' arithmatic_expr ')' { 

   //
   // allocate for the longest string.
   //
   int n = strlen( $1 ); 
   char buf[ n + strlen( "(  )" ) + 1 ];
   char lowercase[ n + 1 ];
   strcpy( lowercase, $1 );
   for( int i=0; i<n; i++ )
      lowercase[ i ] = tolower( lowercase[i] );

   if( strcmp( lowercase, STR_LOG ) == 0 )
       sprintf( buf, "log( %s )",   $3 );
   else if( strcmp( lowercase, STR_LOG10 ) == 0 )
       sprintf( buf, "log10( %s )", $3 );
   else if( strcmp( lowercase, STR_EXP ) == 0 )
       sprintf( buf, "exp( %s )",   $3 );
   else if( strcmp( lowercase, STR_SQRT ) == 0 )
       sprintf( buf, "sqrt( %s )",  $3 );
   else
   {
      char err[128];
      sprintf( err, "%s is not a supported operation!\n", lowercase );
      yyerror( err );
   }
   delete $3;
   $$ = (char*)strdup(buf);
}
;

//==================================================================================
//
// arithmatic_expr
//
// An arithmatic_expr is an expression that evalutes to a numerical value.
// 
// The precedence is 
//
// 4) a + b (addition),  a - b (subtraction)
// 3) +a (plus), -a (minus)
// 2) a * b (multiplication), a / b (division)
// 1) a ** b (power).
// 
//==================================================================================
arithmatic_expr :
arithmatic_expr '+' arithmatic_expr {

   char buf[ strlen( $1 ) + strlen( " + " ) + strlen( $3 ) + 1 ];
   sprintf( buf, "%s + %s", $1, $3 );
   delete $1;
   delete $3;
   $$ = (char*)strdup(buf);
}
|
arithmatic_expr '-' arithmatic_expr { 

   char buf[ strlen( $1 ) + strlen( " - " ) + strlen( $3 ) + 1 ];
   sprintf( buf, "%s - %s", $1, $3 );
   delete $1;
   delete $3;
   $$ = (char*)strdup(buf);
}
|
'-' arithmatic_expr %prec SIGN {

   char buf[ strlen( "-" ) + strlen( $2 ) + 1 ];
   sprintf( buf, "-%s", $2 );
   delete $2;
   $$ = (char*)strdup(buf);
}
|
'+' arithmatic_expr %prec SIGN {

   char buf[ strlen( "+" ) + strlen( $2 ) + 1 ];
   sprintf( buf, "+%s", $2 );
   delete $2;

   $$ = (char*)strdup(buf);
}
|
arithmatic_expr '*' arithmatic_expr {

   char buf[ strlen( $1 ) + strlen( " * " ) + strlen( $3 ) + 1 ];
   sprintf( buf, "%s * %s", $1, $3 );
   delete $1;
   delete $3;
   $$ = (char*)strdup(buf);
}
|
arithmatic_expr '/' arithmatic_expr {

   char buf[ strlen( $1 ) + strlen( " / " ) + strlen( $3 ) + 1 ];
   sprintf( buf, "%s / %s", $1, $3 );
   delete $1;
   delete $3;
   $$ = (char*)strdup(buf);
}
|
arithmatic_expr POWER_OP arithmatic_expr {

   char buf[ strlen( "pow( ,  )" ) + strlen( $1 ) + strlen( $3 ) + 1 ];
   sprintf( buf, "pow( %s, %s )", $1, $3 );
   delete $1;
   delete $3;
   $$ = (char*)strdup(buf);
}
|
primary {
   $$ = $1; 
}
;

//==================================================================================
//
// relational_expr
//
// A relational_expr is an operator that compares the magnitudes or quantities of
// lhs and rhs and evaluates to true or false.
//
// Although a relational_expr, by syntactic rule, accepts an appearance of 
// arithmatic_expr by itself, a numerical value resulted from evaluating an 
// arithmatic expression, by FORTRAN's specification, is NOT interpreted 
// as true or false at all.  So, the clients of this production should
// check the type of the expression when necessarily.
//  
//==================================================================================
relational_expr :
relational_expr EQ_OP relational_expr {

   char buf[ strlen( $1 ) + strlen( " == " ) + strlen( $3 ) + 1 ];
   sprintf( buf, "%s == %s", $1, $3 );
   delete $1;
   delete $3;
   $$ = (char*)strdup(buf);
}
|
relational_expr NE_OP relational_expr { 

   char buf[ strlen( $1 ) + strlen( " != " ) + strlen( $3 ) + 1 ];
   sprintf( buf, "%s != %s", $1, $3 );
   delete $1;
   delete $3;
   $$ = (char*)strdup(buf);
}
|
relational_expr LT_OP relational_expr { 

   char buf[ strlen( $1 ) + strlen( " < " ) + strlen( $3 ) + 1 ];
   sprintf( buf, "%s < %s", $1, $3 );
   delete $1;
   delete $3;
   $$ = (char*)strdup(buf);
}
|
relational_expr LE_OP relational_expr {

   char buf[ strlen( $1 ) + strlen( " <= " ) + strlen( $3 ) + 1 ];
   sprintf( buf, "%s <= %s", $1, $3 );
   delete $1;
   delete $3;
   $$ = (char*)strdup(buf);
}
|
relational_expr GT_OP relational_expr {

   char buf[ strlen( $1 ) + strlen( " > " ) + strlen( $3 ) + 1 ];
   sprintf( buf, "%s > %s", $1, $3 );
   delete $1;
   delete $3;
   $$ = (char*)strdup(buf);
}
|
relational_expr GE_OP relational_expr {

   char buf[ strlen( $1 ) + strlen( " >= " ) + strlen( $3 ) + 1 ];
   sprintf( buf, "%s >= %s", $1, $3 );
   delete $1;
   delete $3;
   $$ = (char*)strdup(buf);
}
|
arithmatic_expr {
  $$ = $1;
}
|
logical_constant { 
  $$ = $1; 
}
;

//==================================================================================
//
// logical_expr
//
// A logical_expr is an operator that computes logical expressions.
// The operand(s) of such an operator must evaluete to true or false
// and the operator further evaluates to true or false.
//
//
// Although a logical_expr, by syntactic rule, accepts an appearance of 
// arithmatic_expr by itself, a numerical value resulted from evaluating an 
// arithmatic expression, by FORTRAN's specification, is NOT interpreted 
// as true or false at all.  So, the clients of this production should
// check the type of the expression when necessarily.
// 
//==================================================================================
logical_expr :
logical_expr EQV_OP logical_expr {

   char buf[ strlen( $1 ) + strlen( " == " ) + strlen( $3 ) + 1 ];
   sprintf( buf, "%s == %s", $1, $3 );
   delete $1;
   delete $3;
   $$ = (char*)strdup(buf);
}
|
logical_expr NEQV_OP logical_expr {

   char buf[ strlen( $1 ) + strlen( " != " ) + strlen( $3 ) + 1 ];
   sprintf( buf, "%s != %s", $1, $3 );
   delete $1;
   delete $3;
   $$ = (char*)strdup(buf);
}
|
logical_expr OR_OP logical_expr {

   char buf[ strlen( $1 ) + strlen( " || " ) + strlen( $3 ) + 1 ];
   sprintf( buf, "%s || %s", $1, $3 );
   delete $1;
   delete $3;
   $$ = (char*)strdup(buf);
}
|
logical_expr AND_OP logical_expr {

   char buf[ strlen( $1 ) + strlen( " && " ) + strlen( $3 ) + 1 ];
   sprintf( buf, "%s && %s", $1, $3 );
   delete $1;
   delete $3;
   $$ = (char*)strdup(buf);
}
|
NOT_OP logical_expr {
   
   char buf[ strlen( $2 ) + strlen( " !(  ) " ) + 1 ];
   sprintf( buf, "!( %s )", $1 );
   delete $2;
   $$ = (char*)strdup(buf);
}
|
relational_expr {
   $$ = $1;
}
;
%%
