#!/usr/bin/perl -w

#*********************************************************************************
#
# File:  NonmemOutput.pm
#
#
# Reads in the values from a NONMEM output file.
#
# Author: Mitch Watrous
#
#
# Exported Symbols
# ----------------
#
# readNonmemOutput
#
# Subroutine that reads in the NONMEM output file.
#
#
# $parEstCalc
#
# Indicates whether or not the parameter estimation step was attempted.
#
#
# $parEstOk
#
# Indicates whether or not the parameter estimation step succeeded.
#
#
# $SECalc
#
# Indicates whether or not the standard errors step was attempted.
#
#
# $SEOk
#
# Indicates whether or not the standard errors step succeeded.
#
#
# $messages
#
# Text generated by NONMEM during either the parameter estimation and/or 
# standard errors step.
#
#
# $nsig
#
# Number of significant digits required in the final parameter
# estimates.
#
#
# $objApproxMethod
#
# The NONMEM approximation for the objective function that was used.
#
#
# $objVal 
#
# The NONMEM objective function value.
#
#
# $thetaOut
#
# Reference to an array containing the final theta value.
# Elements that were not calculated are indicated by a value of "no_value".
#
#
# $thetaSE
#
# Reference to an array containing the standard errors for the final
# theta value.  Elements that were not calculated are indicated by a 
# value of "no_value".
#
#
# $OmegaOut
#
# If Omega is full, this is a reference to an array of arrays containing
# the elements from the lower triangle of the final Omega value.  
# If Omega is diagonal, only the diagonal elements are present.
# Elements that were not calculated are indicated by a value of "no_value".
#
#
# $OmegaSE 
#
# If Omega is full, this is a reference to an array of arrays containing
# the standard errors for the lower triangle of the final Omega value.  
# If Omega is diagonal, only the diagonal elements' standard errors are 
# present.  Elements that were not calculated are indicated by a value 
# of "no_value".
#
#
# $SigmaOut
#
# If Sigma is full, this is a reference to an array of arrays containing
# the elements from the lower triangle of the final Sigma value.  
# If Sigma is diagonal, only the diagonal elements are present.
# Elements that were not calculated are indicated by a value of "no_value".
#
#
# $SigmaSE 
#
# If Sigma is full, this is a reference to an array of arrays containing
# the standard errors for the lower triangle of the final Sigma value.  
# If Sigma is diagonal, only the diagonal elements' standard errors are 
# present.  Elements that were not calculated are indicated by a value 
# of "no_value".
#
#
# $covOfEst
#
# A reference to an array of arrays containing the lower triangle of the 
# covariance matrix of the parameter estimates.  A value of "no_value" 
# indicates that the particular element was not calculated.
#
#
# $corrOfEst
#
# A reference to an array of arrays containing the lower triangle of the 
# correlation matrix of the parameter estimates.  A value of "no_value" 
# indicates that the particular element was not calculated.
#
#
# $etaForAllOut
#
# A reference to an array of arrays containing the matrix of estimates for 
# the true minimizers of the individual objective functions.  Each column 
# of this matrix corresponds to the eta value for a particular individual.
# A value of "no_value" indicates that the particular element was not calculated.
#
#
# $predForAllOut
#
# A reference to an array of arrays containing a "matrix" of data mean 
# model values for each of the individual's data points evaluated using the 
# final values for the fixed effects and for that individual's random effects.
# Each row of this "matrix" contains the model values for a particular individual.
# Note that because each row may contain different number of elements, this 
# is not truly a matrix in the mathematical sense.  A value of "no_value" 
# indicates that the particular element was not calculated.
#
#*********************************************************************************

#------------------------------------------------------------------------
# Preliminaries.
#------------------------------------------------------------------------

use strict;

package NonmemOutput;

# Specify the symbols that will be exported 
require Exporter;
our @ISA       = qw( Exporter );
our @EXPORT    = qw( readNonmemOutput
                     $parEstCalc
                     $parEstOk
                     $SECalc
                     $SEOk
                     $messages
                     $nsig
                     $objApproxMethod
                     $objVal
                     $thetaOut
                     $thetaSE
                     $OmegaStructure
                     $OmegaOut
                     $OmegaSE
                     $SigmaStructure
                     $SigmaOut
                     $SigmaSE
                     $covOfEst
                     $corrOfEst
                     $etaForAllOut
                     $predForAllOut );


#*****************************************************************
#
# Subroutine: readNonmemOutput
#
#
# Reads in the values from the NONMEM output file specified 
# by its input argument.
#
#
# Arguments
# ---------
#
# $_[0]
#
# Path and name for the NONMEM output file.
#
#*****************************************************************

sub readNonmemOutput
{
  #---------------------------------------------------------------
  # Preliminaries.
  #---------------------------------------------------------------

  use strict;

  my $count;
  my $dummy;
  my @dummy;
  my $i;
  my $j;


  #---------------------------------------------------------------
  # Open the NONMEM output file.
  #---------------------------------------------------------------

  # Check that the output file specified by the input argument exists.
  my $file = shift;
  -f $file or die "Can't find $file.\n";

  open( FILE, $file ) or die "Can't open $file.\n";

  # Check the first line of the NONMEM output file.
  my $line = <FILE>;
  $line =~ /.*NONMEM.*DOUBLE.*PRECISION.*VERSION V/
    or die "The NONMEM output file has the wrong format.\n";


  #---------------------------------------------------------------
  # Get the size and structures for theta, Omega, and Sigma.
  #---------------------------------------------------------------

  my $nTheta    = 0;
  my $nOmega    = 0;
  my $nSigma    = 0;

  my $OmegaStructure;
  my $SigmaStructure;

  # Get the length of theta.
  while( <FILE> )
  {
    last if ( /LENGTH OF THETA:/ );
  }
  ($dummy, $nTheta) = split( /: */ );

  # Get the dimensions of Omega.
  while( <FILE> )
  {
    last if ( /OMEGA HAS/ );
  }
  if ( /OMEGA HAS SIMPLE DIAGONAL FORM WITH DIMENSION:/ )
  {
    $OmegaStructure = 'diagonal';
    ($dummy, $nOmega) = split( /: */ );

    # Advance to the Sigma section.
    if ( $nTheta == 3 )
    {
      while( <FILE> )
      {
        last if ( /.*SIGMA.*:/ );
      }
    }
  }
  elsif ( /OMEGA HAS BLOCK FORM:/ )
  {
    $OmegaStructure = 'full';
    while( <FILE> )
    {
      # Go on once the Sigma section is reached.
      if ( $nTheta == 3 )
      {
        last if ( /.*SIGMA.*:/ );
      }
      if ( $nTheta == 4 )
      {
        last if ( /.*INITIAL ESTIMATE OF THETA:/ );
      }
  
      # This program currently assumes each Omega block has a single element.
      for ( split )
      {
        $_ == 1 or die "This program assumes each Omega block has one element.\n";
      }

      $nOmega++;
    }
  }
  else
  {
    die "This program cannot handle this Omega structure.\n";
  }

  # Get the dimensions of Sigma.
  if ( $nTheta == 3 )
  {
    if ( /SIGMA HAS SIMPLE DIAGONAL FORM WITH DIMENSION:/ )
    {
      $SigmaStructure = 'diagonal';
      ($dummy, $nSigma) = split( /: */ );
    }
    elsif ( /SIGMA HAS BLOCK FORM:/ )
    {
      $SigmaStructure = 'full';
      while( <FILE> )
      {
        # Go on once the Sigma section is reached.
        last if ( /.*SIGMA.*:/ );
  
        # This program currently assumes each Sigma block has a single element.
        for ( split )
        {
          $_ == 1 or die "This program assumes each Sigma block has one element.\n";
        }

        $nSigma++;
      }
    }
    else
    {
      die "This program cannot handle this Sigma structure.\n";
    }
  }
  elsif ( $nTheta == 4 )
  {
    $nSigma = 1;
    $SigmaStructure = 'diagonal';
  }
  else
  {
    die "This program cannot handle this Theta structure.\n";
  }

  my $isOmegaDiag = $OmegaStructure eq 'diagonal';
  my $isSigmaDiag = $SigmaStructure eq 'diagonal';

  # Check that the values were determined from the file.
  $nTheta    or die "The length of theta was not able to be determined.\n";
  $nOmega    or die "The dimension of Omega was not able to be determined.\n";
  $nSigma    or die "The dimension of Sigma was not able to be determined.\n";


  #---------------------------------------------------------------
  # Get information related to the estimation step.
  #---------------------------------------------------------------

  our $parEstCalc = 'false';

  # These are the NONMEM default values. 
  our $objApproxMethod = 'FO Method';
  our $nsig            = 3;

  my $epsEtaInteraction = 0;

  # Get the estimation step information.
  while( <FILE> )
  {
    last if ( /ESTIMATION STEP/ );
  }
  if ( /ESTIMATION STEP OMITTED:.+NO/ )
  {
    $parEstCalc = 'true';
  }
  while( <FILE> )
  {
    # Go on once the Covariance step section is reached.
    last if ( /.*COVARIANCE STEP/ );

    if ( /.*EPS-ETA INTERACTION:.+YES/ )
    {
      $epsEtaInteraction = 1;
    }

    if ( /.*LAPLACIAN OBJ. FUNC.:.+NO/ )
    {
      if ( $epsEtaInteraction )
      {
        $objApproxMethod = 'FOCE+Interaction Method';
      }
      else
      {
        $objApproxMethod = 'FOCE Method';
      }
    }

    if ( /.*LAPLACIAN OBJ. FUNC.:.+YES/ )
    {
      $objApproxMethod = 'Laplacian Method';
    }

    if ( /.*SIG. FIGURES REQUIRED/ )
    {
      ($dummy, $nsig) = split( /: */ );
    }
  }


  #---------------------------------------------------------------
  # Get information related to the standard errors step.
  #---------------------------------------------------------------

  our $SECalc = 'false';

  # Get the standard errors step information.
  while( <FILE> )
  {
    last if ( /TABLES STEP/ );
  }
  if ( /COVARIANCE STEP OMITTED:.+NO/ )
  {
    $SECalc = 'true';
  }


  #---------------------------------------------------------------
  # Determine if the estimation and standard errors steps succeeded.
  #---------------------------------------------------------------

  our $parEstOk = 'false';
  our $SEOk     = 'false';
  our $message;

  # Check the status of the estimation and standard errors steps.
  while( <FILE> )
  {
    last if ( /MONITORING OF SEARCH/ );
  }
  while( <FILE> )
  {
    # Go on once the end of the Monitoring of Search section or 
    # the beginning of the objective function section is reached.
    last if ( /^1/ or /\*{10,}/ );

    if ( /MINIMIZATION SUCCESSFUL/ )
    {
      $parEstOk = 'true';
      $SEOk     = 'true';
    }

    if ( /COVARIANCE STEP ABORTED/ )
    {
      $SEOk = 'false';
    }

    # Add the current line to the message.
    $message .= $_;
  }


  #---------------------------------------------------------------
  # Get the NONMEM objective function.
  #---------------------------------------------------------------

  our $objVal;

  # Find the line that contains the final value for the objective,
  # which has the following form:
  #
  #  *****************        331.061     *****************
  #
  while( <FILE> )
  {
    last if ( /\*+ +.+\d.+ +\*+/ );
  }

  # Get the value.
  @dummy = split();
  $objVal = $dummy[ 1 ];


  #---------------------------------------------------------------
  # Advance to the beginning of the parameter estimate section.
  #---------------------------------------------------------------

  while( <FILE> )
  {
    last if ( /FINAL PARAMETER ESTIMATE/ );
  }

  /FINAL PARAMETER ESTIMATE/ or die "Final parameter estimates not found.\n";


  #---------------------------------------------------------------
  # Get the NONMEM final theta value.
  #---------------------------------------------------------------

  # This is a reference to the array of values.
  our $thetaOut;

  # Find the lines that contain the final values for theta,
  # which have the following form:
  #
  #            TH 1      TH 2      TH 3
  #
  #         3.17E+00  7.89E-02  4.03E-02
  #
  while( <FILE> )
  {
    last if ( /TH 1/ );
  }
  while( <FILE> )
  {
    last if ( /.+\d/ );
  }

  # Get all of the elements.
  $thetaOut = [ split() ];

  # Check its dimensions.
  $nTheta == @$thetaOut or die "The length of theta is not correct.\n";


  #---------------------------------------------------------------
  # Get the NONMEM final Omega value.
  #---------------------------------------------------------------

  # This a reference to an array of arrays.
  our $OmegaOut = [];

  $count = 0;

  # Find the lines that contain the final values for Omega,
  # which have the following form:
  #
  #             ETA1      ETA2      ETA3
  #
  #  ETA1
  # +        2.44E+00
  #
  #  ETA2
  # +        6.39E-03  1.75E-04
  #
  #  ETA3
  # +        2.44E-01  4.59E-03  3.87E-01
  #
  while( <FILE> )
  {
    last if ( /ETA1/ );
  }
  for ( $j = 0; $j < $nOmega; $j++ )
  {
    while( <FILE> )
    {
      last if ( /ETA/ );
    }
    while( <FILE> )
    {
      last if ( /^\+\s+/ );
    }

    # Remove the "+ " characters from the beginning of $_.
    s/\+\s+//;

    # Get the values for the current row.
    if ( $isOmegaDiag )
    {
      # Only get the last element.
      @dummy = split();
      push @$OmegaOut, [ $dummy[ $#dummy ] ];
    }
    else
    {
      # Get all of the elements.
      push @$OmegaOut, [ split() ];
    }

    # Add in the number of elements in this row.
    $count += scalar( @{$OmegaOut->[ $j ]} );
  }

  # Check its dimensions.
  $count == $isOmegaDiag ? $nOmega : $nOmega * ( $nOmega + 1 ) / 2
    or die "The dimensions of Omega are not correct.\n";


  #---------------------------------------------------------------
  # Get the NONMEM final Sigma value.
  #---------------------------------------------------------------

  # This a reference to an array of arrays.
  our $SigmaOut = [];

  if ( $nTheta == 3 )
  {
    $count = 0;

    # Find the lines that contain the final values for Sigma,
    # which have the following form:
    #
    #             EPS1
    #
    #  EPS1
    # +        4.02E-01
    #
    while( <FILE> )
    {
      last if ( /EPS1/ );
    }
    for ( $j = 0; $j < $nSigma; $j++ )
    {
      while( <FILE> )
      {
        last if ( /EPS/ );
      }
      while( <FILE> )
      {
        last if ( /^\+\s+/ );
      }

      # Remove the "+ " characters from the beginning of $_.
      s/\+\s+//;

      # Get the values for the current row.
      if ( $isSigmaDiag )
      {
        # Only get the last element.
        @dummy = split();
        push @$SigmaOut, [ $dummy[ $#dummy ] ];
      }
      else
      {
        # Get all of the elements.
        push @$SigmaOut, [ split() ];
      }

      # Add in the number of elements in this row.
      $count += scalar( @{$SigmaOut->[ $j ]} );
    }

    # Check its dimensions.
    $count == $isSigmaDiag ? $nSigma : $nSigma * ( $nSigma + 1 ) / 2
      or die "The dimensions of Sigma are not correct.\n";
  }
  elsif ( $nTheta == 4 )
  {
    $SigmaOut->[ 0 ][ 0 ] = pop( @$thetaOut );
  }
  else
  {
    die "This program cannot handle this Theta structure.\n";
  }


  #---------------------------------------------------------------
  # Determine the total number of fixed effects parameters.
  #---------------------------------------------------------------

  my $nFixedEffects = $nTheta;

  for ( $j = 0; $j < $nOmega; $j++ )
  {
    $nFixedEffects += scalar( @{$OmegaOut->[ $j ]} );
  }

  if ( $nTheta == 3 )
  {
    for ( $j = 0; $j < $nSigma; $j++ )
    {
      $nFixedEffects += scalar( @{$SigmaOut->[ $j ]} );
    }
  }
  elsif ( $nTheta == 4 )
  {
  }
  else
  {
    die "This program cannot handle this Theta structure.\n";
  }


  #---------------------------------------------------------------
  # Advance to the beginning of the standard errors section.
  #---------------------------------------------------------------

  if ( $SEOk eq 'true' )
  {
    while( <FILE> )
    {
      last if ( /STANDARD ERROR OF ESTIMATE/ );
    }

    /STANDARD ERROR OF ESTIMATE/ or die "Standard errors for the final parameter estimates not found.\n";
  }


  #---------------------------------------------------------------
  # Get the NONMEM standard errors for the final theta value.
  #---------------------------------------------------------------

  # This is a reference to the array of values.
  our $thetaSE;

  if ( $SEOk eq 'true' )
  {
    # Find the lines that contain the standard errors for theta,
    # which have the following form:
    #
    #            TH 1      TH 2      TH 3
    #
    #         3.17E+00  7.89E-02  4.03E-02
    #
    while( <FILE> )
    {
      last if ( /TH 1/ );
    }
    while( <FILE> )
    {
      last if ( /.+\d/ );
    }

    # Get all of the elements.
    $thetaSE = [ split() ];

    # Check its dimensions.
    $nTheta == @$thetaSE or die "The length of the theta standard errors is not correct.\n";
  }
  else 
  {
    # Set the elements to indicate the standard errors were not calculated.
    $thetaSE = [ ( 'no_value' ) x $nTheta ];
    if ( $nTheta == 4 )
    {
      pop @$thetaSE;
    }
  }


  #---------------------------------------------------------------
  # Get the NONMEM standard errors for the final Omega value.
  #---------------------------------------------------------------

  # This is a reference to an array of arrays.
  our $OmegaSE = [];

  $count = 0;

  if ( $SEOk eq 'true' )
  {
    # Find the lines that contain the standard errors for Omega,
    # which have the following form:
    #
    #             ETA1      ETA2      ETA3
    #
    #  ETA1
    # +        2.44E+00
    #
    #  ETA2
    # +        6.39E-03  1.75E-04
    #
    #  ETA3
    # +        2.44E-01  4.59E-03  3.87E-01
    #
    while( <FILE> )
    {
      last if ( /ETA1/ );
    }
    for ( $j = 0; $j < $nOmega; $j++ )
    {
      while( <FILE> )
      {
        last if ( /ETA/ );
      }
      while( <FILE> )
      {
        last if ( /^\+\s+/ );
      }

      # Remove the "+ " characters from the beginning of $_.
      s/\+\s+//;

      # Get the values for the current row.
      if ( $isOmegaDiag )
      {
        # Only get the last element.
        @dummy = split();
        push @$OmegaSE, [ $dummy[ $#dummy ] ];
      }
      else
      {
        # Get all of the elements.
        push @$OmegaSE, [ split() ];
      }

      # Add in the number of elements in this row.
      $count += scalar( @{$OmegaSE->[ $j ]} );
    }

    # Check its dimensions.
    $count == $isOmegaDiag ? $nOmega : $nOmega * ( $nOmega + 1 ) / 2
      or die "The dimensions of the Omega standard errors are not correct.\n";
  }
  else 
  {
    # Set the elements to indicate the standard errors were not calculated.
    for ( $j = 0; $j < $nOmega; $j++ )
    {
      if ( $isOmegaDiag )
      {
        push @$OmegaSE, [ ( 'no_value' ) x 1 ];
      }
      else
      {
        push @$OmegaSE, [ ( 'no_value' ) x ( $j + 1 ) ];
      }
    }
  }


  #---------------------------------------------------------------
  # Get the NONMEM standard errors for the final Sigma value.
  #---------------------------------------------------------------

  # This is a reference to an array of arrays.
  our $SigmaSE = [];

  $count = 0;

  if ( $SEOk eq 'true' )
  {
    if ( $nTheta == 3 )
    {
      # Find the lines that contain the standard errors for Sigma,
      # which have the following form:
      #
      #             EPS1
      #
      #  EPS1
      # +        4.02E-01
      #
      while( <FILE> )
      {
        last if ( /EPS1/ );
      }
      for ( $j = 0; $j < $nSigma; $j++ )
      {
        while( <FILE> )
        {
          last if ( /EPS/ );
        }
        while( <FILE> )
        {
          last if ( /^\+\s+/ );
        }

        # Remove the "+ " characters from the beginning of $_.
        s/\+\s+//;

        # Get the values for the current row.
        if ( $isSigmaDiag )
        {
          # Only get the last element.
          @dummy = split();
          push @$SigmaSE, [ $dummy[ $#dummy ] ];
        }
        else
        {
          # Get all of the elements.
          push @$SigmaSE, [ split() ];
        }

        # Add in the number of elements in this row.
        $count += scalar( @{$SigmaSE->[ $j ]} );
      }

      # Check its dimensions.
      $count == $isSigmaDiag ? $nSigma : $nSigma * ( $nSigma + 1 ) / 2
        or die "The dimensions of the Sigma standard errors are not correct.\n";
    }
    elsif ( $nTheta == 4 )
    {
      $SigmaSE->[ 0 ][ 0 ] = pop( @$thetaSE );
    }
    else
    {
      die "This program cannot handle this Theta structure.\n";
    }
  }
  else 
  {
    # Set the elements to indicate the standard errors were not calculated.
    for ( $j = 0; $j < $nSigma; $j++ )
    {
      if ( $isSigmaDiag )
      {
        push @$SigmaSE, [ ( 'no_value' ) x 1 ];
      }
      else
      {
        push @$SigmaSE, [ ( 'no_value' ) x ( $j + 1 ) ];
      }
    }
  }


  #---------------------------------------------------------------
  # Get the NONMEM parameter estimate covariance and correlation matrices.
  #---------------------------------------------------------------

  # These are references to arrays of arrays.
  our $covOfEstOut  = [];
  our $corrOfEstOut = [];

  my $skipThisRow;

  for ( my $isCov = 1; $isCov >= 0; $isCov-- )
  {
    if ( $SEOk eq 'true' )
    {
      $count = 0;

      if ( $isCov )
      {
        # Advance to the beginning of the parameter estimate covariance section.
        while( <FILE> )
        {
          last if ( /COVARIANCE MATRIX OF ESTIMATE/ );
        }
        /COVARIANCE MATRIX OF ESTIMATE/ or die "Parameter estimate covariance not found.\n";
      }
      else
      {
        # Advance to the beginning of the parameter estimate correlation section.
        while( <FILE> )
        {
          last if ( /CORRELATION MATRIX OF ESTIMATE/ );
        }
        /CORRELATION MATRIX OF ESTIMATE/ or die "Parameter estimate correlation not found.\n";
      }

      # Find the lines that contain the parameter estimate covariance
      # or correlation, which have the following form:
      #
      #             TH 1      TH 2      TH 3      OM11      OM12      OM13      OM22      OM23      OM33      SG11
      #
      #  TH 1
      # +        1.00E+00
      #
      #  TH 2
      # +        1.27E-01  1.00E+00
      #
      #  TH 3
      # +        1.57E-01  6.31E-01  1.00E+00
      #
      while( <FILE> )
      {
        last if ( /TH 1|OM11|SG11/ );
      }
      for ( $j = 0; $j < $nFixedEffects; $j++ )
      {
        while( <FILE> )
        {
          last if ( /TH|OM|SG/ );
        }
        while( <FILE> )
        {
          last if ( /^\+\s+/ );
        }

        # Remove the "+ " characters from the beginning of $_.
        s/\+\s+//;

        # Skip this row if all of its elements are equal to ".........".
        # This should only happen if Omega or Sigma is diagonal.
        $skipThisRow = ( /(\.+)+/ and ! /\d+/ );

        if ( $skipThisRow )
        {
          $j--;
        }

        # Remove any occurrences of "........." from $_.
        s/(\.+\s)//;
        s/(\.+\s)//;
        s/(\.+\s)//;
        if ( !$skipThisRow )
        {
          # Get the values for the current row and add in the number 
          # of elements in this row.
          if ( $isCov )
          {
            push @$covOfEstOut, [ split() ];
            $count += scalar( @{$covOfEstOut->[ $j ]} );
          }
          else
          {
            push @$corrOfEstOut, [ split() ];
            $count += scalar( @{$corrOfEstOut->[ $j ]} );
          }
        }
      }

      # Check the dimensions of the covariance or correlation.
      $count == $nFixedEffects * ( $nFixedEffects + 1 ) / 2
       or die "The dimensions of the parameter estimate ".
         ( $isCov ? "covariance" : "correlation" ) ." are not correct.\n";

      if ( $nTheta == 4 )
      {
        my $temp;
        if ( $isCov )
        {
          if ( $nOmega == 3 )
          {
            @$temp->[ 0 ] = @$covOfEstOut->[ 3 ][ 0 ];
            @$temp->[ 1 ] = @$covOfEstOut->[ 3 ][ 1 ];
            @$temp->[ 2 ] = @$covOfEstOut->[ 3 ][ 2 ];
            @$temp->[ 3 ] = @$covOfEstOut->[ 4 ][ 3 ];
            @$temp->[ 4 ] = @$covOfEstOut->[ 5 ][ 3 ];
            @$temp->[ 5 ] = @$covOfEstOut->[ 6 ][ 3 ];
            @$temp->[ 6 ] = @$covOfEstOut->[ 3 ][ 3 ];
            @$covOfEstOut->[ 3 ][ 0 ] = @$covOfEstOut->[ 4 ][ 0 ];
            @$covOfEstOut->[ 3 ][ 1 ] = @$covOfEstOut->[ 4 ][ 1 ];
            @$covOfEstOut->[ 3 ][ 2 ] = @$covOfEstOut->[ 4 ][ 2 ];
            @$covOfEstOut->[ 3 ][ 3 ] = @$covOfEstOut->[ 4 ][ 4 ];
            @$covOfEstOut->[ 4 ][ 0 ] = @$covOfEstOut->[ 5 ][ 0 ];
            @$covOfEstOut->[ 4 ][ 1 ] = @$covOfEstOut->[ 5 ][ 1 ];
            @$covOfEstOut->[ 4 ][ 2 ] = @$covOfEstOut->[ 5 ][ 2 ];
            @$covOfEstOut->[ 4 ][ 3 ] = @$covOfEstOut->[ 5 ][ 4 ];
            @$covOfEstOut->[ 4 ][ 4 ] = @$covOfEstOut->[ 5 ][ 5 ];
            @$covOfEstOut->[ 5 ][ 0 ] = @$covOfEstOut->[ 6 ][ 0 ];
            @$covOfEstOut->[ 5 ][ 1 ] = @$covOfEstOut->[ 6 ][ 1 ];
            @$covOfEstOut->[ 5 ][ 2 ] = @$covOfEstOut->[ 6 ][ 2 ];
            @$covOfEstOut->[ 5 ][ 3 ] = @$covOfEstOut->[ 6 ][ 4 ];
            @$covOfEstOut->[ 5 ][ 4 ] = @$covOfEstOut->[ 6 ][ 5 ];
            @$covOfEstOut->[ 5 ][ 5 ] = @$covOfEstOut->[ 6 ][ 6 ];
            @$covOfEstOut->[ 6 ][ 0 ] = @$temp->[ 0 ];
            @$covOfEstOut->[ 6 ][ 1 ] = @$temp->[ 1 ];
            @$covOfEstOut->[ 6 ][ 2 ] = @$temp->[ 2 ];
            @$covOfEstOut->[ 6 ][ 3 ] = @$temp->[ 3 ];
            @$covOfEstOut->[ 6 ][ 4 ] = @$temp->[ 4 ];
            @$covOfEstOut->[ 6 ][ 5 ] = @$temp->[ 5 ];
            @$covOfEstOut->[ 6 ][ 6 ] = @$temp->[ 6 ];
          }
          elsif ( $nOmega == 6 )
          {
            @$temp->[ 0 ] = @$covOfEstOut->[ 3 ][ 0 ];
            @$temp->[ 1 ] = @$covOfEstOut->[ 3 ][ 1 ];
            @$temp->[ 2 ] = @$covOfEstOut->[ 3 ][ 2 ];
            @$temp->[ 3 ] = @$covOfEstOut->[ 4 ][ 3 ];
            @$temp->[ 4 ] = @$covOfEstOut->[ 5 ][ 3 ];
            @$temp->[ 5 ] = @$covOfEstOut->[ 6 ][ 3 ];
            @$temp->[ 6 ] = @$covOfEstOut->[ 7 ][ 3 ];
            @$temp->[ 7 ] = @$covOfEstOut->[ 8 ][ 3 ];
            @$temp->[ 8 ] = @$covOfEstOut->[ 9 ][ 3 ];
            @$temp->[ 9 ] = @$covOfEstOut->[ 3 ][ 3 ];
            @$covOfEstOut->[ 3 ][ 0 ] = @$covOfEstOut->[ 4 ][ 0 ];
            @$covOfEstOut->[ 3 ][ 1 ] = @$covOfEstOut->[ 4 ][ 1 ];
            @$covOfEstOut->[ 3 ][ 2 ] = @$covOfEstOut->[ 4 ][ 2 ];
            @$covOfEstOut->[ 3 ][ 3 ] = @$covOfEstOut->[ 4 ][ 4 ];
            @$covOfEstOut->[ 4 ][ 0 ] = @$covOfEstOut->[ 5 ][ 0 ];
            @$covOfEstOut->[ 4 ][ 1 ] = @$covOfEstOut->[ 5 ][ 1 ];
            @$covOfEstOut->[ 4 ][ 2 ] = @$covOfEstOut->[ 5 ][ 2 ];
            @$covOfEstOut->[ 4 ][ 3 ] = @$covOfEstOut->[ 5 ][ 4 ];
            @$covOfEstOut->[ 4 ][ 4 ] = @$covOfEstOut->[ 5 ][ 5 ];
            @$covOfEstOut->[ 5 ][ 0 ] = @$covOfEstOut->[ 6 ][ 0 ];
            @$covOfEstOut->[ 5 ][ 1 ] = @$covOfEstOut->[ 6 ][ 1 ];
            @$covOfEstOut->[ 5 ][ 2 ] = @$covOfEstOut->[ 6 ][ 2 ];
            @$covOfEstOut->[ 5 ][ 3 ] = @$covOfEstOut->[ 6 ][ 4 ];
            @$covOfEstOut->[ 5 ][ 4 ] = @$covOfEstOut->[ 6 ][ 5 ];
            @$covOfEstOut->[ 5 ][ 5 ] = @$covOfEstOut->[ 6 ][ 6 ];
            @$covOfEstOut->[ 6 ][ 0 ] = @$covOfEstOut->[ 7 ][ 0 ];
            @$covOfEstOut->[ 6 ][ 1 ] = @$covOfEstOut->[ 7 ][ 1 ];
            @$covOfEstOut->[ 6 ][ 2 ] = @$covOfEstOut->[ 7 ][ 2 ];
            @$covOfEstOut->[ 6 ][ 3 ] = @$covOfEstOut->[ 7 ][ 4 ];
            @$covOfEstOut->[ 6 ][ 4 ] = @$covOfEstOut->[ 7 ][ 5 ];
            @$covOfEstOut->[ 6 ][ 5 ] = @$covOfEstOut->[ 7 ][ 6 ];
            @$covOfEstOut->[ 6 ][ 6 ] = @$covOfEstOut->[ 7 ][ 7 ];
            @$covOfEstOut->[ 7 ][ 0 ] = @$covOfEstOut->[ 8 ][ 0 ];
            @$covOfEstOut->[ 7 ][ 1 ] = @$covOfEstOut->[ 8 ][ 1 ];
            @$covOfEstOut->[ 7 ][ 2 ] = @$covOfEstOut->[ 8 ][ 2 ];
            @$covOfEstOut->[ 7 ][ 3 ] = @$covOfEstOut->[ 8 ][ 4 ];
            @$covOfEstOut->[ 7 ][ 4 ] = @$covOfEstOut->[ 8 ][ 5 ];
            @$covOfEstOut->[ 7 ][ 5 ] = @$covOfEstOut->[ 8 ][ 6 ];
            @$covOfEstOut->[ 7 ][ 6 ] = @$covOfEstOut->[ 8 ][ 7 ];
            @$covOfEstOut->[ 7 ][ 7 ] = @$covOfEstOut->[ 8 ][ 8 ];
            @$covOfEstOut->[ 8 ][ 0 ] = @$covOfEstOut->[ 9 ][ 0 ];
            @$covOfEstOut->[ 8 ][ 1 ] = @$covOfEstOut->[ 9 ][ 1 ];
            @$covOfEstOut->[ 8 ][ 2 ] = @$covOfEstOut->[ 9 ][ 2 ];
            @$covOfEstOut->[ 8 ][ 3 ] = @$covOfEstOut->[ 9 ][ 4 ];
            @$covOfEstOut->[ 8 ][ 4 ] = @$covOfEstOut->[ 9 ][ 5 ];
            @$covOfEstOut->[ 8 ][ 5 ] = @$covOfEstOut->[ 9 ][ 6 ];
            @$covOfEstOut->[ 8 ][ 6 ] = @$covOfEstOut->[ 9 ][ 7 ];
            @$covOfEstOut->[ 8 ][ 7 ] = @$covOfEstOut->[ 9 ][ 8 ];
            @$covOfEstOut->[ 8 ][ 8 ] = @$covOfEstOut->[ 9 ][ 9 ];
            @$covOfEstOut->[ 9 ][ 0 ] = @$temp->[ 0 ];
            @$covOfEstOut->[ 9 ][ 1 ] = @$temp->[ 1 ];
            @$covOfEstOut->[ 9 ][ 2 ] = @$temp->[ 2 ];
            @$covOfEstOut->[ 9 ][ 3 ] = @$temp->[ 3 ];
            @$covOfEstOut->[ 9 ][ 4 ] = @$temp->[ 4 ];
            @$covOfEstOut->[ 9 ][ 5 ] = @$temp->[ 5 ];
            @$covOfEstOut->[ 9 ][ 6 ] = @$temp->[ 6 ];
            @$covOfEstOut->[ 9 ][ 7 ] = @$temp->[ 7 ];
            @$covOfEstOut->[ 9 ][ 8 ] = @$temp->[ 8 ];
            @$covOfEstOut->[ 9 ][ 9 ] = @$temp->[ 9 ];
          }
          else
          {
            die "This program cannot handle this Omega structure.\n";
          }
        }
        else
        {
          if ( $nOmega == 3 )
          {
            @$temp->[ 0 ] = @$corrOfEstOut->[ 3 ][ 0 ];
            @$temp->[ 1 ] = @$corrOfEstOut->[ 3 ][ 1 ];
            @$temp->[ 2 ] = @$corrOfEstOut->[ 3 ][ 2 ];
            @$temp->[ 3 ] = @$corrOfEstOut->[ 4 ][ 3 ];
            @$temp->[ 4 ] = @$corrOfEstOut->[ 5 ][ 3 ];
            @$temp->[ 5 ] = @$corrOfEstOut->[ 6 ][ 3 ];
            @$temp->[ 6 ] = @$corrOfEstOut->[ 3 ][ 3 ];
            @$corrOfEstOut->[ 3 ][ 0 ] = @$corrOfEstOut->[ 4 ][ 0 ];
            @$corrOfEstOut->[ 3 ][ 1 ] = @$corrOfEstOut->[ 4 ][ 1 ];
            @$corrOfEstOut->[ 3 ][ 2 ] = @$corrOfEstOut->[ 4 ][ 2 ];
            @$corrOfEstOut->[ 3 ][ 3 ] = @$corrOfEstOut->[ 4 ][ 4 ];
            @$corrOfEstOut->[ 4 ][ 0 ] = @$corrOfEstOut->[ 5 ][ 0 ];
            @$corrOfEstOut->[ 4 ][ 1 ] = @$corrOfEstOut->[ 5 ][ 1 ];
            @$corrOfEstOut->[ 4 ][ 2 ] = @$corrOfEstOut->[ 5 ][ 2 ];
            @$corrOfEstOut->[ 4 ][ 3 ] = @$corrOfEstOut->[ 5 ][ 4 ];
            @$corrOfEstOut->[ 4 ][ 4 ] = @$corrOfEstOut->[ 5 ][ 5 ];
            @$corrOfEstOut->[ 5 ][ 0 ] = @$corrOfEstOut->[ 6 ][ 0 ];
            @$corrOfEstOut->[ 5 ][ 1 ] = @$corrOfEstOut->[ 6 ][ 1 ];
            @$corrOfEstOut->[ 5 ][ 2 ] = @$corrOfEstOut->[ 6 ][ 2 ];
            @$corrOfEstOut->[ 5 ][ 3 ] = @$corrOfEstOut->[ 6 ][ 4 ];
            @$corrOfEstOut->[ 5 ][ 4 ] = @$corrOfEstOut->[ 6 ][ 5 ];
            @$corrOfEstOut->[ 5 ][ 5 ] = @$corrOfEstOut->[ 6 ][ 6 ];
            @$corrOfEstOut->[ 6 ][ 0 ] = @$temp->[ 0 ];
            @$corrOfEstOut->[ 6 ][ 1 ] = @$temp->[ 1 ];
            @$corrOfEstOut->[ 6 ][ 2 ] = @$temp->[ 2 ];
            @$corrOfEstOut->[ 6 ][ 3 ] = @$temp->[ 3 ];
            @$corrOfEstOut->[ 6 ][ 4 ] = @$temp->[ 4 ];
            @$corrOfEstOut->[ 6 ][ 5 ] = @$temp->[ 5 ];
            @$corrOfEstOut->[ 6 ][ 6 ] = @$temp->[ 6 ];
          }
          elsif ( $nOmega == 6 )
          {
            @$temp->[ 0 ] = @$corrOfEstOut->[ 3 ][ 0 ];
            @$temp->[ 1 ] = @$corrOfEstOut->[ 3 ][ 1 ];
            @$temp->[ 2 ] = @$corrOfEstOut->[ 3 ][ 2 ];
            @$temp->[ 3 ] = @$corrOfEstOut->[ 4 ][ 3 ];
            @$temp->[ 4 ] = @$corrOfEstOut->[ 5 ][ 3 ];
            @$temp->[ 5 ] = @$corrOfEstOut->[ 6 ][ 3 ];
            @$temp->[ 6 ] = @$corrOfEstOut->[ 7 ][ 3 ];
            @$temp->[ 7 ] = @$corrOfEstOut->[ 8 ][ 3 ];
            @$temp->[ 8 ] = @$corrOfEstOut->[ 9 ][ 3 ];
            @$temp->[ 9 ] = @$corrOfEstOut->[ 3 ][ 3 ];
            @$corrOfEstOut->[ 3 ][ 0 ] = @$corrOfEstOut->[ 4 ][ 0 ];
            @$corrOfEstOut->[ 3 ][ 1 ] = @$corrOfEstOut->[ 4 ][ 1 ];
            @$corrOfEstOut->[ 3 ][ 2 ] = @$corrOfEstOut->[ 4 ][ 2 ];
            @$corrOfEstOut->[ 3 ][ 3 ] = @$corrOfEstOut->[ 4 ][ 4 ];
            @$corrOfEstOut->[ 4 ][ 0 ] = @$corrOfEstOut->[ 5 ][ 0 ];
            @$corrOfEstOut->[ 4 ][ 1 ] = @$corrOfEstOut->[ 5 ][ 1 ];
            @$corrOfEstOut->[ 4 ][ 2 ] = @$corrOfEstOut->[ 5 ][ 2 ];
            @$corrOfEstOut->[ 4 ][ 3 ] = @$corrOfEstOut->[ 5 ][ 4 ];
            @$corrOfEstOut->[ 4 ][ 4 ] = @$corrOfEstOut->[ 5 ][ 5 ];
            @$corrOfEstOut->[ 5 ][ 0 ] = @$corrOfEstOut->[ 6 ][ 0 ];
            @$corrOfEstOut->[ 5 ][ 1 ] = @$corrOfEstOut->[ 6 ][ 1 ];
            @$corrOfEstOut->[ 5 ][ 2 ] = @$corrOfEstOut->[ 6 ][ 2 ];
            @$corrOfEstOut->[ 5 ][ 3 ] = @$corrOfEstOut->[ 6 ][ 4 ];
            @$corrOfEstOut->[ 5 ][ 4 ] = @$corrOfEstOut->[ 6 ][ 5 ];
            @$corrOfEstOut->[ 5 ][ 5 ] = @$corrOfEstOut->[ 6 ][ 6 ];
            @$corrOfEstOut->[ 6 ][ 0 ] = @$corrOfEstOut->[ 7 ][ 0 ];
            @$corrOfEstOut->[ 6 ][ 1 ] = @$corrOfEstOut->[ 7 ][ 1 ];
            @$corrOfEstOut->[ 6 ][ 2 ] = @$corrOfEstOut->[ 7 ][ 2 ];
            @$corrOfEstOut->[ 6 ][ 3 ] = @$corrOfEstOut->[ 7 ][ 4 ];
            @$corrOfEstOut->[ 6 ][ 4 ] = @$corrOfEstOut->[ 7 ][ 5 ];
            @$corrOfEstOut->[ 6 ][ 5 ] = @$corrOfEstOut->[ 7 ][ 6 ];
            @$corrOfEstOut->[ 6 ][ 6 ] = @$corrOfEstOut->[ 7 ][ 7 ];
            @$corrOfEstOut->[ 7 ][ 0 ] = @$corrOfEstOut->[ 8 ][ 0 ];
            @$corrOfEstOut->[ 7 ][ 1 ] = @$corrOfEstOut->[ 8 ][ 1 ];
            @$corrOfEstOut->[ 7 ][ 2 ] = @$corrOfEstOut->[ 8 ][ 2 ];
            @$corrOfEstOut->[ 7 ][ 3 ] = @$corrOfEstOut->[ 8 ][ 4 ];
            @$corrOfEstOut->[ 7 ][ 4 ] = @$corrOfEstOut->[ 8 ][ 5 ];
            @$corrOfEstOut->[ 7 ][ 5 ] = @$corrOfEstOut->[ 8 ][ 6 ];
            @$corrOfEstOut->[ 7 ][ 6 ] = @$corrOfEstOut->[ 8 ][ 7 ];
            @$corrOfEstOut->[ 7 ][ 7 ] = @$corrOfEstOut->[ 8 ][ 8 ];
            @$corrOfEstOut->[ 8 ][ 0 ] = @$corrOfEstOut->[ 9 ][ 0 ];
            @$corrOfEstOut->[ 8 ][ 1 ] = @$corrOfEstOut->[ 9 ][ 1 ];
            @$corrOfEstOut->[ 8 ][ 2 ] = @$corrOfEstOut->[ 9 ][ 2 ];
            @$corrOfEstOut->[ 8 ][ 3 ] = @$corrOfEstOut->[ 9 ][ 4 ];
            @$corrOfEstOut->[ 8 ][ 4 ] = @$corrOfEstOut->[ 9 ][ 5 ];
            @$corrOfEstOut->[ 8 ][ 5 ] = @$corrOfEstOut->[ 9 ][ 6 ];
            @$corrOfEstOut->[ 8 ][ 6 ] = @$corrOfEstOut->[ 9 ][ 7 ];
            @$corrOfEstOut->[ 8 ][ 7 ] = @$corrOfEstOut->[ 9 ][ 8 ];
            @$corrOfEstOut->[ 8 ][ 8 ] = @$corrOfEstOut->[ 9 ][ 9 ];
            @$corrOfEstOut->[ 9 ][ 0 ] = @$temp->[ 0 ];
            @$corrOfEstOut->[ 9 ][ 1 ] = @$temp->[ 1 ];
            @$corrOfEstOut->[ 9 ][ 2 ] = @$temp->[ 2 ];
            @$corrOfEstOut->[ 9 ][ 3 ] = @$temp->[ 3 ];
            @$corrOfEstOut->[ 9 ][ 4 ] = @$temp->[ 4 ];
            @$corrOfEstOut->[ 9 ][ 5 ] = @$temp->[ 5 ];
            @$corrOfEstOut->[ 9 ][ 6 ] = @$temp->[ 6 ];
            @$corrOfEstOut->[ 9 ][ 7 ] = @$temp->[ 7 ];
            @$corrOfEstOut->[ 9 ][ 8 ] = @$temp->[ 8 ];
            @$corrOfEstOut->[ 9 ][ 9 ] = @$temp->[ 9 ];
          }
          else
          {
            die "This program cannot handle this Omega structure.\n";
          }
        }
      }
    }
    else 
    {
      # Set the elements to indicate the standard errors were not calculated.
      for ( $j = 0; $j < $nFixedEffects; $j++ )
      {
        if ( $isCov )
        {
          push @$covOfEstOut,  [ ( 'no_value' ) x ( $j + 1 ) ];
        }
        else
        {
          push @$corrOfEstOut, [ ( 'no_value' ) x ( $j + 1 ) ];
        }
      }

    }
  }


  #---------------------------------------------------------------
  # Advance to the beginning of the tables of values section.
  #---------------------------------------------------------------

  while( <FILE> )
  {
    last if ( /TABLES OF DATA AND PREDICTIONS/ );
  }

  /TABLES OF DATA AND PREDICTIONS/ or die "Tables of values not found.\n";


  #---------------------------------------------------------------
  # Get the NONMEM individuals' objective minimizers and data mean model values.
  #---------------------------------------------------------------

  # These are references to arrays of arrays.
  my  $etaForAllTrans = [];
  our $etaForAllOut   = [];
  our $predForAllOut  = [];

  my $nEta = $nOmega;

  # Advance to the beginning of the table that contains the 
  # individuals' objective minimizers and data mean model values.
  # It has the following line of column headings:
  #
  #  LINE NO.     ID      ETA1      ETA2      ETA3      IPRE        CP      PRED      RES       WRES
  #
  while( <FILE> )
  {
    last if ( /ID\s+(ETA\w+\s+)+\s+IPRE/ );
  }
  /ID\s+(ETA\w+\s+)+\s+IPRE/ or die "Table of objective minimizers and model values not found.\n";

  # Check the number of eta columns.
  $count = 0;
  while ( /ETA\w/g )
  {
    $count++;
  }
  $count == $nEta or die "Wrong number of eta columns in the table.\n";

  # Set the positions of the values in the array of values that will 
  # be extracted from each line.
  my $idPos    = 0;
  my $etaBegin = 1;
  my $etaEnd   = $etaBegin + $nEta - 1;
  my $ipredPos = $etaEnd   + 1;
  my $cpPos    = $ipredPos + 1;

  $i = 0;

  my $indCurr  = 0;
  my $indPrev  = 0;

  # Find the lines that contain the individuals' objective minimizers
  # and data mean model values, which have the following form:
  #
  #  LINE NO.     ID      ETA1      ETA2      ETA3      IPRE        CP      PRED      RES       WRES
  #
  #     1
  # +        1.00E+00 -1.19E-01 -7.31E-03  3.81E-01  0.00E+00  0.00E+00  0.00E+00  0.00E+00  0.00E+00
  #
  #     2
  # +        1.00E+00 -1.19E-01 -7.31E-03  3.81E-01  0.00E+00  5.07E-01  0.00E+00  5.07E-01  7.99E-01
  #
  #     3
  # +        1.00E+00 -1.19E-01 -7.31E-03  3.81E-01  3.37E+00  4.40E+00  4.25E+00  1.43E-01  1.40E+00 
  #
  #                                           .
  #                                           .
  #                                           .
  #
  #    24
  # +        2.00E+00  1.72E+00  1.13E-02 -1.05E-01  7.89E+00  9.14E+00  6.86E+00  2.28E+00  2.32E+00
  #
  #    25
  # +        2.00E+00  1.72E+00  1.13E-02 -1.05E-01  7.22E+00  6.83E+00  6.36E+00  4.64E-01 -3.24E-01
  #
  # 1
  #
  #  LINE NO.     ID      ETA1      ETA2      ETA3      IPRE        CP      PRED      RES       WRES
  #
  #    26
  # +        2.00E+00  1.72E+00  1.13E-02 -1.05E-01  6.70E+00  7.14E+00  5.96E+00  1.18E+00  9.29E-01
  #
  #    27
  # +        2.00E+00  1.72E+00  1.13E-02 -1.05E-01  5.97E+00  5.70E+00  5.39E+00  3.08E-01 -2.62E-01
  #
  TABLE_LOOP: while( /ID\s+(ETA\w+\s+)+\s+IPRE/ )
  {
    TABLE_PAGE_LOOP: while( <FILE> )
    {
      while( <FILE> )
      {
        # Exit this loop once the line of values is reached.
        last if ( /^\+\s+/ );

        # If the end of the page of table values has been reached, then
        # advance to the beginning of the next page of values for this
        # table, or to the beginning of the next table, or to the next 
        # section of the NONMEM output file.
        if ( /^1/ )
        {
          while( <FILE> )
          {
            last TABLE_PAGE_LOOP if ( /ID\s+(ETA\w+\s+)+\s+IPRE/ );
            last TABLE_LOOP      if ( /TABLE NO/ or /\*{10,}/ );
          }
        }
      }

      # Go on if the end of the file has been reached.
      last TABLE_LOOP unless $_;

      # Remove the "+ " characters from the beginning of $_.
      s/\+\s+//;

      # Get all of the values from the current line.
      @dummy = split();

      # Set the current individual.
      $indCurr = $dummy[ $idPos ];

      # Check to see if the individual has changed.
      if ( $indCurr != $indPrev )
      {
        # This module assumes the individuals' ID values are sequential
        # and that they start at 1.  Thus, it does not save their ID
        # values and does not export them to calling modules.
        $indCurr == $indPrev + 1 
          or die "The individuals' ID values are not sequential and/or don't start at 1.\n"; 

        # Set this individual's eta values.
        push @$etaForAllTrans,  [ @dummy[ $etaBegin..$etaEnd ] ];

        # Add a new array for this individual's data mean model values.
        push @$predForAllOut, [];

        $indPrev = $indCurr;
        $i       = $indCurr - 1;
      }

      # If the data value (CP column) isn't zero, than set the data 
      # mean model value for this data value.
      if ( $dummy[ $cpPos ] != 0.0 )
      {
        push @{$predForAllOut->[ $i ]}, $dummy[ $ipredPos ];
      }
    }
  }

  # Get the number of individuals.
  my $nInd  = scalar( @{$etaForAllTrans} );

  # Create a transposed version of the matrix of eta values.
  for ( $j = 0; $j < $nEta; $j++ )
  {
    push @$etaForAllOut, [];
  }
  for ( $i = 0; $i < $nInd; $i++ )
  {
    for ( $j = 0; $j < $nEta; $j++ )
    {
      push @{$etaForAllOut->[ $j ]}, $etaForAllTrans->[ $i ][ $j ];
    }
  }


  #---------------------------------------------------------------
  # Finish up.
  #---------------------------------------------------------------

  if ( $nTheta == 4 )
  {
    $nTheta = 3;
  }

  # Close the NONMEM output file.
  close FILE;

}


#*********************************************************************************
#
# Module return value.
#
#*********************************************************************************

1;
