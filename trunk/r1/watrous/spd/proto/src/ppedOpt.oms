# ---------------------------------------------------------------------
# File: ppedOpt.oms
#
#
# Optimizes the modified Laplace approximation for the population
# expected determinant optimal design criterion.
#
# Author: Mitch Watrous
# 
# ---------------------------------------------------------------------

#begin##

$begin ppedOpt$$
$escape #$$

$spell
  cg
  covariance
  df
  dx
  eps
  epsline
  fval
  Hessian
  Info
  itr
  Laplace
  mod
  mitr
  ndir
  ok
  opt
  pped
  ppka
  Ri
  Rval
  Std
  subvector
  const
  sqrt
  snormal
  seq
$$

$section Optimization of the Population Expected Determinant Criterion$$

$index ppedOpt$$
$cindex optimization #of #the population expected determinant criterion$$

$table
$bold Syntax:$$ $cend
$syntax/ppedOpt( ...
  function /Model/, ...
  /K/, ...
  /eps/, ...
  /delta/, ...
  /mitr/, ...
  /level/, ...
  /xStep/, /xLow/, /xUp/, /xIn/, /xOut/,...
  /alpStep/, /alpLow/, /alpUp/, /alpIn/, /alpOut/,...
  /bLength/, ...
  /phiTildeOut/, /phiTilde_xOut/, /phiTilde_x_xOut/  ...
)/$$

$tend

$fend 25$$

$head Description$$
Determines the design vector $math%x%$$ that
maximizes the modified Laplace approximation for
the parametric population expected determinant criterion
$math%

                     +infinity
                    /\
                    \                      
    phiTilde(x)  =   \        p(alp) #det[ HTilde(x, alp) ] dalp  .
                    \/
                     -infinity

%$$
In this expression, $math%p(alp)%$$ is the prior distribution of the
value of $math%alp%$$, $xref/HTilde//HTilde(x, alp)/$$ is an approximation for
the information matrix corresponding to the negative log-likelihood
of all of the data, 
and $math%alp%$$ is the value for the fixed population parameter vector.
$pre

$$
The full design parameter vector $math%x%$$ contains the design vectors 
$math%x_i%$$ for all $math%M%$$ of the individuals in the population 
together with $math%x_common%$$, which is a vector of design 
parameters common to all of the individuals.
That is,
$math%
           -          -
          |  x_1       |
          |  x_2       |
          |   .        |
    x  =  |   .        |  .
          |   .        |
          |  x_M       |
          |  x_common  |
           -          -

%$$
The combination of parameters that each individuals' model functions will
depend on is denoted by
$math%
               -          -
    chi_i  =  |  x_i       |  .
              |  x_common  |
               -          -

%$$

The approximate information matrix $math%HTilde(x, alp)%$$ is defined as
$math%

                        M
                       ----   
    HTilde(x, alp)  =  >      HTilde_i(chi_i, alp)  ,
                       ----
                       i = 1

%$$
where the contribution from each individual is given by
replacing the derivatives with respect to the fixed population 
parameter $math%alp%$$ by central difference approximations
in the definition of
$math%

    HTilde_i(chi_i, alp)

                                      T         -1            
        =  fTilde_i_alp(chi_i, alp, 0)  VTilde_i  (chi_i, alp)  fTilde_i_alp(chi_i, alp, 0)

           1                         T               -1                      -1             
        +  - VTilde_i_alp(chi_i, alp)  kron[ VTilde_i  (chi_i, alp), VTilde_i  (xTilde_i, alp) ] VTilde_i_alp(chi_i, alp)  ,
           2
%$$
and where
$math%

    VTilde_i(chi_i, alp)  =  RTilde_i(chi_i, alp)

                                                                       T
        +  fTilde_i_b(chi_i, alp, 0)  D(alp)  fTilde_i_b(chi_i, alp, 0)  .
%$$

$head Notes$$
(1.) This function makes the following first order approximation
for the model for the mean of the $th i$$ individual's data,
$math%

    fTilde_i(chi_i, alp, b_i)  =  f_i(chi_i, alp, 0)  +  f_i_b(chi_i, alp, 0) * b_i  ,

%$$
where $math%f_i_b(chi_i, alp, b_i)%$$ is the derivative of 
$math%f_i(chi_i, alp, b_i)%$$ with respect to the random effect 
vector $math%b_i%$$.
$pre

$$
(2.) This function makes the following approximation for the
model for the covariance of the $th i$$ individual's data,
$math%

    RTilde_i(chi_i, alp)  =  R_i(chi_i, alp, 0)  .
%$$
$pre

$$
(3.) This function requires the model function to provide the
following second derivatives of $math%f_i(chi_i, alp, b_i)%$$
$math%

  f_i_b_chi(chi_i, alp, b_i)  ,

  f_i_b_alp(chi_i, alp, b_i)  .
%$$
$pre

$$
(4.) The number of individuals in the population, $math%M%$$, is 
determined by subtracting one from the number of elements in the 
argument $italic K$$, which is a column vector containing 
information about the partitioning of the elements in $italic x$$.

$head Reference$$
B. M. Bell, $italic Approximating The Marginal Likelihood Estimate 
For Models With Random Parameters$$, Applied Mathematics and Computation,
119 (2001), pp. 57-73. 

$head Model Assumptions$$
The following model assumptions are stated using 
$xref/glossary/Population Notation/population notation/$$.
The bar above $math%chi_i%$$, $math%alp%$$, and $math%b_i%$$ denote 
the true, but unknown, values for the design parameters, 
the fixed population parameters, and the random population 
parameters for the $th i$$ individual, respectively.
$math%
             _____  ___   ___
  y_i = f_i( chi_i, alp , b_i ) + e_i
                  _____  ___  ___
  e_i ~ N[0, R_i( chi_i, alp, b_i)]
  ___          ___
  b_i ~ N[0, D(alp)]
%$$

$head Return Values$$
The return value of $code ppedOpt$$ 
is true, if it succeeds, and false otherwise.

$head Arguments$$
$syntax//Model/(/i/, /chi/, /alp/, /b/, /fOut/, /f_chiOut/, /f_alpOut/, /f_bOut/, /f_b_chiOut/, /f_b_alpOut/, 
    /ROut/, /R_chiOut/, /R_alpOut/, /R_bOut/, /DOut/, /D_alpOut/, /pOut/, /p_alpOut/)
/$$
The return value of $italic Model$$ is true if it succeeds and false otherwise.
All the arguments to this routine have real or double-precision values. In addition,
the arguments that end in $italic Out$$ are $xref/glossary/Output Value/output values/$$.
$pre

$$
$center
$table
$bold Argument$$
  $cend $bold Value$$ 
  $cend $bold Comments$$ $rend
$italic i$$
  $cend $math%i%$$
  $cend index for this individual $rend
$italic chi$$
  $cend $math%chi_i%$$
  $cend design parameter vector for this individual combined with the
          design parameter vector common to all individuals $rend
$italic alp$$
  $cend $math%alp%$$
  $cend fixed population parameter vector $rend
$italic b$$
  $cend $math%b_i%$$
  $cend random population parameter vector for this individual $rend
$italic fOut$$
  $cend $math%f_i(chi_i, alp, b_i)%$$ 
  $cend model for the mean of $math%y_i%$$ given $math%b_i%$$ $rend
$italic f_chiOut$$ 
  $cend $math%f_i_chi(chi_i, alp, b_i)%$$
  $cend derivative of $math%f_i(chi_i, alp, b_i)%$$ with respect to $math%chi_i%$$ $rend
$italic f_alpOut$$ 
  $cend $math%f_i_alp(chi_i, alp, b_i)%$$ 
  $cend derivative of $math%f_i(chi_i, alp, b_i)%$$ with respect to $math%alp%$$ $rend
$italic f_bOut$$ 
  $cend $math%f_i_b(chi_i, alp, b_i)%$$ 
  $cend derivative of $math%f_i(chi_i, alp, b_i)%$$ with respect to $math%b_i%$$ $rend
$italic f_b_chiOut$$ 
  $cend $math%f_i_b_chi(chi_i, alp, b_i)%$$ 
  $cend derivative of $math%f_i_b(chi_i, alp, b_i)%$$ with respect to $math%chi_i%$$ $rend
$italic f_b_alpOut$$ 
  $cend $math%f_i_b_alp(chi_i, alp, b_i)%$$ 
  $cend derivative of $math%f_i_b(chi_i, alp, b_i)%$$ with respect to $math%alp%$$ $rend
$italic ROut$$ 
  $cend $math%R_i(chi_i, alp, b_i)%$$ 
  $cend model for the variance of $math%y_i%$$ given $math%b_i%$$ $rend
$italic R_chiOut$$ 
  $cend $math%R_i_chi(chi_i, alp, b_i)%$$
  $cend derivative of $math%R_i(chi_i, alp, b_i)%$$ with respect to $math%chi_i%$$ $rend
$italic R_alpOut$$
  $cend $math%R_i_alp(chi_i, alp, b_i)%$$ 
  $cend derivative of $math%R_i(chi_i, alp, b_i)%$$ with respect to $math%alp%$$ $rend
$italic R_bOut$$
  $cend $math%R_i_b(chi_i, alp, b_i)%$$ 
  $cend derivative of $math%R_i(chi_i, alp, b_i)%$$ with respect to $math%b_i%$$ $rend
$italic DOut$$ 
  $cend $math%D(alp)%$$ 
  $cend model for the variance of $math%b_i%$$ $rend
$italic D_alpOut$$
  $cend $math%D_alp(alp)%$$ 
  $cend derivative of $math%D(alp)%$$ with respect to $math%alp%$$ $rend
$italic pOut$$ 
  $cend $math%p(alp)%$$ 
  $cend model for the prior distribution of $math%alp%$$ $rend
$italic p_alpOut$$
  $cend $math%p_alp(alp)%$$ 
  $cend derivative of $math%p(alp)%$$ with respect to $math%alp%$$
$tend
$$

$syntax/
/K/
/$$
The $th i$$ element of the integer column vector $italic K$$
specifies $math%K(i)%$$, the number of elements of $italic x$$ that
correspond to the $th i$$ individual.
The last element in $italic K$$ specifies $math%K_common%$$,
the number of elements of $italic x$$ that
are common to all of the individuals in the population.
The number of elements in $italic K$$ should be one more than
the number of individuals in the population, $math%M%$$,
since the length of $italic K$$ minus one specifies $math%M%$$.
$pre

$$
To be specific, the vector $italic x$$ should have
$math%

  K(1) + K(2) + ... + K(M) + K_common

%$$
elements.  
The design vector corresponding to the first individual is
$math%
                                       T
  x_1 = [ x(1) , x(2) , ... , x(K(1)) ]   .

%$$
Elements $math%x(K(1) + 1)%$$ through $math%x(K(1) + K(2))%$$ 
correspond to the second individual and so on.
The last $math%K_common%$$ elements make up $math%x_common%$$.
(Note that $math%x_1%$$ refers to the first subvector or $italic x$$ while
$math%x(1)%$$ refers to the first element of the vector $italic x$$.)

$syntax/

/eps/(1)
/$$
Is a double-precision scalar greater than zero. 
A fixed population parameter value $math%alp0%$$ is 
accepted as the point at which to make the Laplace 
approximation when 
$math%
	abs(alp0 - alpHat) #le eps(1) (alpUp - alpLow)
%$$
where $math%abs%$$ is the element-by-element absolute value function
and $math%alpHat%$$ is the true minimizer with respect to $math%alp%$$ of 
$xref/Lambda//Lambda(x, alp)/$$, 
the negative logarithm of the integrand that appears in the 
population expected determinant optimal design criterion.
This is a rough approximation that is quick to
calculate during the optimization procedure.
$syntax/

/eps/(2)
/$$
Is a double-precision scalar greater than zero. 
A design parameter value $math%xOut%$$ is 
accepted as close enough to optimal if 
$math%
	abs(xOut - xHat) #le eps(2) (xUp - xLow)
%$$
where $math%abs%$$ is the element-by-element absolute value function
and $math%xHat%$$ is the true maximizer of 
the Laplace approximation for the population optimal design criterion.
This is a rough approximation that is quick to
calculate during the optimization procedure.
$syntax/

/delta/(1)
/$$
is a double-precision scalar greater than zero.
A fixed population parameter value $math%alp0%$$ is 
accepted as the point at which to make the Laplace or Expected
Hessian approximation when
$math%
	Lambda(x, alp0) - Lambda(x, alpHat) #le delta
%$$
where $math%alpHat%$$ is its true minimizer of 
$xref/Lambda//Lambda(x, alp)/$$, 
the negative logarithm of the integrand that appears in the 
population expected determinant optimal design criterion.
$syntax/

/delta/(2)
/$$
is a double-precision scalar greater than zero.
A design parameter value $math%xOut%$$ is 
accepted as close enough to optimal if
$math%
	phiTilde(xOut) - phiTilde(xHat) #le delta
%$$
where $math%phiTilde(x)%$$ 
is the Laplace approximation for the population 
optimal design criterion and
$math%xHat%$$ is the true minimizer of $math%phiTilde(x)%$$.
$syntax/

/mitr/(1)
/$$
this integer scalar specifies the maximum number of 
iterations to attempt before giving up on convergence
of the fixed population parameter values.
$syntax/

/mitr/(2)
/$$
this integer scalar specifies the maximum number of 
iterations to attempt before giving up on convergence
of the design parameter values.
$syntax/

/level/
/$$
this integer vector specifies the amount of tracing during the
determination of the optimal design parameter values and the 
determination of the optimal population parameter values.
Note that the objective function for the design parameter 
optimization problem is the negative logarithm of the 
Laplace approximation for the population optimal design criterion,
while the objective function for the population parameter 
optimization problem is the negative logarithm of the
integrand that appears in the population expected determinant 
optimal design criterion.
$math%level(1)%$$ corresponds to the fixed population parameters
and $math%level(2)%$$ corresponds to the design parameters.
$math%
level(j) #ge 1
%$$
the current value of the objective that corresponds to $math%j%$$ is printed
with the label $code f$$ and the norm of the gradient is
printed with the label $code |g|$$ 
(not including the constrained directions in the gradient).
In addition, the total time between calling the objective and its
return is printed.
$math%
level(j) #ge 2
%$$
the current value of the parameter that corresponds to $math%j%$$ is 
printed with the label $code x$$, and the gradient of the
objective is printed with the label $code g$$
(not including the constrained directions in the gradient).
$math%
level(j) #ge 3
%$$
the step size and function values that corresponds to $math%j%$$ are traced
during each line search procedure.
$math%
level(j) #ge 4
%$$
the analytic derivative of the objective function 
that corresponds to $math%j%$$ 
with respect to the
parameters is compared with its numerical approximation.
$syntax/

/xStep/
/$$
The double-precision column vector $italic xStep$$
specifies the step size used for approximating
the derivatives with respect to the design parameters.
The value of this parameter does not matter unless
$italic phiTilde_x_xOut$$ is true.
$syntax/

/xLow/
/$$
is a double-precision column vector with the same length as $italic xIn$$
specifying the lower limit for $italic x$$ during the optimization.
$syntax/

/xUp/
/$$
is a double-precision column vector with the same length as $italic xIn$$
specifying the upper limit for $italic x$$ during the optimization.
$syntax/

/xIn/
/$$
is a double-precision column vector specifying the initial value
for the design parameters.
The $xref/glossary/Ordering Of Vectors/order condition/$$
$math%xLow \le xIn \le xUp%$$ is assumed to hold.
$syntax/

/xOut/
/$$
The $xref/glossary/Output Value/output value/$$ of $italic xOut$$
is a double-precision column vector containing the approximate
maximizer of the Laplace approximation for the population 
optimal design criterion.
$syntax/

/alpStep/
/$$
The double-precision column vector $italic alpStep$$
specifies the step size used for approximating
the derivatives with respect to the fixed population parameters.
$syntax/

/alpLow/
/$$
is a double-precision column vector with the same length as $italic alpIn$$
specifying the lower limit for $italic alp$$ during the optimization.
$syntax/

/alpUp/
/$$
is a double-precision column vector with the same length as $italic alpIn$$
specifying the upper limit for $italic alp$$ during the optimization.
$syntax/

/alpIn/
/$$
is a double-precision column vector specifying the initial value
for the fixed population parameters.
The $xref/glossary/Ordering Of Vectors/order condition/$$
$math%alpLow \le alpIn \le alpUp%$$ is assumed to hold.
$syntax/

/alpOut/
/$$
The $xref/glossary/Output Value/output value/$$ of $italic alpOut$$
is a double-precision column vector containing the approximate
minimizer of $xref/Lambda//Lambda(x, alp)/$$, 
the negative logarithm of the integrand that appears in the 
population expected determinant optimal design criterion.
This is under the assumption that $italic xOut$$
is the true value for the design parameters.
The values $math%eps(1)%$$, and $math%delta(1)%$$, are used 
for accepting the minimizers with respect to the fixed population parameters.
$syntax/

/bLength/
/$$
is an integer scalar that specifies the number of random population 
parameters.
$syntax/

/phiTildeOut/
/$$
the $xref/glossary/Output Value/output value/$$ of $italic phiTildeOut$$
is a row vector containing the value of the Laplace approximation 
for the population optimal design criterion at each iteration of the 
minimization method. 
Its first element is the value of the Laplace approximation 
for the population optimal design criterion at $math%xIn%$$.
Its last element is the value of the Laplace approximation for 
the population optimal design criterion at $math%xOut%$$.
The number of elements is one more than the number of 
optimizer iterations used.
$syntax/

/phiTilde_xOut/
/$$
the $xref/glossary/Output Value/output value/$$ of $italic phiTilde_xOut$$
is a row vector containing the derivative of the Laplace approximation 
for the population optimal design criterion at the value $math%xOut%$$.
$syntax/

/phiTilde_x_xOut/ 
/$$
the $xref/glossary/Output Value/output value/$$ of $italic phiTilde_x_xOut$$
is a square matrix containing an approximation for the 
Hessian of the Laplace approximation for the population optimal 
design criterion at the value $math%xOut%$$.

$end
---------------------------------------------------------------------
#end##


# ---------------------------------------------------------------------
#
# Local functions
#
# ---------------------------------------------------------------------

# ---------------------------------------------------------------------
# Function: dummy
# ---------------------------------------------------------------------

local function dummy() begin
  stop "Model not set"
end


# ---------------------------------------------------------------------
# Function: Model
# ---------------------------------------------------------------------

local function Model = dummy()


# ---------------------------------------------------------------------
#
# Global functions
#
# ---------------------------------------------------------------------

# ---------------------------------------------------------------------
# Function: GLOBAL_FixedEffectsPrior
# ---------------------------------------------------------------------

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# [Revisit - Global Fixed Effects Prior Function - Mitch]
# It would be better if this were part of the model function
# that was passed down from function to function.
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

function GLOBAL_FixedEffectsPrior(alp, pOut, p_alpOut) begin

  i     = novalue
  chi_i = novalue
  b_i   = novalue

  fOut          = false
  f_chiOut      = false
  f_alpOut      = false
  f_bOut        = false
  f_b_chiOut    = false
  f_b_alpOut    = false
  ROut          = false
  R_chiOut      = false
  R_alpOut      = false
  R_bOut        = false
  DOut          = false
  D_alpOut      = false

  ok = Model( ...
    i, ...
    chi_i, ...
    alp, ...
    b_i, ...
    fOut, f_chiOut, f_alpOut, f_bOut, f_b_chiOut, f_b_alpOut, ...
    ROut, R_chiOut, R_alpOut, R_bOut, ...
    DOut, D_alpOut, ...
    pOut, p_alpOut ...
  )
  if not ok then begin
    stop
    return false
  end

  return true
end


# ---------------------------------------------------------------------
#
# Include files
#
# ---------------------------------------------------------------------

# PPED functions.
include FOOptimalDesignModel.oms

# Modified SPK functions.
include Lambda.oms
include MapObj.oms

# SPK functions.
include ppkaOpt.oms


# ---------------------------------------------------------------------
# Function: NoAlpPriorModel
# ---------------------------------------------------------------------

local function NoAlpPriorModel( ...
  i, ...
  chi_i, ...
  alp, ...
  b_i, ...
  fOut, f_chiOut, f_alpOut, f_bOut, f_b_chiOut, f_b_alpOut, ...
  ROut, R_chiOut, R_alpOut, R_bOut, ...
  DOut, D_alpOut ...
) begin

  pOut     = false
  p_alpOut = false

  return Model( ...
    i, ...
    chi_i, ...
    alp, ...
    b_i, ...
    fOut, f_chiOut, f_alpOut, f_bOut, f_b_chiOut, f_b_alpOut, ...
    ROut, R_chiOut, R_alpOut, R_bOut, ...
    DOut, D_alpOut, ...
    pOut, p_alpOut ...
  )

end


# ---------------------------------------------------------------------
# Function: FOOptimalDesignModelWrapper
# ---------------------------------------------------------------------

local function FOOptimalDesignModelWrapper( ...
  Unused, ...
  x, ....
  alp, ...
  fTildeOut, fTilde_chiOut, fTilde_alpOut, ...
  VTildeOut, VTilde_chiOut, VTilde_alpOut, ...
  Unused1, ...
  Unused2 ...
) begin

  return FOOptimalDesignModel( ...
    function NoAlpPriorModel, ...
    x, ....
    alp, ...
    fTildeOut, fTilde_chiOut, fTilde_alpOut, ...
    VTildeOut, VTilde_chiOut, VTilde_alpOut ...
  )

end


# ---------------------------------------------------------------------
#
# Global functions.
#
# ---------------------------------------------------------------------

# ---------------------------------------------------------------------
# Function: ppedOpt
# ---------------------------------------------------------------------

# ---------------------------------------------------------------------
#
# Implementation Notes
# ====================
#
# The criterion phi(x) is optimized by replacing the definition of 
# lambda(alp, b) and mapObj(b) by the negative natural logarithm 
# of the integral with respect to alp and then calls the function 
# ppkaOpt to optimize the Laplace approximation for the integral.
#
# ---------------------------------------------------------------------

function ppedOpt( ...
  function model, ...
  K, ...
  eps, ...
  delta, ...
  mitr, ...
  level, ...
  xStep, xLow, xUp, xIn, xOut, ...
  alpStep, alpLow, alpUp, alpIn, alpOut, ...
  bLength, ...
  phiTildeOut, phiTilde_xOut, phiTilde_x_xOut  ...
) ...
begin

  # -------------------------------------------------------------------
  # Preliminaries.
  # -------------------------------------------------------------------

  if not (phiTildeOut or phiTilde_xOut or phiTilde_x_xOut) then ...
    return true

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # [Revisit - Global Variables for Lambda - Mitch]
  # It would be better if these were part of the model function
  # that was passed down from function to function.  The reason
  # they cannot be passed down to lambda is that the LTilde/Lambda
  # interface does not include these.
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  #
  global GLOBAL_K
  global GLOBAL_alpStep
  global GLOBAL_nB

  GLOBAL_K       = K
  GLOBAL_alpStep = alpStep
  GLOBAL_nB      = bLength

  function Model = model()


  # -------------------------------------------------------------------
  # Optimize the modified Laplace approximation for the negative log of phi(x).
  # -------------------------------------------------------------------

  objective = "L"

  # ppkaOpt solves a two-level optimization problem, where the second
  # level is made up of multiple optimization problems that are all 
  # solved for each iteration of the first level.  The length of the 
  # vector n specifies the number of optimation problems that must be 
  # solved at the second level.  In this use of ppkaOpt, the first 
  # level optimization is over the design variables x, while the 
  # second level is over the fixed effects vector alp.  Since there 
  # is only a single fixed effects vector alp, n has length one.  Its
  # only value is zero because this criterion does not depend on the data.
  n = { 0 }
  y = {}

  xOutTemp      = xOut
  alpOutTemp    = alpOut
  LTildeOut     = phiTildeOut or phiTilde_xOut or phiTilde_x_xOut
  LTilde_xOut   = phiTilde_xOut or phiTilde_x_xOut
  LTilde_x_xOut = phiTilde_x_xOut

  ok = ppkaOpt( ...
    function FOOptimalDesignModelWrapper, ...
    objective, ...
    n, ...
    y, ...
    eps, ...
    delta, ...
    mitr, ...
    level, ...
    xStep, xLow, xUp, xIn, xOutTemp, ...
    alpStep, alpLow, alpUp, alpIn, alpOutTemp, ...
    LTildeOut, LTilde_xOut, LTilde_x_xOut  ...
  )

  if not ok then begin
    return false
  end


  # -------------------------------------------------------------------
  # Finish up.
  # -------------------------------------------------------------------

  if xOut then ...
    xOut = xOutTemp

  if alpOut then ...
    alpOut = alpOutTemp

  if phiTildeOut then ...
    phiTildeOut = exp(-LTildeOut)

  if phiTilde_xOut or phiTilde_x_xOut then ...
    LTildeLast = LTildeOut(coldim(LTildeOut))

  if phiTilde_xOut then ...
    phiTilde_xOut = - exp(-LTildeLast) * LTilde_xOut

  if phiTilde_x_xOut then ...
    phiTilde_x_xOut = ...
      exp(-LTildeLast) * (-LTilde_x_xOut + LTilde_xOut'*LTilde_xOut)

  function Model = dummy()

  return ok
end
