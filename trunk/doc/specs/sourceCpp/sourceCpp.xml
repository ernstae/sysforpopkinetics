<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                  "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd"[
  <!ENTITY uw "University of Washington">
  <!ENTITY dept "Department of Bioengineering">
]>
<article>
   <title>SPK Compiler Output (C++)</title>
   <articleinfo>
      <revhistory>
         <revision>
            <revnumber>1.6</revnumber>
            <date>July 1, 2004</date>
            <authorinitials>sh</authorinitials>
            <revremark>Complete reorganization.</revremark>
         </revision>
         <revision>
            <revnumber>1.5</revnumber>
            <date>April 6, 2004</date>
            <authorinitials>sh</authorinitials>
            <revremark>Updated the doc re. $PRED: Pred class derived from PredBase.</revremark>
         </revision>
         <revision>
            <revnumber>1.4</revnumber>
            <date>March 13, 2004</date>
            <authorinitials>alan</authorinitials>
            <revremark>Changes to move documentation to web server.</revremark>
         </revision>
         <revision>
            <revnumber>1.3</revnumber>
            <date>January 6, 2004</date>
            <authorinitials>alan</authorinitials>
            <revremark>Changed version of Docbook DTD from 4.1.2 to 4.2 in all .xml files</revremark>
         </revision>
         <revision>
            <revnumber>1.2</revnumber>
            <date>January 5, 2004</date>
            <authorinitials>alan</authorinitials>
            <revremark>Clean up.</revremark>
         </revision>
         <revision>
	    <revnumber>1.1</revnumber>
	    <date>December 8, 2003</date>
	    <authorinitials>sh</authorinitials>
	    <revremark>Initial version.</revremark>
         </revision>
      </revhistory>
      <abstract>
         <para>
SPK Compiler, given a pair of SpkSourceML and SpkDataML documents, produces
a number of C++ source code files in two stages.  The first set of files
being generated defines the problem to solve and its constraints.
The second set of files executes and process the information in different ways.  
The last set assembles and report the results.
         </para>
         <para>
In this documentation, you will find the specifications for those parameters
and interfaces which are public to SPK application developers.
         </para>
      </abstract>
   </articleinfo>
   <sect1>
      <title>Related Articles</title>
      <para>
         <itemizedlist>
            <listitem>
               <para>
                  <ulink url="../modelCap/html/modelCap.html">
                  Modeling Capabilities Specification</ulink>
               </para>
            </listitem>
            <listitem>
               <para>
                  <ulink url="http://muir.rfpk.washington.edu:800/SoftwareTeamArchive/Nonmem.doc">
                  NONMEM Description for RFPK (.doc)
                  </ulink>
               </para>
            </listitem>
         </itemizedlist>
      </para>
   </sect1>
   <sect1>
      <title><filename>Pred.h</filename></title>
      <para>
<filename>Pred.h</filename> defines a template class, <classname>Pred</classname>,
which is derived from an abstract class, <classname>PredBase</classname>.
The only virtual member in the base class is a boolean valued function, 
<function>eval</function>.
      </para>
      <para>
The definition of <literal>$PRED</literal>, which is written 
in NM-TRAN (ie. a subset of FORTRAN 77), is translated into C++ and 
inserted into a generated (by the SPK Compiler) 
subclass of an existing abstract class, <classname>PredBase</classname>.
<classname>PredBase</classname>
declares a pure virtual member function called <function>eval()</function>,
that is to be implemented.  SPK Compiler produces a C++ source code for
<classname>Pred</classname>, a concrete template sub-class of the abstract
base and store the definition in a file named, <filename>Pred.h</filename>.
The C++ version of PRED definition takes up the core computational portion
of the function implementation.
      </para>
      <sect2>
         <title>Abstract Base Class: <classname>PredBase</classname></title>
         <anchor id="predbase"/>
         <para>
            <classname>PredBase</classname> declares a pure virtual function, 
            <function>eval()</function>.  This function evaluates
            the C++ translation of user's $PRED model for the j-th component of
            the i-th individual's measurement data.  The class <classname>PredBase</classname>
            is part of <literal>spkpred</literal> library and declared in 
            <filename>PredBase.h</filename>.
         </para>
         <programlisting>
// This class is defined in &lt;spk/PredBase.h&gt;.
template &lt;class T&gt;
PredBase{
   public:
      virtual bool eval( int spk_thetaOffset, int spk_thetaLen,
		     int spk_etaOffset,   int spk_etaLen,
		     int spk_epsOffset,   int spk_epsLen,
		     int spk_fOffset,     int spk_fLen,
		     int spk_yOffset,     int spk_yLen,
		     int spk_i,
		     int spk_j,
		     const std::vector&lt;T&gt; & spk_indepVar,
		     std::vector&lt;T&gt; & spk_depVar ) = 0;
      virtual ~PredBase(){}
   protected:
      PredBase(){}
      PredBase( const PredBase& ){}
      PredBase& operator=( const PredBase& ){}
}
         </programlisting>
         <formalpara>
            <title>Description</title>
            <para>
<classname>Pred</classname>::<function>eval(...)</function> 
is called to evalute the PK value and
the estimate for the measure at every sampling point with
the current values of the population
parameter and the individual parameter for the particular subject
every time the optimizer comes up with a new set of values. 
            </para>
            </formalpara>
            <formalpara>
               <title>Requirements</title>
               <para>
                  <itemizedlist>
                     <listitem>
                        <para>
At the end of an iteration of population parameter optimization,
a <emphasis>complete</emphasis> set of values assigned 
to the all variables appeared 
on the left hand side of assignment operators in the user's 
portion of code ($PRED), evaluated at every sampling point for 
each individual shall be kept and be available externally.
This implies that the values from the previous iteration shall
be available if the current iteration failed in the middle
of computation.
                        </para>
                     </listitem>  
                     <listitem>
                        <para>
The user's portion of code originally written in FORTRAN (which is
case-insensitive) shall be able to use the upper or lower case letters
interexchangingly.
                        </para>
                     </listitem>
                     <listitem>
                        <para>
The user may define arbitrary varibles and use any NONMEM reserved words
within their portion of code.
                        </para>
                     </listitem>
                  </itemizedlist>
               </para>
            </formalpara>
            <formalpara>
               <title>Returned Value</title>
               <para>
<literal>true</literal> if the MDV for the the i-th individual's j-th data record were marked 0.  
<literal>false</literal> if it were 1.  MDV is a flag (0/1) indicating
as to whether the data record contains the DV (Dependent Variable, our 
<literal>y</literal>).  This information comes from the user's 
data set.  If the data record did not have this field, SPK Compiler
assumes every record contains a DV data item, in which case, MDV=0.
For v0.1, only the MDV data items of value 0 is supported.
               </para>
            </formalpara>
            <variablelist>
               <title>Arguments</title>
               <varlistentry>
                  <term>spk_thetaOffset</term>
                  <listitem>
	             <para>
                    The index to the head of <emphasis>theta</emphasis> vector within spk_indepVar.
                    </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term>spk_thetaLen</term>
                  <listitem>
                     <para>
                    The length of <emphasis>theta</emphasis> vector.  The vector elements are assumed to be placed
                    from <literal>spk_indepVar[spk_thetaOffset]</literal> 
                    to <literal>spk_indepVar[spk_theetaOffset + spk_theetaLen]</literal>.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term>spk_etaOffset</term>
                  <listitem>
                     <para>
                    The index to the head of <emphasis>eta</emphasis> vector within spk_indepVar.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term>spk_etaLen</term>
                  <listitem>
                     <para>
                     The length of <emphasis>eta</emphasis> vector.  The vector elements are assumed to be placed
                     from <literal>spk_indepVar[spk_etaOffset]</literal>
                     to <literal>spk_indepVar[spk_etaOffset + spk_etaLen]</literal>.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term>spk_epsOffset</term>
                  <listitem>
                     <para>
                     The index to the head of EPS vector within spk_indepVar.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term>spk_epsLen</term>
                  <listitem>
                     <para>
                     The length of EPS vector.
                     The vector elements are assumed to be placed
                     from <literal>spk_indepVar[spk_thetaOffset]</literal> 
                     to <literal>spk_indepVar[spk_theetaOffset + spk_theetaLen]</literal>.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term>spk_fOffset</term>
                  <listitem>
                     <para>
                     The index to the element in spk_depVar in which
                     the prediction for the j-th measurement for the i-th individual, 
                     <literal>F</literal>, shall be placed.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term>spk_fLen</term>
                 <listitem>
                     <para>
                     The number of measurements for the i-th individual.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term>spk_yOffset</term>
                  <listitem>
                     <para>
                     The index to the memory location within spk_depVar in which
                     the error model value for the j-th measurement for the i-th individual,
                     <literal>Y</literal>, shall be placed.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term>spk_yLen</term>
                  <listitem>
                     <para>
                     The number of measurments for the i-th individual..
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term>spk_i</term>
                  <listitem>
                     <para>
                     Index to the i-th individual 
                     within the population (0 indicates the first individual).
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term>spk_j</term>
                  <listitem>
                     <para>
                     Index to the j-th measurement of the i-th individual.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term>spk_indepVar</term>
                  <listitem>
                     <para>
                     The vector containing independent variables: 
                     <emphasis>theta</emphasis>, <emphasis>eta</emphasis> 
                     and <emphasis>eps</emphasis>.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term>spk_depVar</term>
                  <listitem>
                     <para>
                     (output) The <literal>spk_yOffset</literal>-th element will be 
                     replaced by the predicted value for the i-th individual's j-th measurement.
                     The <literal>spk_yOffset</literal>-th elements will be 
                     are replaced by the error model value for the i-th individual's j-th measurement.
                     </para>
                  </listitem>
               </varlistentry>
            </variablelist>
         </sect2>
         <sect2>
            <title>An instance of $PRED and <filename>Pred.h</filename></title>
            <anchor id="pred"/>
            <sect3>
               <title>$PRED</title>
               <programlisting>
   ;THETA(1)=MEAN ABSORPTION RATE CONSTANT (1/HR)
   ;THETA(2)=MEAN ELIMINATION RATE CONSTANT (1/HR)
   ;THETA(3)=SLOPE OF CLEARANCE VS WEIGHT RELATIONSHIP (LITERS/HR/KG)
   ;DOSE=WT-ADJUSTED DOSE (MG/KG)
   ;DS=NON-WT-ADJUSTED DOSE (MG)

   IF (DOSE.NE.0) THEN
      DS=DOSE*WT
      W=WT
   ENDIF
   KA=THETA(1) + ETA(1)
   KE=THETA(2) + ETA(2)
   CL=THETA(3) * WT + ETA(3)
   D=EXP(-KE*TIME)-EXP(-KA*TIME)
   E=CL*(KA-KE)
   F=DS*KE*KA/E*D
   Y=F+EPS(1)
               </programlisting>
           </sect3>
           <sect3>
              <title><filename>Pred.h</filename></title>
              <programlisting>
#ifndef PRED_H
#define PRED_H

#include &lt;vector&gt;
#include &lt;string&gt;
#include "DataSet.h"
#include "PredBase.h"

template &lt;class T&gt;
class Pred : public PredBase
{
public:
   virtual bool eval( int spk_thetaOffset, int spk_thetaLen,
                      int spk_etaOffset,   int spk_etaLen,
                      int spk_epsOffset,   int spk_epsLen,
                      int spk_fOffset,     int spk_fLen,
                      int spk_yOffset,     int spk_yLen,
                      int spk_i,
                      int spk_j,
                      const std::vector&lt;T&gt;& spk_indepVar,
                      std::vector&lt;T&gt;& spk_depVar );
   Pred( const DataSet&lt;T&gt; * dataIn ){}
   ~Pred(){}

protected:
   Pred(){}
   Pred( const Pred& ){}
   Pred & operator=( const Pred& ){}
private:
   // # of individuals in the population
   const int nIndividuals;

   // A pointer to the data set
   const DataSet&lt;T&gt; *set;

   // temporary placeholders for the user's equations to be able to access
   // the data items freely.
   mutable std::string id;
   mutable T time;
   mutable T cp;
   mutable T dv;
   mutable T wt;
   mutable T dose;
   mutable T mdv;
   mutable T cl;
   mutable T d;
   mutable T ds;
   mutable T e;
   mutable T f;
   mutable T y;
   mutable T ka;
   mutable T ke;
};

template &lt;class T&gt;
bool Pred&lt;T&gt;::eval( int spk_thetaOffset, int spk_thetaLen,
                    int spk_etaOffset,   int spk_etaLen,
                    int spk_epsOffset,   int spk_epsLen,
                    int spk_fOffset,     int spk_fLen,
                    int spk_yOffset,     int spk_yLen,
                    int spk_i,
                    int spk_j,
                    const std::vector&lt;T&gt;& spk_indepVar,
                    std::vector&lt;T&gt;& spk_depVar )
{

   //==================================================================================
   // Preliminaries:
   //
   // Place the data items to temporary variables for easy data access.
   //==================================================================================
   id   = set->data[spk_i]->id[spk_j];
   time = set->data[spk_i]->time[spk_j];
   cp   = set->data[spk_i]->cp[spk_j];
   dv   = set->data[spk_i]->dv[spk_j];
   wt   = set->data[spk_i]->wt[spk_j];
   dose = set->data[spk_i]->dose[spk_j];
   mdv  = set->data[spk_i]->mdv[spk_j];
   typename std::vector&lt;T&gt;::const_iterator theta1 = spk_indepVar.begin() + spk_thetaOffset + 0;
   typename std::vector&lt;T&gt;::const_iterator theta2 = spk_indepVar.begin() + spk_thetaOffset + 1;
   typename std::vector&lt;T&gt;::const_iterator theta3 = spk_indepVar.begin() + spk_thetaOffset + 2;
   typename std::vector&lt;T&gt;::const_iterator eta1   = spk_indepVar.begin() + spk_etaOffset   + 0;
   typename std::vector&lt;T&gt;::const_iterator eta2   = spk_indepVar.begin() + spk_etaOffset   + 1;
   typename std::vector&lt;T&gt;::const_iterator eta3   = spk_indepVar.begin() + spk_etaOffset   + 2;
   typename std::vector&lt;T&gt;::const_iterator eps1   = spk_indepVar.begin() + spk_epsOffset   + 0;
   typename std::vector&lt;T&gt;::const_iterator eps2   = spk_indepVar.begin() + spk_epsOffset   + 1;
   typename std::vector&lt;T&gt;::const_iterator theta  = spk_indepVar.begin() + spk_thetaOffset;
   typename std::vector&lt;T&gt;::const_iterator eta    = spk_indepVar.begin() + spk_etaOffset;
   typename std::vector&lt;T&gt;::const_iterator eps    = spk_indepVar.begin() + spk_epsOffset;
   f = 0.0;
   y = 0.0;

   //==================================================================================
   // Begin User Code                         
   //----------------------------------------------------------------------------------
   // THETA(1)=MEAN ABSORPTION RATE CONSTANT (1/HR)
   // THETA(2)=MEAN ELIMINATION RATE CONSTANT (1/HR)
   // THETA(3)=SLOPE OF CLEARANCE VS WEIGHT RELATIONSHIP (LITERS/HR/kg)
   // DOSE=WT-ADJUSTED DOSE (mg/kg)
   // DS=NON-WT-ADJUSTED DOSE (mg)
   if( dose != 0 )
   {
      ds = dose * wt;
      w = wt;
   }

   ka = theta[ ( 1 ) - 1 ] + eta[ ( 1 ) - 1 ];
   ke = theta[ ( 2 ) - 1 ] + eta[ ( 2 ) - 1 ];
   cl = theta[ ( 3 ) - 1 ] * w + eta[ ( 3 ) - 1 ];
   d = exp( -ke * time ) - exp( -ka * time );
   e = cl * ( ka - ke );
   f = ds * ke * ka / e * d;
   y = f + eps[ ( 1 ) - 1 ];
   //----------------------------------------------------------------------------------
   // End User Code                           
   //==================================================================================


   //==================================================================================
   // Wrap up:
   //
   // Place values to expected locations in given vectors.
   //==================================================================================
   spk_depVar[ spk_fOffset ] = f;
   spk_depVar[ spk_yOffset ] = y;


   //==================================================================================
   // Return:
   //
   // Return true if MDV (missing dependent variable) for this record is false.
   // Otherwise return false (which is not supported for ver 0.1).
   //==================================================================================
   if( set->data[ spk_i ]->mdv[ spk_j ] == 0 )
      return true;
   else 
      return false;
}

#endif
            </programlisting>
         </sect3>
      </sect2>
   </sect1>
   <sect1>
      <title><filename>IndData.h</filename></title>
      <para>
      <filename>IndData.h</filename> declares/defines a template class, <classname>IndData</classname>.
      <classname>IndData</classname> holds a set of data records for an individual.
      A data record is a s set of <emphasis>at least</emphasis> two data items: DV and MDV.
      DV is an abbribiation for Dependent Variable (see NONMEM documentations for definition)
      and MDV is for Missing Dependent Variable.  When the MDV value is 1 (ie. logical true),
      the value in DV is said to be missing or to be ignored.  When it is 0 (ie. logical false),
      the corresponding DV value is taken as a measurement against which estimate is made.
      </para>
      <para>
      All the data records are declared read-only within the class: ID, DV, MDV and the rest of the data items.
      An <classname>IndData</classname> object, however, would have another set of items for each record.
      These are meant to hold computed values for the left hand side of equations defined in the 
      <emphasis>PRED</emphasis> model definition every time it is evaluated.  This set of placeholders
      are, therefore, writable.  For example, if a data set had 3 records.  Each record is composed of
      a sampling time (TIME), a measurement (DV) and a MDV flag value.  A corresponding model looks like:
         <programlisting>
TMP1 = THETA(1) * 2.0
F = TMP1 + ETA(1)
         </programlisting>
      Then, an <classname>IndData</classname> object would have fields: TIME, DV and MDV as read-only and
      TMP1 and F as well as THETA(1) and ETA(1) as writable.  These values are accessible from a member function,
      <function>getValues()</function>.
      </para>
      <variablelist>
         <title>Public Methods</title>
         <varlistentry>
            <term><literal>const std::string getID() const</literal></term>
            <listitem>
               <para>
               Returns the ID for this individual.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const std::vector&lt;double&gt; getMeasurements() const</literal></term>
            <listitem>
               <para>
               Returns a vector of only those DV values which corresponding MDV != 1.
               Thus, the i-th element of the vector is not necessary the DV value from the i-th record.
               For example, if there are 10 records among which 1st and 5th records have MDV=1.
               The 1st element of the vector is the DV value from the 2nd record in the original set
               and the 5th element is from the 7th record.
               <programlisting>
indexes to all records                           : { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }
indexes to those records which have measurements : { 2, 3, 4, 6, 7, 8, 9, 10 }
               </programlisting>
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const std::vector&lt;double&gt; getValues( const std::string& label ) 
                           const</literal></term>
            <listitem>
               <para>
               Returns a vector of read-only values of <literal>label</literal> from the data set.
               The i-th element of the vector is the value from the i-th record.
               Case in <literal>label</literal> is ignored.  If <literal>label</literal> is
               not found, an SpkCompilerException is thrown.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>std::vector&lt;double&gt; getValues( const std::string& label ) </literal></term>
            <listitem>
               <para>
               Returns a vector of writable values/placeholders for <literal>label</literal> from the data set.
               The i-th element of the vector corresponds to the value from the i-th record.
               Case in <literal>label</literal> is ignored.  If <literal>label</literal> is
               not found, an SpkCompilerException is thrown.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
   </sect1>
   <sect1>
      <title><filename>DataSet.h</filename></title>
      <para>
      <filename>DataSet.h</filename> declares/defines a template class, <classname>DataSet</classname>.
      <classname>DataSet</classname> holds the entire data set for the population of size > 0.
      </para>
      <para>
      The first individual's data set is indexed by 0.
      </para>
      <variablelist>
         <title>Public Methods</title>
         <varlistentry>
            <term><literal>bool simulate( unsigned int seed, SpkModel& model )</literal></term>
            <listitem>
               <para>
               Simulate a data set for the population and replaces the existing measurement values
               with the new values for all individuals.
               Returns true if simulation was successful.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>int getPopSize() const </literal></term>
            <listitem>
               <para>
               Returns the number of individuals in the population.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const std::vector&lt;double&gt; getAllMeasurements() const</literal></term>
            <listitem>
               <para>
               Returns a vector of measurements from the entire data set for the population.
               The measurements values are taken from those data records with MDV != 1.
               If <literal>simulate</literal> has been executed in advance, the values returned
               by this method are simulated data.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const std::vector&lt;int&gt; getN() const </literal></term>
            <listitem>
               <para>
               Returns a vector of numbers of measurements.  The i-th element of the vector
               indicates the number of measurements for the i-th individual.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const std::vector&lt;double&gt; getMeasurements( int i ) const </literal></term>
            <listitem>
               <para>
               Returns the i-th individual's measurements.
               If <literal>simulate</literal> has been executed in advance, the values returned
               by this method are simulated data.  
               If <literal>i</literal> is out of bound, an SpkCompilerException will be thrown.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const std::vector&lt;double&gt; getValues( const std::string& label, int i ) const </literal></term>
            <listitem>
               <para>
               Returns a vector of <literal>label</literal> read-only values for the i-th individual. 
               If <literal>i</literal> is out of bound, an SpkCompilerException will be thrown.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>std::vector&lt;double&gt; getValues( const std::string& label, int i ) </literal></term>
            <listitem>
               <para>
               Returns a writable vector of <literal>label</literal> values/placeholders 
               for the i-th individual. 
               If <literal>i</literal> is out of bound, an SpkCompilerException will be thrown.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
   </sect1>
   <sect1>
      <title><filename>NonmemPars.h</filename></title>
      <para>
      <filename>NonmemPars.h</filename> exports a namespace, <literal>NonmemPars</literal>, containing
      parameters given by the end-user and values that can be derived from these parameters
      at SPK-compilation time.
      </para>
      <variablelist>
         <title>Public Properties</title>
         <varlistentry>
            <term><literal>const int nTheta</literal></term>
            <listitem>
               <para>
               is the length of <emphasis>theta</emphasis> vector.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const valarray&lt;double&gt; thetaUp</literal></term>
            <listitem>
               <para>
               contains the upper boundary value for <emphasis>theta</emphasis>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const valarray&lt;double&gt; thetaLow</literal></term>
            <listitem>
               <para>
               contains the lower boundary value for <emphasis>theta</emphasis>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const valarray&lt;double&gt; thetaIn</literal></term>
            <listitem>
               <para>
               contains the initial estimate for <emphasis>theta</emphasis>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const enum PopPredModel::covStruct omegaStruct</literal></term>
            <listitem>
               <para>
               is present only if the user has requested the population analysis.
               The value is either <literal>PopPredModel::DIAGONAL</literal> or 
               <literal>PopPredModel::FULL</literal>.
               <literal>DIAGONAL</literal> indicates that only the diagonal elements of 
               <emphasis>Omega</emphasis> matrix
               are subject to optimization.  <literal>FULL</literal> indicates that potentially all elements
               are subject to optimization.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const enum IndPredModel::covStruct omegaStruct</literal></term>
            <listitem>
               <para>
               is present only if the individual analysis is requested.
               The value is always IndPredModel::DIAGONAL for such analysis. 
               Only the diagonal elements of <emphasis>Omega</emphasis> matrix
               are subject to optimization.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const int omegaOrdrer</literal></term>
            <listitem>
               <para>
               is the number of elements in <emphasis>Omega</emphasis> matrix that are subject to optimization
               (ie. the order of <emphasis>Omega</emphasis>).
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const valarray&lt;double&gt; omegaIn</literal></term>
            <listitem>
               <para>
               is the initial estimates for the elements of <emphasis>Omega</emphasis>
               that are subject to optimization.  Thus, the length of <literal>omegaIn</literal>
               is <literal>omegaOrder</literal>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const int nEta</literal></term>
            <listitem>
               <para>
               is the length of <emphasis>eta</emphasis> vector, 
               which is the order of <emphasis>Omega</emphasis>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const valarray&lt;double&gt; etaIn</literal></term>
            <listitem>
               <para>
               is the initial estimate for <emphasis>eta</emphasis> vector.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const enum PopPredModel::covStruct sigmaStruct</literal></term>
            <listitem>
               <para>
               is present only if the population analysis is requested.
               The value is either <literal>PopPredModel::DIAGONAL</literal>
               or <literal>PopPredModel::FULL</literal>.
               <literal>DIAGONAL</literal> indicates that only the diagonal elements of 
               <emphasis>Sigma</emphasis> matrix
               are subject to optimization.  <literal>FULL</literal> indicates that potentially all elements
               are subject to optimization.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const valarray&lt;double&gt; sigmaIn</literal></term>
            <listitem>
               <para>
               is the initial estimates for the elements of <emphasis>Sigma</emphasis>
               that are subject to optimization.  Thus, the length of <literal>simgaIn</literal>
               is <literal>sigmaOrder</literal>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const int nEps</literal></term>
            <listitem>
               <para>
               is the length of <emphasis>eps</emphasis> vector,
               which is the order of <emphasis>Sigma</emphasis>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const int seed</literal></term>
            <listitem>
               <para>
               specifies the seed for random number generation.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
   </sect1>
   <sect1>
      <title><filename>MontePars.h</filename></title>
      <para>
         <filename>MontePars.h</filename> exports a namespace, <filename>MontePars</filename>.
         The namespace contains control parameters for Monte Carlo simulation.
         This file is generated only if Monte Carlo simulation is requested.
      </para>
      <variablelist>
         <varlistentry>
            <term><literal>const enum { analytic, grid, monte } method</literal></term>
            <listitem>
               <para>specifies the method for approximating (or computing) the integral.
               <variablelist>
                  <varlistentry>
                     <term><literal>analitic</literal></term>
                     <listitem>
                        <para>Closed form solution only valid for <emphasis>LinearModel</emphasis> (consult Brad for details)
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>grid</literal></term>
                     <listitem>
                        <para>Approximation integral using evaluation on a uniform grid
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><literal>monte</literal></term>
                     <listitem>
                        <para>Monte-Carlo approximation for integral
                        </para>
                     </listitem>
                  </varlistentry>
               </variablelist>
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><literal>const int numberEval</literal></term>
            <listitem>
               <para>
               specifies the number of function evalautions to use for each
               individual in the population.
               Actually it is the maximum number when <emphasis>method</emphasis> is
               <literal>grid</literal> and it is not used when <varname>method</varname> is <literal>analytic</literal>.
               </para>
            </listitem>
         </varlistentry>
      </variablelist>
   </sect1>
   <sect1>
      <title><filename>spkDriver.cpp</filename></title>
      <para>
      </para>
   </sect1>
   <sect1>
      <title><filename>monteDriver.cpp</filename></title>
      <para>
      </para>
   </sect1>
   <sect1>
      <title><filename>Makefile.SPK</filename></title>
      <para>
      This Make file defines rules to build targets that perform
      the population/individual parameter estimation (if requested)
      and statistics computation (if requested).
      </para>
      <formalpara>
         <title>Targets</title>
         <para>
            <variablelist>
               <varlistentry>
                  <term>proc <emphasis>(default)</emphasis></term>
                  <listitem>
                     <para>
                     Compile all SPK-Compiler-generated C++ source code files,
                     link to <emphasis>production</emphasis> libraries and build an
                     SPK driver, <filename>spkDriver</filename>.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term>test</term>
                  <listitem>
                     <para>
                     Compile all SPK-Compiler-generated C++ source code files,
                     link to <emphasis>test</emphasis> libraries and build an
                     SPK driver, <filename>spkDriver</filename>.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term>clean</term>
                  <listitem>
                     <para>
                     Delete all artifacts generated by SPK Compiler except for Make files.
                     </para>
                  </listitem>
               </varlistentry>
            </variablelist>
         </para>
      </formalpara>
   </sect1>
   <sect1>
      <title><filename>Makefile.MC</filename></title>
      <para>
      This Make file defines rule to build targets that perform
      the Monte Carlo simulation.
      </para>
      <formalpara>
         <title>Targets</title>
         <para>
            <variablelist>
               <varlistentry>
                  <term>proc <emphasis>(default)</emphasis></term>
                  <listitem>
                     <para>
                     Compile all SPK-Compiler-generated C++ source code files,
                     link to <emphasis>production</emphasis> libraries and build an
                     Monte Carlo simulator, <filename>monteDriver</filename>.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term>test</term>
                  <listitem>
                     <para>
                     Compile all SPK-Compiler-generated C++ source code files,
                     link to <emphasis>test</emphasis> libraries and build an
                     Monte Carlo simulator, <filename>monteDriver</filename>.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term>clean</term>
                  <listitem>
                     <para>
                     Delete all artifacts generated by SPK Compiler except for Make files.
                     </para>
                  </listitem>
               </varlistentry>
            </variablelist>
         </para>
      </formalpara>
   </sect1>

</article>
