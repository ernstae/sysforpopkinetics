<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                  "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd"[
  <!ENTITY uw "University of Washington">
  <!ENTITY dept "Department of Bioengineering">
]>
<article><title>ASPK Compiler Output (C++)</title>
 <articleinfo>
    <revhistory>
      <revision>
	<revnumber>1.0</revnumber>
	<date>December 8, 2003</date>
	<authorinitials>sh</authorinitials>
	<revremark>Initial version.</revremark>
      </revision>
    </revhistory>
  <abstract>
      <para>
This document specifies the requirements for the source code (C++) that
ASPK Compiler produces and that, 
as a whole, is built to an executable that ultimately makes 
the SPK Library produce what the end-user asks for.  The source code is,
therefore, the C++ translation of 
<ulink url="../sourceML/sourceML.html">
SpkSourceML</ulink> and 
<ulink url="../dataML/dataML.html">
SpkDataML</ulink> given by MDA, as well as it is to produce an instance of
<ulink url="../reportML/reportML.html">
SpkReportML</ulink>.  
The generated C++ source code is packaged as an archive and put into the CSPK job queue.
      </para>
  </abstract>
 </articleinfo>
  <sect1>
    <title>Related Articles</title>
    <para>
       <itemizedlist>
          <listitem>
             <para>
                <ulink url="../modelCap/html/modelCap.html">
                Modeling Capabilities Specification</ulink>
             </para>
          </listitem>
          <listitem>
             <para>
                <ulink url="http://muir.rfpk.washington.edu:800/SoftwareTeamArchive/Nonmem.doc">
                NONMEM Description for RFPK (.doc)
                </ulink>
             </para>
          </listitem>
       </itemizedlist>
    </para>
  </sect1>
  <sect1>
    <title>Three Logical Units</title>
    <para>
The C++ source code as a whole defines the following three units at large:

       <itemizedlist>
          <listitem>
             <para><link linkend="models">Models</link></para>
          </listitem>
          <listitem>
             <para><link linkend="dataset">Data Set</link></para>
          </listitem>
          <listitem>
             <para><link linkend="driver">Driver</link></para>
          </listitem>
       </itemizedlist>
    </para>
  </sect1>
  <sect1>
     <title>Models</title>
     <anchor id="models"/>
     <para>
The models are functions of different set of parameters depending on the situation.
When SPK is used to estimate a single subject's parameters only, it is said to be
performing the individual analysis, in which case, the models are functions of only
the individual's parameters.  The SPK model for the measurement in this case is defined
as:
   y = f( b*) + e,
where e~N(0, R(b*)) and, if the variance of prior distribution is known, 
b*~N(0, D(alpha*)).
     </para>
     <para>
When it is used to estimate the fixed effects
among a group of subjects, it is said to be doing the population analysis, in which case,
the models are functions of both the population parameters (fixed effects) and
the individuals' parameters (random effects).
The SPK's mixed effect model for the measurements in this case is defined as:
yi = fi( alpha*, bi* ) + ei, 
where ei~N( 0, Ri(alpha*, bi*) ) and bi*~N( 0.0, D(alpha*) ).
     </para>
     <para>
Thus, this section describes how clients' models are transformed to the SPK models.
For the version 0.1, we forcus on the following clients' models:
        <itemizedlist>
           <listitem>
              <para><link linkend="nonmem_models">NONMEM Models</link></para>
           </listitem>
        </itemizedlist>
     </para>
     <sect2>
        <title>Where the NONMEM Models Fit in to the Problem to Solve</title>
        <anchor id="nonmem_models"/>
        <para>
NONMEM models are written in a way different from SPK because
the problem NONMEM is different from the one SPK solves.
This section is to give you the brief background as to how these two
different problems are made equivalent conceptually and in the following
section, you will find out how the ASPK Compiler actually translates 
the NONMEM models to fit into the SPK's framework, software-wise.
        </para>
        <para>
           <emphasis>
The complete discussion of mathematical transformation is beyond the scope of
this document.  One of the text you can find more information about this is
<ulink url="../modelCap/html/modelCap.html">
Modeling Capabilities Specification</ulink>: Appendix B.
           </emphasis>
        </para>
        <para>
Here's the side-by-side brief comparizon of the two problems:
           <anchor id="tableProblemMap"/>
           <table>
              <title>Problems to Solve</title>
              <tgroup cols='3'>
                 <thead>
                    <row>
                       <entry align='center'>Analysis</entry>
                       <entry align='center'>SPK</entry>
                       <entry align='center'>NONMEM</entry>
                    </row>
                 </thead>
                 <tbody>
                    <row>
                       <entry>Individual</entry>
                       <entry>
                          <literallayout>y = f(b) + e --- <emphasis>(1)</emphasis></literallayout>
                       </entry>
                       <entry>
                          <literallayout>y = f(x, theta) + h(x, theta) * eps --- <emphasis>(2)</emphasis></literallayout>
                       </entry>
                    </row>
                    <row>
                       <entry>Population</entry>
                       <entry>
                          <literallayout>y<emphasis>i</emphasis> = f<emphasis>i</emphasis>(alp, b<emphasis>i</emphasis>) + e<emphasis>i</emphasis> --- <emphasis>(3)</emphasis></literallayout>
                       </entry>
                       <entry>
                          <literallayout>y<emphasis>i</emphasis> = f(x<emphasis>i</emphasis>, theta, eta<emphasis>i</emphasis>) + h(x<emphasis>i</emphasis>, theta, eta<emphasis>i</emphasis>) * eps<emphasis>i</emphasis> --- <emphasis>(4)</emphasis></literallayout>
                       </entry>
                    </row>
                 </tbody>
              </tgroup>
           </table>
        </para>
        <para>
Some of the parameters in the equations above are already equivalent but some are not.
The following two tables summerieze the parameter and function mappings:
           <anchor id="tableParameterMap"/>
           <table>
              <title>Parameter Mapping</title>
              <tgroup cols="4">
                 <thead>
                    <row>
                       <entry align="center">Analysis</entry>
                       <entry align="center">Parameter</entry>
                       <entry align="center">SPK</entry>
                       <entry align="center">NONMEM</entry>
                    </row>
                 </thead>
                 <tbody>
                    <row>
                       <entry morerows="1">Individual</entry>
                       <entry>Individual's Parameter</entry>
                       <entry>b</entry>
                       <entry>theta</entry>
                    </row>
                    <row>
                       <entry>Prior Distribution</entry>
                       <entry>D (constant value)</entry>
                       <entry>Omega, where Omega is constant.</entry>
                    </row>
                    <row>
                       <entry morerows="2">Population</entry>
                       <entry>Individual's Parameter</entry>
                       <entry>bi</entry>
                       <entry>etai</entry>
                    </row>
                    <row>
                       <entry>Population Parameter</entry>
                       <entry>alpha</entry>
                       <entry>{ theta, Omega, Sigma }</entry>
                    </row>
                    <row>
                       <entry>Prior Distribution</entry>
                       <entry>see the table 2</entry>
                       <entry>see the table 2</entry>
                    </row>
                 </tbody>
              </tgroup>
           </table>
        </para>
        <para>
           <anchor id="tableFunctionMap"/>
           <table>
              <title>Function Mapping</title>
              <tgroup cols="4">
                 <thead>
                    <row>
                       <entry align="center">Analysis</entry>
                       <entry align="center">Parameter</entry>
                       <entry align="center">SPK</entry>
                       <entry align="center">NONMEM</entry>
                    </row>
                 </thead>
                 <tbody>
	            <row>
                       <entry morerows="1">Individual</entry>
                       <entry>Mean of Data</entry>
                       <entry>f(b)</entry>
                       <entry>{ f0(x0, theta), f1(x1, theta), ... f(xn, theta) }</entry>
                    </row>
                    <row>
                       <entry>Variance of Data</entry>
                       <entry>R(b)</entry>
                       <entry>cov[ sum{ h(m)(x, theta)*eps } | m=1:nSigma ]</entry>
                    </row>
                    <row>
                       <entry morerows="2">Population</entry>
                       <entry>Mean of Data</entry>
                       <entry>fi(alpha, bi)</entry>
                       <entry>{ fi0(xi0, theta, etai), f1(xi1, theta, etai), ... fi(xin, theta, etai) }</entry>
                    </row>
                    <row>
                       <entry>Variance of Data</entry>
                       <entry>Ri(alpha, bi)</entry>
                       <entry>cov[ sum{h(m)(xi, theta, etai)*epsi} | m=1:nSigma ]</entry>
                    </row>
                    <row>
                       <entry>Variance Between Individual Parameters</entry>
                       <entry>D(alpha)</entry>
                       <entry>Omega, where Omega is subject to optimization</entry>
                    </row>
                 </tbody>
              </tgroup>
           </table>
        </para>
     </sect2>
     <sect2>
        <title>C++ Implementation of NONMEM PRED Model</title>
        <para>
For v0.1, ASPK Compiler supports only the NONMEM's most general modeling framework,
<literal>$PRED</literal>.  
        </para>
        <para>
The definition of <literal>$PRED</literal>, which is written 
in NM-TRAN (ie. a subset of FORTRAN 77), is translated into C++ and 
inserted into a dynamically generated (by the SPK Compiler) 
subclass of a pre-specified abstract class, <classname>PredBase</classname>.  
<classname>PredBase</classname>
declares a pure virtual member function called <function>eval(...)</function>,
and this is where the C++ version of <literal>$PRED</literal> definition
is embedded in.
        </para>
        <para>
The following is the <classname>PredBase</classname>:
           <programlisting>
template &lt;class T&gt;
class PredBase
{
public:
  virtual bool eval( int spk_thetaOffset, int spk_thetaLen,
		     int spk_etaOffset,   int spk_etaLen,
		     int spk_epsOffset,   int spk_epsLen,
		     int spk_fOffset,     int spk_fLen,
		     int spk_yOffset,     int spk_yLen,
		     int spk_i,
		     int spk_j,
		     const std::vector&lt;T&gt; & spk_indepVar,
		     std::vector&lt;T&gt; & spk_depVar ) = 0;
 protected:
  ~PredBase(){}
  PredBase(){}
  PredBase( const PredBase& ){}
  PredBase & operator=( const PredBase&lt;T&gt;& ){}
};
           </programlisting>
        </para>

        <formalpara>
           <title>Description</title>
           <para>
<classname>Pred</classname>::<function>eval(...)</function> 
is called to evalute the PK value and
the estimate for the measure at every sampling point with
the current values of the population
parameter and the individual parameter for the particular subject
every time the optimizer comes up with a new set of values. 
           </para>
        </formalpara>
        <formalpara>
           <title>Requirements</title>
           <para>
              <itemizedlist>
                 <listitem>
                    <para>
At the end of an iteration of population parameter optimization,
a <emphasis>complete</emphasis> set of values assigned 
to the all variables appeared 
on the left hand side of assignment operators in the user's 
portion of code ($PRED), evaluated at every sampling point for 
each individual shall be kept and be available externally.
This implies that the values from the previous iteration shall
be available if the current iteration failed in the middle
of computation.
                    </para>
                 </listitem>  
                 <listitem>
                    <para>
The user's portion of code originally written in FORTRAN (which is
case-insensitive) shall be able to use the upper or lower case letters
interexchangingly.
                    </para>
                 </listitem>
                 <listitem>
                    <para>
The user may define arbitrary varibles and use any NONMEM reserved words
within their portion of code.
                    </para>
                 </listitem>
              </itemizedlist>
           </para>
        </formalpara>
        <formalpara>
           <title>Returned Value</title>
           <para>
<literal>true</literal> if the MDV for the the i-th individual's j-th data record were marked 0.  
<literal>false</literal> if it were 1.  MDV is a flag (0/1) indicating
as to whether the data record contains the DV (Dependent Variable, our 
<literal>y</literal>).  This information comes from the user's 
data set.  If the data record did not have this field, ASPK Compiler
assumes every record contains a DV data item, in which case, MDV=0.
For v0.1, only the MDV data items of value 0 is supported.
           </para>
        </formalpara>
        <variablelist>
           <title>Arguments</title>
           <varlistentry>
              <term>spk_thetaOffset</term>
               <listitem>
	         <para>
                 The index to the head of THETA vector within spk_indepVar.
                 </para>
              </listitem>
           </varlistentry>
           <varlistentry>
              <term>spk_thetaLen</term>
              <listitem>
                 <para>
                 The length of THETA vector.  The vector elements are assumed to be placed
                 from <literal>spk_indepVar[spk_thetaOffset]</literal> 
                 to <literal>spk_indepVar[spk_theetaOffset + spk_theetaLen]</literal>.
                 </para>
              </listitem>
           </varlistentry>
           <varlistentry>
              <term>spk_etaOffset</term>
              <listitem>
                 <para>
                 The index to the head of ETA vector within spk_indepVar.
                 </para>
              </listitem>
           </varlistentry>
           <varlistentry>
              <term>spk_etaLen</term>
              <listitem>
                 <para>
                 The length of ETA vector.  The vector elements are assumed to be placed
                 from <literal>spk_indepVar[spk_etaOffset]</literal>
                 to <literal>spk_indepVar[spk_etaOffset + spk_etaLen]</literal>.
                 </para>
              </listitem>
           </varlistentry>
           <varlistentry>
              <term>spk_epsOffset</term>
              <listitem>
                 <para>
                 The index to the head of EPS vector within spk_indepVar.
                 </para>
              </listitem>
           </varlistentry>
           <varlistentry>
              <term>spk_epsLen</term>
              <listitem>
                 <para>
                 The length of EPS vector.
                 The vector elements are assumed to be placed
                 from <literal>spk_indepVar[spk_thetaOffset]</literal> 
                 to <literal>spk_indepVar[spk_theetaOffset + spk_theetaLen]</literal>.
                 </para>
              </listitem>
           </varlistentry>
           <varlistentry>
              <term>spk_fOffset</term>
              <listitem>
                 <para>
                 The index to the memory location within spk_depVar in which
                 the computed <literal>F</literal> (ie. prediction) 
                 for the j-th measurement of the i-th individual
                 shall be placed.
                 </para>
              </listitem>
           </varlistentry>
           <varlistentry>
              <term>spk_fLen</term>
              <listitem>
                 <para>
                 The total length of <literal>F</literal> vector.
                 </para>
              </listitem>
           </varlistentry>
           <varlistentry>
              <term>spk_yOffset</term>
              <listitem>
                 <para>
                 The index to the memory location within spk_depVar in which
                 the computed <literal>Y</literal> (ie. data variance) 
                 for the j-th measurement of the i-th individual
                 shall be placed.
                 </para>
              </listitem>
           </varlistentry>
           <varlistentry>
              <term>spk_yLen</term>
              <listitem>
                 <para>
                 The total length of <literal>Y</literal> vector.
                 </para>
              </listitem>
           </varlistentry>
           <varlistentry>
              <term>spk_i</term>
              <listitem>
                 <para>
                 The index to the individual of interest 
                 within the population (0 indicates the first individual).
                 </para>
              </listitem>
           </varlistentry>
           <varlistentry>
              <term>spk_j</term>
              <listitem>
                 <para>
                 The index to the sampling point of interest.
                 </para>
              </listitem>
           </varlistentry>
           <varlistentry>
              <term>spk_indepVar</term>
              <listitem>
                 <para>
                 The vector containing independent variables: 
                 <literal>THETA</literal>, <literal>ETA</literal> and <literal>EPS</literal>.
                 </para>
              </listitem>
           </varlistentry>
           <varlistentry>
              <term>spk_depVar</term>
              <listitem>
                 <para>
                 (output) The vector whose spk_yOffset-th and spk_yOffset-th elements
                 are replaced with newly computed values.
                 </para>
              </listitem>
           </varlistentry>
        </variablelist>
     </sect2>
     <sect2>
        <title>An Example of $PRED</title>
        <programlisting>
   ;THETA(1)=MEAN ABSORPTION RATE CONSTANT (1/HR)
   ;THETA(2)=MEAN ELIMINATION RATE CONSTANT (1/HR)
   ;THETA(3)=SLOPE OF CLEARANCE VS WEIGHT RELATIONSHIP (LITERS/HR/KG)
   ;DOSE=WT-ADJUSTED DOSE (MG/KG)
   ;DS=NON-WT-ADJUSTED DOSE (MG)

   IF (DOSE.NE.0) THEN
      DS=DOSE*WT
      W=WT
   ENDIF
   KA=THETA(1) + ETA(1)
   KE=THETA(2) + ETA(2)
   CL=THETA(3) * WT + ETA(3)
   D=EXP(-KE*TIME)-EXP(-KA*TIME)
   E=CL*(KA-KE)
   F=DS*KE*KA/E*D
   Y=F+EPS(1)
        </programlisting>
      </sect2>
      <sect2>
         <title>A C++ Realization of $PRED</title>
         <programlisting>
// THIS FILE IS GENERATED BY THE ASPK COMPILER
#ifndef PRED_H
#define PRED_H

#include &lt;vector&gt;
#include &lt;string&gt;
#include "DataSet.h"
#include "PredBase.h"

template &lt;class T&gt;
class Pred : public PredBase
{
public:
Pred( const DataSet&lt;T&gt; * dataIn );
~Pred();
bool eval( int spk_thetaOffset, int spk_thetaLen,
           int spk_etaOffset,   int spk_etaLen,
           int spk_epsOffset,   int spk_epsLen,
           int spk_fOffset,     int spk_fLen,
           int spk_yOffset,     int spk_yLen,
           int spk_i,
           int spk_j,
           const std::vector&lt;T&gt;& spk_indepVar,
           std::vector&lt;T&gt;& spk_depVar );

protected:
Pred();
Pred( const Pred& );
Pred & operator=( const Pred& );
private:
const int nIndividuals;
const DataSet&lt;T&gt; *perm;
DataSet&lt;T&gt; temp;
mutable bool isIterationCompleted;
mutable std::string id;
mutable T time;
mutable T cp;
mutable T dv;
mutable T wt;
mutable T dose;
mutable T mdv;
mutable T cl;
mutable T d;
mutable T ds;
mutable T e;
mutable T f;
mutable T ka;
mutable T ke;
mutable T omega;
mutable T pred;
mutable T res;
mutable T sigma;
mutable T w;
mutable T wres;
mutable T y;
};
template &lt;class T&gt;
Pred&lt;T&gt;::Pred( const DataSet&lt;T&gt;* dataIn )
: perm( dataIn ),
  nIndividuals( 3 ),
  isIterationCompleted( true )
{
}
template &lt;class T&gt;
Pred&lt;T&gt;::~Pred()
{
}
template &lt;class T&gt;
bool Pred&lt;T&gt;::eval( int spk_thetaOffset, int spk_thetaLen,
                    int spk_etaOffset,   int spk_etaLen,
                    int spk_epsOffset,   int spk_epsLen,
                    int spk_fOffset,     int spk_fLen,
                    int spk_yOffset,     int spk_yLen,
                    int spk_i,
                    int spk_j,
                    const std::vector&lt;T&gt;& spk_indepVar,
                    std::vector&lt;T&gt;& spk_depVar )
{
  assert( spk_thetaLen == 3 );
  assert( spk_etaLen   == 3 );
  assert( spk_epsLen   == 2 );

id = perm->data[spk_i]->id[spk_j];
time = perm->data[spk_i]->time[spk_j];
cp = perm->data[spk_i]->cp[spk_j];
dv = perm->data[spk_i]->dv[spk_j];
wt = perm->data[spk_i]->wt[spk_j];
dose = perm->data[spk_i]->dose[spk_j];
mdv = perm->data[spk_i]->mdv[spk_j];
typename std::vector&lt;T&gt;::const_iterator theta1 = spk_indepVar.begin() + spk_thetaOffset + 0;
typename std::vector&lt;T&gt;::const_iterator theta2 = spk_indepVar.begin() + spk_thetaOffset + 1;
typename std::vector&lt;T&gt;::const_iterator theta3 = spk_indepVar.begin() + spk_thetaOffset + 2;
typename std::vector&lt;T&gt;::const_iterator eta1 = spk_indepVar.begin() + spk_etaOffset + 0;
typename std::vector&lt;T&gt;::const_iterator eta2 = spk_indepVar.begin() + spk_etaOffset + 1;
typename std::vector&lt;T&gt;::const_iterator eta3 = spk_indepVar.begin() + spk_etaOffset + 2;
typename std::vector&lt;T&gt;::const_iterator eps1 = spk_indepVar.begin() + spk_epsOffset + 0;
typename std::vector&lt;T&gt;::const_iterator eps2 = spk_indepVar.begin() + spk_epsOffset + 1;
typename std::vector&lt;T&gt;::const_iterator theta = spk_indepVar.begin() + spk_thetaOffset;
typename std::vector&lt;T&gt;::const_iterator eta = spk_indepVar.begin() + spk_etaOffset;
typename std::vector&lt;T&gt;::const_iterator eps = spk_indepVar.begin() + spk_epsOffset;
T f = 0.0;
T y = 0.0;
//=========================================
// Begin User Code                         
//-----------------------------------------

// THETA(1)=MEAN ABSORPTION RATE CONSTANT (1/HR)
// THETA(2)=MEAN ELIMINATION RATE CONSTANT (1/HR)
// THETA(3)=SLOPE OF CLEARANCE VS WEIGHT RELATIONSHIP (LITERS/HR/kg)
// DOSE=WT-ADJUSTED DOSE (mg/kg)
// DS=NON-WT-ADJUSTED DOSE (mg)
if( dose != 0 )
{
ds = dose * wt;
w = wt;
}

ka = theta[ ( 1 ) - 1 ] + eta[ ( 1 ) - 1 ];
ke = theta[ ( 2 ) - 1 ] + eta[ ( 2 ) - 1 ];
cl = theta[ ( 3 ) - 1 ] * w + eta[ ( 3 ) - 1 ];
d = exp( -ke * time ) - exp( -ka * time );
e = cl * ( ka - ke );
f = ds * ke * ka / e * d;
y = f + eps[ ( 1 ) - 1 ];
//-----------------------------------------
// End User Code                           
//=========================================
temp.data[ spk_i ]->cl[ spk_j ] = cl;
temp.data[ spk_i ]->d[ spk_j ] = d;
temp.data[ spk_i ]->ds[ spk_j ] = ds;
temp.data[ spk_i ]->e[ spk_j ] = e;
copy( eps, eps + 2, temp.data[ spk_i ]->eps.begin() );
copy( eta, eta + 3, temp.data[ spk_i ]->eta.begin() );
temp.data[ spk_i ]->f[ spk_j ] = f;
temp.data[ spk_i ]->ka[ spk_j ] = ka;
temp.data[ spk_i ]->ke[ spk_j ] = ke;
temp.data[ spk_i ]->omega[ spk_j ] = omega;
temp.data[ spk_i ]->pred[ spk_j ] = pred;
temp.data[ spk_i ]->res[ spk_j ] = res;
temp.data[ spk_i ]->sigma[ spk_j ] = sigma;
copy( theta, theta + 3, temp.data[ spk_i ]->theta.begin() );
temp.data[ spk_i ]->w[ spk_j ] = w;
temp.data[ spk_i ]->wres[ spk_j ] = wres;
temp.data[ spk_i ]->y[ spk_j ] = y;

if( spk_i == 3-1 && spk_j == perm->data[spk_i]->id.size()-1 )
{
  // This means, SPK advanced in iteration.
  // Move temporary storage to permanent storage.
  isIterationCompleted = true;
  for( int i=0; i < nIndividuals; i++ )
  {
    perm->data[ i ]->cl = temp.data[ i ]->cl;
    perm->data[ i ]->d = temp.data[ i ]->d;
    perm->data[ i ]->ds = temp.data[ i ]->ds;
    perm->data[ i ]->e = temp.data[ i ]->e;
    perm->data[ i ]->eps = temp.data[ i ]->eps;
    perm->data[ i ]->eta = temp.data[ i ]->eta;
    perm->data[ i ]->f = temp.data[ i ]->f;
    perm->data[ i ]->ka = temp.data[ i ]->ka;
    perm->data[ i ]->ke = temp.data[ i ]->ke;
    perm->data[ i ]->omega = temp.data[ i ]->omega;
    perm->data[ i ]->pred = temp.data[ i ]->pred;
    perm->data[ i ]->res = temp.data[ i ]->res;
    perm->data[ i ]->sigma = temp.data[ i ]->sigma;
    perm->data[ i ]->theta = temp.data[ i ]->theta;
    perm->data[ i ]->w = temp.data[ i ]->w;
    perm->data[ i ]->wres = temp.data[ i ]->wres;
    perm->data[ i ]->y = temp.data[ i ]->y;
  }
}
else
{
  isIterationCompleted = false;
}

spk_depVar[ spk_fOffset ] = f;
spk_depVar[ spk_yOffset ] = y;
if( perm->data[ spk_i ]->mdv[ spk_j ] == 0 )
   return true;
else return false;
}
template &lt;class T&gt;
Pred&lt;T&gt;::Pred()
{
}
template &lt;class T&gt;
Pred&lt;T&gt;::Pred( const Pred&lt;T&gt;& )
{
}
template &lt;class T&gt;
Pred&lt;T&gt; & Pred&lt;T&gt;::operator=( const Pred&lt;T&gt;& )
{
}
#endif

         </programlisting>
      </sect2>
   </sect1>
   <sect1>
     <title>Data Set</title>
     <anchor id="dataset"/>
     <para>
A data set is a set of data records for one or more subjects
and a data record is a set of related data items.  
A data record contains not only sampling times and measurements but also
may contain other useful information that may indicate the type or/and the state
of the corresponding record.  The data item labeled as DV
(Dependent Variable) is what we SPK calls <emphasis>y</emphasis>, the measurements.
The data set has to be kept internally (to SPK) 
in such a way that the following requirements are met:
     </para>
     <formalpara>
        <title>Requirements</title>
        <para>
           <itemizedlist>
              <listitem>
                 <para>
The DV (Dependent Variable) values are recognized as our <emphasis>y</emphasis>,
the measurements.
                 </para>
              </listitem>
              <listitem>
                 <para>
A set of same kind of data items is refered both by its label and by the alias
if it is associated.
                 </para>
              </listitem>
              <listitem>
                 <para>
A data item is accessible by its owner's order (not ID) and the order in which the item
appears within the owner's data records as indeces staring from 0.
ie. <literal>xxx[i][j]</literal> refers to the (i+1)-th subject's (j+1)-th data item labeled as 
<literal>xxx</literal>.
                 </para>
              </listitem>
           </itemizedlist>
        </para>
     </formalpara>
        <table>
           <title>An Example of Data Set</title>
           <tgroup cols="5">
              <thead>
                 <row>
                    <entry align="center"><emphasis>Label</emphasis></entry>
                    <entry align="center">ID</entry>
                    <entry align="center">AMT</entry>
                    <entry align="center">TIME</entry>
                    <entry align="center">DV</entry>
                    <entry align="center">WT</entry>
                 </row>
                 <row>
                    <entry align="center"><emphasis>Alias</emphasis></entry>
                    <entry align="center">---</entry>
                    <entry align="center">DOSE</entry>
                    <entry align="center">---</entry>
                    <entry align="center">CP</entry>
                    <entry align="center">---</entry>
                 </row>
              </thead>
              <tbody>
                 <row>
                    <entry morerows="5" align="center">---</entry>
                    <entry morerows="1" align="center">1</entry>
                    <entry align="center">4.02</entry>
                    <entry align="center">0.0</entry>
                    <entry align="center">0.74</entry>
                    <entry align="center">79.6</entry>
                 </row>
                 <row>
                    <entry align="center">0.0</entry>
                    <entry align="center">0.25</entry>
                    <entry align="center">2.84</entry>
                    <entry align="center">0.0</entry>
                 </row>
                 <row>
                    <entry morerows="2" align="center">2</entry>
                    <entry align="center">4.40</entry>
                    <entry align="center">0.0</entry>
                    <entry align="center">0.0</entry>
                    <entry align="center">72.4</entry>
                 </row>
                 <row>
                    <entry align="center">0.0</entry>
                    <entry align="center">0.27</entry>
                    <entry align="center">1.72</entry>
                    <entry align="center">0.0</entry>
                 </row>
                 <row>
                    <entry align="center">0.0</entry>
                    <entry align="center">0.52</entry>
                    <entry align="center">7.91</entry>
                    <entry align="center">0.0</entry>
                 </row>
              </tbody>
           </tgroup>
        </table>
     <sect2>     
        <title>A Realization of The Data Set Requirements</title>
        <anchor id="inddata"/>
        <programlisting>
// IndData.h
#include &lt;vector&gt;
#include &lt;valarray&gt;

template &lt;class T&gt;
class IndData{
   public:
      IndData( 
         const valarray&lt;T&gt;& idIn, 
         const valarray&lt;T&gt;& amtIn,
         const valarray&lt;T&gt;& timeIn,
         const valarray&lt;T&gt;& dvIn,
         const valarray&lt;T&gt;& wtIn );
      const valarray&lt;T&gt; id;
      const valarray&lt;T&gt; amt;
      const valarray&lt;T&gt; dose;
      const valarray&lt;T&gt; time;
      const valarray&lt;T&gt; dv;
      const valarray&lt;T&gt; cp;
      const valarray&lt;T&gt; wt;

      const valarray&lt;T&gt; theta;
      const valarray&lt;T&gt; eta;
      const valarray&lt;T&gt; eps;
      const valarray&lt;T&gt; ds;
      const valarray&lt;T&gt; w;
      const valarray&lt;T&gt; ka;
      const valarray&lt;T&gt; ke;
      const valarray&lt;T&gt; cl;
      const valarray&lt;T&gt; d;
      const valarray&lt;T&gt; e;
      const valarray&lt;T&gt; f;
      const valarray&lt;T&gt; y;

      ~IndData();

   protected:
      IndData();
      IndData( const IndData&lt;T&gt; & );
      const IndData& operator=( const IndData&lt;T&gt; & );
};

template &lt;class T&gt;
class IndDataSet{
   public:
      IndDataSet( int               nIn, 
                  const valarray&lt;T&gt; idIn[], 
                  const valarray&lt;T&gt; amtIn[],
                  const valarray&lt;T&gt; timeIn[],
                  const valarray&lt;T&gt; dvIn[],
                  const valarray&lt;T&gt; wtIn[] );
      ~IndDataSet();
      const IndData& operator[]( int n ) const;
   private:
      std::vector&lt;IndData*&gt; all;
      const int n;
   protected:
      IndDataSet();
      IndDataSet( const IndDataSet&lt;T&gt; & );
      const IndDataSet& operator=( const IndDataSet&lt;T&gt; & );
};
        </programlisting>
        <para/>
        <programlisting>
// IndData.cpp
#include "IndData.h"
#include &lt;valarray&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;map&gt;

template &lt;class T&gt;
IndData::IndData( 
         const valarray&lt;T&gt;& idIn, 
         const valarray&lt;T&gt;& amtIn,
         const valarray&lt;T&gt;& timeIn,
         const valarray&lt;T&gt;& dvIn,
         const valarray&lt;T&gt;& wtIn
  )
:
        id(idIn),
        amt(amtIn), dose(amtIn),
        time(timeIn),
        dv(dvIn), cp(dvIn),
        wt(wtIn)
{}
template &lt;class T&gt;
IndData::~IndData(){}

template &lt;class T&gt;
IndData::IndData(){}

template &lt;class T&gt;
IndData::IndData( const IndData & ){}

template &lt;class T&gt;
const IndData& IndData::operator=( const IndData& ){}

template &lt;class T&gt;
IndDataSet::IndDataSet( int nIn, 
      const valarray&lt;T&gt; idIn[], 
      const valarray&lt;T&gt; amtIn[],
      const valarray&lt;T&gt; timeIn[],
      const valarray&lt;T&gt; dvIn[],
      const valarray&lt;T&gt; wtIn[] )
      : n(nIn), all(nIn)
{
   for( int i=0; i&lt;n; i++ )
   {
      all[i] = new IndData( idIn[i], amtIn[i], timeIn[i], dvIn[i], wt[i] );
   }
}

template &lt;class T&gt;
IndDataSet::~IndDataSet()
{
   for( int i=0; i&lt;n; i++ )
      delete all[i];
}

template &lt;class T&gt;
const IndData & IndDataSet::operator[]( int i ) const
{
   return *all[i];
}

template &lt;class T&gt;
IndDataSet::IndDataSet(){}

template &lt;class T&gt;
IndDataSet::IndDataSet( const IndDataSet&lt;T&gt; & ){}

template &lt;class T&gt;
const IndDataSet & IndDataSet::operator=( const IndDataSet&lt;T&gt; & ){}
        </programlisting>
     </sect2>
  </sect1>
  <sect1>
     <title>Driver</title>
     <anchor id="driver"/>
     <para>
Besides models and data set, SPK needs a driver which initializes the parameters to
certain modules and call them.  
The parameters control the user defined models' behaviors and the SPK's optimization effort.
The driver is also responsible for preparing a report upon the normal
completion (regardless of whether successful or not).
     </para>
     <para>
Below are lists of tasks the driver must accomplish:
     </para>
     <para>
        <orderedlist>
           <title>Parameter Intializations and Routine Calls</title>
           <listitem>
              <para>
Initializing the parameters to <function>simulation()</function> 
and call it to obtain a data set when the data simulation is requested.
              </para>
           </listitem>
           <listitem>
              <para>
Organizing the data set (ie. <link linkend="inddata">IndDataSet</link>).
              </para>
           </listitem>
           <listitem>
              <para>
Initializing the parameters to <function>fitPopualation()</function> 
and call it when the pop analysis is requested, or call 
<function>fitIndividual()</function> instead
if the individual analysis is requested.
              </para>
           </listitem>
           <listitem>
              <para>
Initializing the paramteres to <function>popStatistics()</function>
and call it when the population analysis is completed and statistics are requested,
or call <function>indStatistics()</function> instead if the individual
analysis were completed.
              </para>
           </listitem>
        </orderedlist>
        <orderedlist continuation="continues">
           <title>Report preparation</title>
           <listitem>
              <para>
Composing an error/warning message if errors/warnings have been detected.
              </para>
           </listitem>
           <listitem>
              <para>
Converting the objective value (if available) to the NONMEM equivalent.
              </para>
           </listitem>
           <listitem>
              <para>
Obtaining the PRED values.
                 <table>
                    <title>Values</title>
                    <tgroup cols="5">
                       <thead>
                          <row>
                             <entry align="center">Simulation</entry>
                             <entry align="center">Estimation</entry>
                             <entry align="center">THETA</entry>
                             <entry align="center">ETA</entry>
                             <entry align="center">PRED, RES, WRES</entry>
                             <entry align="center">Others/Arbitrary</entry>
                          </row>
                       </thead>
                       <tbody>
                          <row>
                             <entry align="center">---</entry>
                             <entry align="center">---</entry>
                             <entry align="center">initial</entry>
                             <entry align="center">0</entry>
                             <entry align="center">typical</entry>
                             <entry align="center">typical</entry>
                          </row>
                          <row>
                             <entry align="center">---</entry>
                             <entry align="center">FO</entry>
                             <entry align="center">finial</entry>
                             <entry align="center">0</entry>
                             <entry align="center">typical</entry>
                             <entry align="center">typical</entry>
                          </row>
                          <row>
                             <entry align="center">---</entry>
                             <entry align="center">FOCE/Laplace</entry>
                             <entry align="center">final</entry>
                             <entry align="center">conditional</entry>
                             <entry align="center">conditional</entry>
                             <entry align="center">conditional</entry>
                          </row>
                          <row>
                             <entry align="center">yes</entry>
                             <entry align="center">---</entry>
                             <entry align="center">initial</entry>
                             <entry align="center">0</entry>
                             <entry align="center">typical</entry>
                             <entry align="center">typical</entry>
                          </row>
                          <row>
                             <entry align="center">yes</entry>
                             <entry align="center">FO</entry>
                             <entry align="center">final</entry>
                             <entry align="center">0</entry>
                             <entry align="center">typical</entry>
                             <entry align="center">typical</entry>
                          </row>
                          <row>
                             <entry align="center">yes</entry>
                             <entry align="center">FOCE/Laplace</entry>
                             <entry align="center">final</entry>
                             <entry align="center">conditional</entry>
                             <entry align="center">conditional</entry>
                             <entry align="center">conditional</entry>
                          </row>
                       </tbody>
                    </tgroup>
                 </table>
                 <variablelist>
                    <varlistentry>
                       <term>typical</term>
                       <listitem>
                          <para>means average, which implies the value is evaluated at ETA=0.</para>
                       </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>conditional</term>
                       <listitem>
                          <para>means whatever available. Typically implies, the value is evaluated at the final estimate of THETA if it is available.
                          </para>
                       </listitem>
                    </varlistentry>
                 </variablelist>
              </para>
           </listitem>
           <listitem>
              <para>
Composing a <ulink url="../reportML/reportML.html">SpkReportML</ulink> document for reporting the errors (if occured),
the population/individual analysis results, the PRED values and statistics values.
              </para>
           </listitem>
        </orderedlist>
     </para>
     <sect2>
        <title>A Realization of The Driver Requirements</title>
        <programlisting>
<emphasis>TBA</emphasis>
        </programlisting>
     </sect2>
  </sect1>
</article>
