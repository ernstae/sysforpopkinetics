#!/usr/bin/perl -w

#*********************************************************************************
#
# File: SpkOutput.pm
#
#
# Parses an XML file that contains values calculated using SPK.
#
# Author: Mitch Watrous
#
#
# Exported Symbols
# ----------------
#
# parseSpkValues
#
# Subroutine that parses the XML file.
#
#
# $parEstCalc
#
# Indicates whether or not the parameter estimation step was attempted.
#
#
# $parEstOk
#
# Indicates whether or not the parameter estimation step succeeded.
#
#
# $SECalc
#
# Indicates whether or not the standard errors step was attempted.
#
#
# $SEOk
#
# Indicates whether or not the standard errors step succeeded.
#
#
# $messages
#
# Text generated by SPK during either the parameter estimation or 
# standard errors step.
#
#
# $popEpsilon
#
# Tolerance parameter for determining if a fixed population parameter 
# value is accepted as an estimate for the true minimizer of the 
# parametric population objective function. 
#
#
# $objApproxMethod
#
# The SPK approximation for the objective function that was used.
#
#
# $objVal
#
# The NONMEM objective function value equivalent to the SPK objective 
# function value.
#
#
# $objRelTol
#
# Relative tolerance for comparing the NONMEM objective value to
# the NONMEM objective function value equivalent to the SPK objective 
# function value.
#
#
# $thetaNonPar
#
# Reference to an array containing true or false values that indicate 
# which theta elements are parameterized the same way as their NONMEM
# counterparts.
#
#
# $thetaLow
#
# Reference to an array containing the lower limit for the theta value.
# Elements that were not calculated are indicated by a value of "no_value".
#
#
# $thetaUp
#
# Reference to an array containing the upper limit for the theta value.
# Elements that were not calculated are indicated by a value of "no_value".
#
#
# $thetaOut
#
# Reference to an array containing the final theta value.
# Elements that were not calculated are indicated by a value of "no_value".
#
#
# $thetaSE
#
# Reference to an array containing the standard errors for the final
# theta value.  Elements that were not calculated are indicated by a 
# value of "no_value".
#
#
# $thetaRelTol
#
# Relative tolerance for comparing NONMEM and SPK theta values.
#
#
# $OmegaNonPar
#
# If Omega is full, this is a reference to an array of arrays containing
# true or false values that indicate which elements from the lower triangle
# of Omega are parameterized the same way as their NONMEM counterparts.
# If Omega is diagonal, only the diagonal elements are present.
#
#
# $OmegaLow
#
# If Omega is full, this is a reference to an array of arrays containing
# the elements from the lower triangle of lower limit for the Omega value. 
# If Omega is diagonal, only the diagonal elements are present.
# Elements that were not calculated are indicated by a value of "no_value".
#
#
# $OmegaUp
#
# If Omega is full, this is a reference to an array of arrays containing
# the elements from the lower triangle of upper limit for the Omega value. 
# If Omega is diagonal, only the diagonal elements are present.
# Elements that were not calculated are indicated by a value of "no_value".
#
#
# $OmegaOut
#
# If Omega is full, this is a reference to an array of arrays containing
# the elements from the lower triangle of the final Omega value.  
# If Omega is diagonal, only the diagonal elements are present.
# Elements that were not calculated are indicated by a value of "no_value".
#
#
# $OmegaSE 
#
# If Omega is full, this is a reference to an array of arrays containing
# the standard errors for the lower triangle of the final Omega value.  
# If Omega is diagonal, only the diagonal elements' standard errors are 
# present.  Elements that were not calculated are indicated by a value 
# of "no_value".
#
#
# $OmegaRelTol
#
# Relative tolerance for comparing NONMEM and SPK Omega values.
#
#
# $SigmaNonPar
#
# If Sigma is full, this is a reference to an array of arrays containing
# true or false values that indicate which elements from the lower triangle
# of Sigma are parameterized the same way as their NONMEM counterparts.
# If Sigma is diagonal, only the diagonal elements are present.
#
#
# $SigmaLow
#
# If Sigma is full, this is a reference to an array of arrays containing
# the elements from the lower triangle of lower limit for the Sigma value. 
# If Sigma is diagonal, only the diagonal elements are present.
# Elements that were not calculated are indicated by a value of "no_value".
#
#
# $SigmaUp
#
# If Sigma is full, this is a reference to an array of arrays containing
# the elements from the lower triangle of upper limit for the Sigma value. 
# If Sigma is diagonal, only the diagonal elements are present.
# Elements that were not calculated are indicated by a value of "no_value".
#
#
# $SigmaOut
#
# If Sigma is full, this is a reference to an array of arrays containing
# the elements from the lower triangle of the final Sigma value.  
# If Sigma is diagonal, only the diagonal elements are present.
# Elements that were not calculated are indicated by a value of "no_value".
#
#
# $SigmaSE 
#
# If Sigma is full, this is a reference to an array of arrays containing
# the standard errors for the lower triangle of the final Sigma value.  
# If Sigma is diagonal, only the diagonal elements' standard errors are 
# present.  Elements that were not calculated are indicated by a value 
# of "no_value".
#
#
# $SigmaRelTol
#
# Relative tolerance for comparing NONMEM and SPK Sigma values.
#
#
# $covOfEstNonPar
#
# A reference to an array of arrays containing true or false values that 
# indicate which elements from the lower triangle of the covariance matrix 
# of the parameter estimates are parameterized the same way as their NONMEM
# counterparts.
#
#
# $covOfEst
#
# A reference to an array of arrays containing the lower triangle of the 
# covariance matrix of the parameter estimates.  A value of "no_value" 
# indicates that the particular element was not calculated.
#
#
# $covOfEstRelTol
#
# Relative tolerance for comparing NONMEM and SPK covariance of the 
# estimate values.
#
#
# $corrOfEstNonPar
#
# A reference to an array of arrays containing true or false values that 
# indicate which elements from the lower triangle of the correlation matrix 
# of the parameter estimates are parameterized the same way as their NONMEM
# counterparts.
#
#
# $corrOfEst
#
# A reference to an array of arrays containing the lower triangle of the 
# correlation matrix of the parameter estimates.  A value of "no_value" 
# indicates that the particular element was not calculated.
#
#
# $corrOfEstRelTol
#
# Relative tolerance for comparing NONMEM and SPK correlation of the 
# estimate values.
#
#
# $etaForAllNonPar
#
# A reference to an array of arrays containing true or false values that 
# indicate which elements from the matrix of estimates for the true minimizers
# of the individual objective functions are parameterized the same way as 
# their NONMEM counterparts.
#
#
# $etaForAllOut
#
# A reference to an array of arrays containing the matrix of estimates for 
# the true minimizers of the individual objective functions.  Each column 
# of this matrix corresponds to the eta value for a particular individual.
# A value of "no_value" indicates that the particular element was not calculated.
#
#
# $etaForAllRelTol
#
# Relative tolerance for comparing NONMEM and SPK eta values.
#
#
# $predForAllOut
#
# A reference to an array of arrays containing a "matrix" of data mean 
# model values for each of the individual's data points evaluated using the 
# final values for the fixed effects and for that individual's random effects.
# Each row of this "matrix" contains the model values for a particular individual.
# Note that because each row may contain different number of elements, this 
# is not truly a matrix in the mathematical sense.  A value of "no_value" 
# indicates that the particular element was not calculated.
#
#
# $predForAllRelTol
#
# Relative tolerance for comparing NONMEM and SPK data mean model (PRED) values.
#
#*********************************************************************************

#------------------------------------------------------------------------
# Preliminaries.
#------------------------------------------------------------------------

use strict;

package SpkOutput;

# Specify the symbols that will be exported 
require Exporter;
our @ISA       = qw( Exporter );
our @EXPORT    = qw( parseSpkValues
                     $parEstCalc
                     $parEstOk
                     $SECalc
                     $SEOk
                     $messages
                     $popEpsilon
                     $objApproxMethod
                     $objVal
                     $objRelTol
                     $thetaNonPar
                     $thetaLow
                     $thetaUp
                     $thetaOut
                     $thetaSE
                     $thetaRelTol
                     $OmegaStructure
                     $OmegaNonPar
                     $OmegaLow
                     $OmegaUp
                     $OmegaOut
                     $OmegaSE
                     $OmegaRelTol
                     $SigmaStructure
                     $SigmaNonPar
                     $SigmaLow
                     $SigmaUp
                     $SigmaOut
                     $SigmaSE
                     $SigmaRelTol
                     $covOfEstNonPar
                     $covOfEst
                     $covOfEstRelTol
                     $corrOfEstNonPar
                     $corrOfEst
                     $corrOfEstRelTol
                     $etaForAllNonPar
                     $etaForAllOut
                     $etaForAllRelTol
                     $predForAllOut
                     $predForAllRelTol );


#*****************************************************************
#
# Subroutine: parseSpkValues
#
#
# Parses an XML file that contains values calculated using SPK.
#
#
# Arguments
# ---------
# 
# $_[0]
# 
# Path and name for the XML file that contains the values 
# calculated using SPK.
# 
#*****************************************************************

sub parseSpkValues
{
  #---------------------------------------------------------------
  # Preliminaries.
  #---------------------------------------------------------------

  my $j;
  my $ref;
  my $val;


  #---------------------------------------------------------------
  # Get a data structure containing the fields from the XML file.
  #---------------------------------------------------------------

  # Check that the output file specified by the input argument exists.
  my $file = $_[0];
  -f $file or die "Can't find file \"$file\"";

  # Parse the XML file that contains the values calculated using SPK.
  use XML::Simple;
  my $parsedFile = XMLin( $file, forcearray => 1 );

  # [Revisit - Should the Version of SPK be Checked - Mitch]
  # Should the version of the SPK library and the version of the test 
  # driver that generated the results be checked?
  #
  ## Check the source of the XML file.
  #$parsedFile->{source}->[0]->{driver}->[0] eq "DiffEqnModelTest"
  #  or die "The SpkDriver output file was generated by an unknown source.\n";

  #[Remove]================================
  #
  #use Data::Dumper;
  #print "The following was extracted from $file:\n";
  #print Dumper( $parsedFile );
  #
  #[Remove]================================


  #---------------------------------------------------------------
  # Get the values calculated using SPK and related information.
  #---------------------------------------------------------------

  # Get status information.
  our $parEstCalc = $parsedFile->{status}->[0]->{paramEstimationStep}->[0]->{attempted}->[0];
  our $parEstOk   = $parsedFile->{status}->[0]->{paramEstimationStep}->[0]->{succeeded}->[0];
  our $SECalc     = $parsedFile->{status}->[0]->{standardErrorsStep} ->[0]->{attempted}->[0];
  our $SEOk       = $parsedFile->{status}->[0]->{standardErrorsStep} ->[0]->{succeeded}->[0];

  # Get any messages and the population level tolerance parameter.
  our $messages   = $parsedFile->{messages}  ->[0];
  our $popEpsilon = $parsedFile->{popEpsilon}->[0];

  # Get information related to the NONMEM equivalent objective function.
  our $objApproxMethod = $parsedFile->{objective}->[0]->{approximation}->[0];
  our $objVal          = $parsedFile->{objective}->[0]->{nonmemEquiv}  ->[0];
  our $objRelTol       = $parsedFile->{objective}->[0]->{relTol}       ->[0];

  # Get information related to theta.
  our $thetaRelTol = $parsedFile->{theta}->[0]->{relTol}->[0];

  # These are references to arrays.
  our $thetaNonPar = $$parsedFile{theta}->[0]->{nonmemParam}   ->[0];
  our $thetaLow    = $$parsedFile{theta}->[0]->{low}           ->[0];
  our $thetaUp     = $$parsedFile{theta}->[0]->{up}            ->[0];
  our $thetaOut    = $$parsedFile{theta}->[0]->{out}           ->[0];
  our $thetaSE     = $$parsedFile{theta}->[0]->{standardErrors}->[0];

  # Get information related to Omega.
  our $OmegaStructure = $parsedFile->{Omega}->[0]->{structure}->[0];
  our $OmegaRelTol    = $parsedFile->{Omega}->[0]->{relTol}   ->[0];

  # These are references to arrays of arrays.
  our $OmegaNonPar  = $$parsedFile{Omega}->[0]->{nonmemParam};
  our $OmegaLow     = $$parsedFile{Omega}->[0]->{low};
  our $OmegaUp      = $$parsedFile{Omega}->[0]->{up};
  our $OmegaOut     = $$parsedFile{Omega}->[0]->{out};
  our $OmegaSE      = $$parsedFile{Omega}->[0]->{standardErrors};

  # Get information related to Sigma.
  our $SigmaStructure = $parsedFile->{Sigma}->[0]->{structure}->[0];
  our $SigmaRelTol    = $parsedFile->{Sigma}->[0]->{relTol}   ->[0];

  # These are references to arrays of arrays.
  our $SigmaNonPar  = $$parsedFile{Sigma}->[0]->{nonmemParam};
  our $SigmaLow     = $$parsedFile{Sigma}->[0]->{low};
  our $SigmaUp      = $$parsedFile{Sigma}->[0]->{up};
  our $SigmaOut     = $$parsedFile{Sigma}->[0]->{out};
  our $SigmaSE      = $$parsedFile{Sigma}->[0]->{standardErrors};

  # Get information related to the covariance matrix of the parameter 
  # estimates.  These are references to arrays of arrays.
  our $covOfEstNonPar = $$parsedFile{covarianceOfEstimate}->[0]->{nonmemParam};
  our $covOfEstOut    = $$parsedFile{covarianceOfEstimate}->[0]->{out};

  # Get information related to the correlation matrix of the parameter 
  # estimates.  These are references to arrays of arrays.
  our $corrOfEstNonPar  = $$parsedFile{correlationOfEstimate}->[0]->{nonmemParam};
  our $corrOfEstOut     = $$parsedFile{correlationOfEstimate}->[0]->{out};

  # Get information related to the individual objective function minimizers.
  our $etaForAllRelTol  = $parsedFile->{etaForAllIndividuals}->[0]->{relTol}->[0];

  # These are references to arrays of arrays.
  our $etaForAllNonPar  = $$parsedFile{etaForAllIndividuals}->[0]->{nonmemParam};
  our $etaForAllOut     = $$parsedFile{etaForAllIndividuals}->[0]->{out};

  # Get information related to the individuals' data mean model values.
  our $predForAllRelTol = $parsedFile->{predForAllIndividuals}->[0]->{relTol}->[0];

  # These are references to arrays of arrays.
  our $predForAllOut    = $$parsedFile{predForAllIndividuals}->[0]->{out};


  #---------------------------------------------------------------
  # Check the dimensions of the values.
  #---------------------------------------------------------------

  my $nTheta  = scalar( @$thetaOut );
  my $nOmega  = scalar( @$OmegaOut );
  my $nSigma  = scalar( @$SigmaOut );
  my $nEta    = scalar( @$etaForAllOut );
  my $nInd    = scalar( @{$etaForAllOut->[ 0 ]} );

  # Determine the total number of fixed effects parameters.
  my $nFixedEffects = $nTheta;
  for ( $j = 0; $j < $nOmega; $j++ )
  {
    $nFixedEffects += scalar( @{$OmegaOut->[ $j ]} );
  }
  for ( $j = 0; $j < $nSigma; $j++ )
  {
    $nFixedEffects += scalar( @{$SigmaOut->[ $j ]} );
  }

  # Check the lengths for the theta related values.
  scalar( @$thetaNonPar ) == $nTheta
    or die "The length of the theta NONMEM parameterization flag is not correct.\n";
  scalar( @$thetaLow )    == $nTheta
    or die "The length of the theta lower limits is not correct.\n";
  scalar( @$thetaUp )     == $nTheta
    or die "The length of the theta upper limits is not correct.\n";
  scalar( @$thetaSE )     == $nTheta
    or die "The length of the theta standard errors is not correct.\n";

  # Check the number of rows for the Omega related values.
  scalar( @$OmegaNonPar ) == $nOmega
    or die "The row dimensions of the Omega NONMEM parameterization flag are not correct.\n";
  scalar( @$OmegaLow )    == $nOmega
    or die "The row dimensions of the Omega lower limits are not correct.\n";
  scalar( @$OmegaUp )     == $nOmega
    or die "The row dimensions of the Omega upper limits are not correct.\n";
  scalar( @$OmegaSE )     == $nOmega
    or die "The row dimensions of the Omega standard errors are not correct.\n";

  # Check the number of columns for the Omega related values.
  for ( $j = 0; $j < $nOmega; $j++ )
  {
    scalar( @{$OmegaOut->[ $j ]} ) == scalar( @{$OmegaNonPar->[ $j ]} )
      or die "The column dimensions of the Omega NONMEM parameterization flag are not correct.\n";
    scalar( @{$OmegaOut->[ $j ]} ) == scalar( @{$OmegaLow->[ $j ]} )
      or die "The column dimensions of the Omega lower limits are not correct.\n";
    scalar( @{$OmegaOut->[ $j ]} ) == scalar( @{$OmegaUp->[ $j ]} )
      or die "The column dimensions of the Omega upper limits are not correct.\n";
    scalar( @{$OmegaOut->[ $j ]} ) == scalar( @{$OmegaSE->[ $j ]} )
      or die "The column dimensions of the Omega standard errors are not correct.\n";
  }

  # Check the number of rows for the Sigma related values.
  scalar( @$SigmaNonPar ) == $nSigma
    or die "The row dimensions of the Sigma NONMEM parameterization flag are not correct.\n";
  scalar( @$SigmaLow )    == $nSigma
    or die "The row dimensions of the Sigma lower limits are not correct.\n";
  scalar( @$SigmaUp )     == $nSigma
    or die "The row dimensions of the Sigma upper limits are not correct.\n";
  scalar( @$SigmaSE )     == $nSigma
    or die "The row dimensions of the Sigma standard errors are not correct.\n";

  # Check the number of columns for the Sigma related values.
  for ( $j = 0; $j < $nSigma; $j++ )
  {
    scalar( @{$SigmaOut->[ $j ]} ) == scalar( @{$SigmaNonPar->[ $j ]} )
      or die "The column dimensions of the Sigma NONMEM parameterization flag are not correct.\n";
    scalar( @{$SigmaOut->[ $j ]} ) == scalar( @{$SigmaLow->[ $j ]} )
      or die "The column dimensions of the Sigma lower limits are not correct.\n";
    scalar( @{$SigmaOut->[ $j ]} ) == scalar( @{$SigmaUp->[ $j ]} )
      or die "The column dimensions of the Sigma upper limits are not correct.\n";
    scalar( @{$SigmaOut->[ $j ]} ) == scalar( @{$SigmaSE->[ $j ]} )
      or die "The column dimensions of the Sigma standard errors are not correct.\n";
  }

  # Check the number of rows for the parameter estimates covariance matrix.
  scalar( @$covOfEstNonPar )  == $nFixedEffects
    or die "The row dimensions of the parameter estimates covariance matrix NONMEM parameterization flag are not correct.\n";
  scalar( @$covOfEstOut )     == $nFixedEffects
    or die "The row dimensions of the parameter estimates covariance matrix out value are not correct.\n";

  # Check the number of columns for the parameter estimates covariance matrix.
  for ( $j = 0; $j < $nFixedEffects; $j++ )
  {
    # This matrix is always full so each row contains all of the 
    # elements up to and including the diagonal element.
    scalar( @{$covOfEstNonPar->[ $j ]} )  == $j + 1
      or die "The column dimensions of the parameter estimates covariance matrix NONMEM parameterization flag are not correct.\n";
    scalar( @{$covOfEstOut->[ $j ]} )     == $j + 1
    or die "The column dimensions of the parameter estimates covariance matrix out value are not correct.\n";
  }

  # Check the number of rows for the parameter estimates correlation matrix.
  scalar( @$corrOfEstNonPar )  == $nFixedEffects
    or die "The row dimensions of the parameter estimates correlation matrix NONMEM parameterization flag are not correct.\n";
  scalar( @$corrOfEstOut )     == $nFixedEffects
    or die "The row dimensions of the parameter estimates correlation matrix out value are not correct.\n";

  # Check the number of columns for the parameter estimates correlation matrix.
  for ( $j = 0; $j < $nFixedEffects; $j++ )
  {
    # This matrix is always full so each row contains all of the 
    # elements up to and including the diagonal element.
    scalar( @{$corrOfEstNonPar->[ $j ]} )  == $j + 1
      or die "The column dimensions of the parameter estimates correlation matrix NONMEM parameterization flag are not correct.\n";
    scalar( @{$corrOfEstOut->[ $j ]} )     == $j + 1
    or die "The column dimensions of the parameter estimates correlation matrix out value are not correct.\n";
  }

  # Check the number of rows for the individual objective function minimizers.
  scalar( @$etaForAllNonPar )  == $nEta
    or die "The row dimensions of the individual objective minimizers NONMEM parameterization flag are not correct.\n";

  # Check the number of columns for the individual objective function minimizers.
  for ( $j = 0; $j < $nEta; $j++ )
  {
    # Each row should have one column for each individual.
    scalar( @{$etaForAllNonPar->[ $j ]} ) == $nInd
      or die "The column dimensions of the individual objective minimizers NONMEM parameterization flag are not correct.\n";
    scalar( @{$etaForAllOut->[ $j ]} )    == $nInd
      or die "The column dimensions of the individual objective minimizers out value are not correct.\n";
  }

  # Check the number of rows for the individuals' data mean model values.
  scalar( @$predForAllOut )  == $nInd
    or die "The row dimensions of the individuals' data mean model values are not correct.\n";

}


#*********************************************************************************
#
# Module return value.
#
#*********************************************************************************

1;
