<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                  "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd"[
  <!ENTITY uw "University of Washington">
  <!ENTITY dept "Department of Bioengineering">
]>
<article><title>Database Schema</title>
 <articleinfo>
    <revhistory>
      <revision>
	<revnumber>1.0</revnumber>
	<date>November 19, 2003</date>
	<authorinitials>afw</authorinitials>
	<revremark>Initial version.</revremark>
      </revision>
      <revision>
	<revnumber>1.01</revnumber>
	<date>November 21, 2003</date>
	<authorinitials>afw</authorinitials>
	<revremark>Clarified description of xml_source.</revremark>
      </revision>
      <revision>
	<revnumber>1.02</revnumber>
	<date>December 26, 2003</date>
	<authorinitials>afw</authorinitials>
	<revremark>Added discussion of transaction processing.</revremark>
      </revision>
      <revision>
	<revnumber>1.03</revnumber>
	<date>February 3, 2004</date>
	<authorinitials>afw</authorinitials>
	<revremark>Various modifications to schema.</revremark>
      </revision>
      <revision>
	<revnumber>1.04</revnumber>
	<date>November 19, 2005</date>
	<authorinitials>jd</authorinitials>
	<revremark>More additions to schema.</revremark>
      </revision>
      <revision>
	<revnumber>1.05</revnumber>
	<date>May 9, 2006</date>
	<authorinitials>jd</authorinitials>
	<revremark>More additions to schema.</revremark>
      </revision>
    </revhistory>
  <abstract>
      <para>
	The schema for the Spk database (spkdb) is presented in SQL.
	In addition, the context for the database design is 
	presented, as well as a short description of each table
	and each field.
      </para>
  </abstract>
 </articleinfo>
  <sect1>
    <title>Introduction</title>
    <para>
      This specification describes the logical design of the
      Spk database.  It complements two other specifications:
      <itemizedlist>
	<listitem>
	  <para>
	    <ulink url="../erModel/erModel.html">
	      Database Entity-Relationship Model
	    </ulink>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <ulink url="../jobHistory/jobHistory.html">
	      Job History Model
	    </ulink>
	  </para>
	</listitem>
      </itemizedlist>
    </para>
  </sect1>
  <sect1>
    <title>Architectural Context</title>
    <para>
      The Spk system architecture is comprised of three major 
      independent processes, each of which may have multiple
      instances running simultaneously.  The major processes
      are the following:
      <orderedlist>
	<listitem>
	  <para> 
	    <emphasis>MDA Surrogate.</emphasis>
	    The Model Design Agent is a client application which
	    runs on the user's workstation.  There will typically
	    be many MDAs in operation at any given time.  Each
	    MDA communicates with the rest of Spk via a secure
	    Internet connection to a web server.  The portion of
	    the web server which supports the MDA is called 
	    the MDA Surrogate.  For performance reasons, the
	    architecture permits multiple MDA Surrogates to 
	    be running simultaneously on one or more server
	    machines.  
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <emphasis>Aspk Compiler</emphasis>.  The Application
	    Server for Population Kinetics is a specialized compiler
	    which translates model specifications received from 
	    MDAs into C++ source code to be compiled and linked
	    into object code and then run by the Cspk. To 
	    optimize performance, there can be multiple Aspk
	    Compilers running simultaneously on one or more
	    server machines.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <emphasis>Cspk</emphasis>.  The Computational Server
	    for Population Kinetics receives source code for a
	    model along with scientific
	    data from the Aspk, utilizes a C++ compiler and linker
	    to build a representation of the model in object code,
	    and then executes it.  There can be multiple
	    Cspk server machines and processor clusters.
	  </para>
	</listitem>
      </orderedlist>
    </para>
    <para>
      These three tasks run continuously and, hence, are
      the type of processes known as <emphasis>daemons</emphasis>.
      A daemon is implemented and installed in such a way that
      it starts automatically when the host computer on 
      which it runs is booted up, and it stops gracefully when
      the machine is shut down.
    </para>
    <para>
      The Spk database is <emphasis>the sole means of communication</emphasis>
      between these daemons. It plays, 
      therefore, a central role in the Spk architecture.  The principal
      interprocess communications are the following:
      <itemizedlist>
	<listitem>
	  <para>
	    <emphasis>MDA Surrogate to Aspk Compiler</emphasis>.
	    The MDA submits a user job, via the Surrogate,
	    by creating a new row
	    in the <emphasis>job</emphasis> table, storing
	    the model in the <emphasis>xml_source</emphasis> field,
	    the data in the <emphasis>xml_data</emphasis> field,
	    the user's identification number in the
	    <emphasis>user_id</emphasis> field, and
	    setting the <emphasis>state_code</emphasis> field to
	    "Queued to Compile".
	    The Aspk Compiler 
	    selects the job from the queue when it has become the highest
	    priority job with "Queued to Compile" status,
	    retrieving the model and data and setting 
	    <emphasis>state_code</emphasis> to "Compiling".
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <emphasis>Aspk Compiler to MDA</emphasis>. If, for any 
	    reason, the compilation process fails, the Aspk Compiler
	    stores an error report in the
	    <emphasis>report</emphasis> field of the 
	    job, sets <emphasis>state_code </emphasis> to "End"
	    and <emphasis>end_code</emphasis>
	    to "Compilation Error".  When querying the database,
	    an MDA Surrogate notices that one of its jobs has reached the
	    "End" state and retrieves the report from the database.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <emphasis>Aspk Compiler to Cspk</emphasis>.  If the model
	    compiles successfully, the Aspk Compiler stores
	    an archive of C++ source code and data into the 
	    <emphasis>cpp_source</emphasis> field of the job
	    and sets <emphasis>state_code</emphasis> to "Queued to Run".
	    A Cspk selects the job when it is the job of highest
	    priority in the "Queued to Run" state, retrieving 
	    the source code and data and setting 
	    <emphasis>state_code</emphasis> to "Running".
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <emphasis>Cspk to MDA Surrogate</emphasis>.  
	    When the model runs to completion, the Cspk stores
	    the final report in the <emphasis>report</emphasis>
	    field of the job, sets <emphasis>state_code</emphasis>
	    to "End" and <emphasis>end_code</emphasis> to
	    "Successful Run".  When an MDA Surrogate notices that one of
	    its jobs had reached the "End" state, 
	    it retrieves the final report.
	  </para>
	</listitem>
      </itemizedlist>
     </para>
    <para>
      Several very important points must be emphasized:
      <itemizedlist>
	<listitem>
	  <para>
	    All the high-level interprocess communication described
	    above is <emphasis>asynchronous</emphasis>. The loose
	    coupling between the daemons is very attractive from
	    an operational standpoint because additional instances
	    of the daemons can be easily added or subtracted at
	    any time.  There is a slight penalty to be paid in 
	    terms of communications latency, but this is negligible
	    given the low activity level in the queues.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Multiple processes may be updating the 
	    <emphasis>job</emphasis> table simultaneously. 
	    These updates must be <emphasis>atomic</emphasis>
	    transactions.
	  </para>
	</listitem>
      </itemizedlist>
    </para>
  </sect1>
  <sect1>
    <title>Transaction Processing Considerations</title>
    <para>
      In general, multiple independent processes will be modifying
      the database simultaneously. In designing the database, it is
      imperative to anticipate situations in which two processes,
      attempting to do the same thing at the same time, could damage
      database logical integrity.
    </para>
    <para>
      As an example, consider the selection of the highest priority
      job from the compiler queue.  There may be several copies
      of the Aspk Compiler running concurrently, and two of these
      might attempt to a job from the queue simultaneously.
      The selection of a job entails the following:
      <orderedlist>
	<listitem>
	  <para>
	    Select from the <emphasis>job</emphasis>
	    table the job of highest priority
	    which has state_code = 'q2c'.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Change the state_code field from 'q2c' to 'cmp', to 
	    logically remove the job from the compiler queue.
	  </para>
	</listitem>
      </orderedlist>
    </para>
    <para>
      Both steps must occur as a single transaction, even though
      time might elapse in between.  If this constraint is not 
      enforced the following is one example of what might happen:
      <orderedlist>
	<listitem>
	  <para>
	    Compiler-1 selects the highest priority job.  
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Before Compiler-1 can change the state_code in the job,
	    compiler-2 selects the same job.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Both Compiler-1 and Compiler-2 compile the job and 
	    queue it to be run.  This is a waste of resources.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Since the job has been queued twice, it runs twice.  
	    This is a huge waste of resources and is very likely
	    to confuse the user.
	  </para>
	</listitem>
      </orderedlist>
    </para>
    <para>
      In Version 4 of MySQL, transaction support is provided for
      tables of type 'InnoDB'.  To avoid the problem described above,
      the <emphasis>job</emphasis> table must be created with with
      'InnoDB' type, and within programs, the steps required for
      removing a job from a queue occur between SQL <command>begin</command>
      and <command>end</command> statements.
    </para>
    <para>
      In the <link linkend="tables_and_fields">Tables and Fields</link> section,
      transaction processing considerations will be discussed for each table.
    </para>
  </sect1>
  <sect1>
    <title>SQL Schema</title>
    <para>
      The following SQL statements will create an empty copy of 
      the Spkdb database.
      <screen>
CREATE TABLE class (
  class_code char(2) NOT NULL default '',
  class_name char(20) default NULL,
  parent_required tinyint(1) default '0',
  PRIMARY KEY  (class_code)
) TYPE=MyISAM;

CREATE TABLE dataset (
  dataset_id int(10) unsigned NOT NULL auto_increment,
  name varchar(20) NOT NULL default '',
  abstract varchar(100) NOT NULL default '',
  archive longblob,
  user_id int(10) unsigned NOT NULL default '0',
  PRIMARY KEY  (dataset_id),
  UNIQUE KEY user_id (user_id,name)
) TYPE=InnoDB;

CREATE TABLE end (
  end_code char(4) NOT NULL default '',
  end_name char(20) default NULL,
  PRIMARY KEY  (end_code)
) TYPE=MyISAM;

CREATE TABLE history (
  history_id int(10) unsigned NOT NULL auto_increment,
  event_time int(10) unsigned NOT NULL default '0',
  state_code varchar(4) NOT NULL default '',
  job_id int(10) unsigned NOT NULL default '0',
  host varchar(100) NOT NULL default '',
  PRIMARY KEY  (history_id)
  KEY `idx_history_job_id` (`job_id`)
) TYPE=InnoDB;

CREATE TABLE job (
  job_id int(10) unsigned NOT NULL auto_increment,
  user_id int(10) unsigned NOT NULL default '0',
  abstract varchar(100) NOT NULL default '',
  dataset_id int(10) unsigned NOT NULL default '0',
  dataset_version varchar(10) NOT NULL default '',
  model_id int(10) unsigned NOT NULL default '0',
  model_version varchar(10) NOT NULL default '',
  xml_source longblob,
  checkpoint longblob,
  state_code varchar(4) NOT NULL default '',
  report longblob,
  start_time int(10) unsigned NOT NULL default '0',
  event_time int(10) unsigned NOT NULL default '0',
  cpp_source longblob,
  end_code varchar(4) default NULL,
  method_code char(2) default NULL,
  parent int(10) unsigned default '0',
  mail tinyint(1) default '0',
  share_with int(10) unsigned NOT NULL default '0',
  PRIMARY KEY  (job_id)
  KEY `idx_job_user_id` (`user_id`)
  KEY `idx_job_share_with` (`share_with`)
) TYPE=InnoDB;

CREATE TABLE method (
  method_code char(2) NOT NULL default '',
  method_name char(20) default NULL,
  class_code char(2) NOT NULL default '',
  test_only tinyint(1) default '0',
  PRIMARY KEY  (method_code)
) TYPE=MyISAM;

CREATE TABLE model (
  model_id int(10) unsigned NOT NULL auto_increment,
  name varchar(20) NOT NULL default '',
  abstract varchar(100) NOT NULL default '',
  archive longblob,
  user_id int(10) unsigned NOT NULL default '0',
  PRIMARY KEY  (model_id),
  UNIQUE KEY user_id (user_id,name)
) TYPE=InnoDB;

CREATE TABLE state (
  state_code char(4) NOT NULL default '',
  state_name char(20) default NULL,
  PRIMARY KEY  (state_code)
) TYPE=MyISAM;

CREATE TABLE user (
  user_id int(10) unsigned NOT NULL auto_increment,
  first_name varchar(30) NOT NULL default '',
  surname varchar(40) NOT NULL default '',
  password varchar(32) NOT NULL default '',
  username varchar(20) NOT NULL default '',
  company varchar(30) NOT NULL default '',
  country varchar(20) NOT NULL default '',
  state varchar(20) NOT NULL default '',
  email varchar(40) default NULL,
  test tinyint(1) default '0',
  dev tinyint(1) default '0',
  team_id int(10) unsigned NOT NULL,
  register_time timestamp default now(),
  contact tinyint(1) NOT NULL default '1', 
  PRIMARY KEY  (user_id),
  UNIQUE KEY username (username)
) TYPE=InnoDB;

CREATE TABLE team (
  team_id int(10) unsigned NOT NULL auto_increment,
  team_name varchar(20) NOT NULL default '',
  PRIMARY KEY  (team_id),
  UNIQUE KEY `team_name` (team_name)
) Type=InnoDB;

      </screen>
    </para>
  </sect1>
  <sect1>
    <title>Static Data</title>
    <para>
      The following SQL statements will populate static data fields in the
      database:
      <screen>
INSERT INTO class (class_code, class_name, parent_required) VALUES ('al','Approx. Likelihood',0);
INSERT INTO class (class_code, class_name, parent_required) VALUES ('le','Likelihood Eval.',1);
INSERT INTO class (class_code, class_name, parent_required) VALUES ('so','Simulation Only',0);
INSERT INTO class (class_code, class_name, parent_required) VALUES ('id','identifiability',0);

INSERT INTO end (end_code, end_name) VALUES ('cerr','Compiler Error');
INSERT INTO end (end_code, end_name) VALUES ('herr','Hard Fault');
INSERT INTO end (end_code, end_name) VALUES ('serr','Software Error');
INSERT INTO end (end_code, end_name) VALUES ('srun','Successful Run');
INSERT INTO end (end_code, end_name) VALUES ('abrt','User Abort');
INSERT INTO end (end_code, end_name) VALUES ('staf','Opt OK, Stat Failure');
INSERT INTO end (end_code, end_name) VALUES ('othe','Unsuccessful Run');
INSERT INTO end (end_code, end_name) VALUES ('othf','Unknown Run Failure');
INSERT INTO end (end_code, end_name) VALUES ('acce','File Access Error');
INSERT INTO end (end_code, end_name) VALUES ('accf','File Access Failure');
INSERT INTO end (end_code, end_name) VALUES ('sime','Simulation Error');
INSERT INTO end (end_code, end_name) VALUES ('simf','Simulation Failure');
INSERT INTO end (end_code, end_name) VALUES ('opte','Optimization Error');
INSERT INTO end (end_code, end_name) VALUES ('optf','Optimization Failure');
INSERT INTO end (end_code, end_name) VALUES ('stae','Opt OK, Stat Error');
INSERT INTO end (end_code, end_name) VALUES ('usre','Input Error');
INSERT INTO end (end_code, end_name) VALUES ('usrf','Input Failure');
INSERT INTO end (end_code, end_name) VALUES ('deve','Known Prog Error');
INSERT INTO end (end_code, end_name) VALUES ('devf','Known Prog Failure');
INSERT INTO end (end_code, end_name) VALUES ('pose','Post-opt Error');
INSERT INTO end (end_code, end_name) VALUES ('posf','Post-opt Failure');
INSERT INTO end (end_code, end_name) VALUES ('idee','Model Ident Error');
INSERT INTO end (end_code, end_name) VALUES ('idef','Model Ident Failure');
INSERT INTO end (end_code, end_name) VALUES ('spku','SPK Unavailable');
INSERT INTO end (end_code, end_name) VALUES ('rese','Opt OK, Resid Error');
INSERT INTO end (end_code, end_name) VALUES ('resf','Opt OK, Resid Fail');
INSERT INTO end (end_code, end_name) VALUES ('optm','Opt Max Iter Error');

INSERT INTO method (method_code, method_name, class_code, test_only) VALUES ('fo','First Order','al',0);
INSERT INTO method (method_code, method_name, class_code, test_only) VALUES ('eh','Expected Hessian','al',0);
INSERT INTO method (method_code, method_name, class_code, test_only) VALUES ('la','Laplace Approx.','al',0);
INSERT INTO method (method_code, method_name, class_code, test_only) VALUES ('ml','M.C. Likelihood','le',0);
INSERT INTO method (method_code, method_name, class_code, test_only) VALUES ('mc','Markov Chain M.C.','al',0);
INSERT INTO method (method_code, method_name, class_code, test_only) VALUES ('gr','Grid','le',1);
INSERT INTO method (method_code, method_name, class_code, test_only) VALUES ('an','Analytical','le',0);
INSERT INTO method (method_code, method_name, class_code, test_only) VALUES ('so','Simulation Only','so',0);
INSERT INTO method (method_code, method_name, class_code, test_only) VALUES ('ia','Individual Analysis','al',0);
INSERT INTO method (method_code, method_name, class_code, test_only) VALUES ('mi','Miser Likelihood','le',0);
INSERT INTO method (method_code, method_name, class_code, test_only) VALUES ('s2','Std. Two-stage','al',0);
INSERT INTO method (method_code, method_name, class_code, test_only) VALUES ('i2','Iter. Two-stage','al',0);
INSERT INTO method (method_code, method_name, class_code, test_only) VALUES ('g2','Global Two-stage','al',0);
INSERT INTO method (method_code, method_name, class_code, test_only) VALUES ('sm','MAP Std. Two-stage','al',0);
INSERT INTO method (method_code, method_name, class_code, test_only) VALUES ('im','MAP Iter. Two-stage','al',0);
INSERT INTO method (method_code, method_name, class_code, test_only) VALUES ('gm','MAP Global Two-stage','al',0);
INSERT INTO method (method_code, method_name, class_code, test_only) VALUES ('id','Identifiability','id',0);
INSERT INTO method (method_code, method_name, class_code, test_only) VALUES ('gn','Grid Nonparam.','al',0);
INSERT INTO method (method_code, method_name, class_code, test_only) VALUES ('un','Uniform Nonparam.','al',0);

INSERT INTO state (state_code, state_name) VALUES ('q2c','Queued to compile');
INSERT INTO state (state_code, state_name) VALUES ('q2ml','Queued to M.L.');
INSERT INTO state (state_code, state_name) VALUES ('cmp','Compiling');
INSERT INTO state (state_code, state_name) VALUES ('q2r','Queued to run');
INSERT INTO state (state_code, state_name) VALUES ('run','Running');
INSERT INTO state (state_code, state_name) VALUES ('end','End');
INSERT INTO state (state_code, state_name) VALUES ('q2ac','Queued to abort cmp');
INSERT INTO state (state_code, state_name) VALUES ('q2ar','Queued to abort run');
INSERT INTO state (state_code, state_name) VALUES ('acmp','Aborting compilation');
INSERT INTO state (state_code, state_name) VALUES ('arun','Aborting run');
      </screen>
    </para>
  </sect1>
  <sect1 id="tables_and_fields">
    <title>Tables and Fields</title>
    <sect2>
      <title>class</title>
      <para>
	The <emphasis>class</emphasis> table categorizes methods into
	classes.  No row is ever deleted from this table.
      </para>
      <para>
	<table frame='all'><title>class</title>
	  <tgroup cols='3' align='left' colsep='1' rowsep='1'>
	    <colspec colwidth="1*" colname='c1'/>
	    <colspec colwidth="2*" colname='c2'/>
	    <colspec colwidth="4*" colname='c3'/>
	    <thead>
	      <row>
		<entry>Field</entry>
		<entry>Type</entry>
		<entry>Description</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>class_code</entry>
		<entry>char(2)</entry>
		<entry>Primary key.</entry>
	      </row>
	      <row>
		<entry>class_name</entry>
		<entry>char(20)</entry>
		<entry>Expanded name.</entry>
	      </row>
	      <row>
		<entry>parent_required</entry>
		<entry>tinyint(1)</entry>
		<entry>
		  Whether or not methods in the class can only be used by jobs
		  which have a parent link.
		</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
      </para>
      <bridgehead renderas="sect3">Transaction Processing Considerations</bridgehead>
      <para>
	This table is not updated by applications. There are no 
	transaction processing issues.
      </para>
    </sect2>
    <sect2>
      <title>dataset</title>
      <para>
	Each row of the <emphasis>dataset</emphasis> table represents
	the source code for a scientific dataset.  A text file, 
	stored in the <emphasis>archive</emphasis> field, contains
	the current and all previous versions of the dataset, in 
	compressed RCS-compatible format.
      </para>
      <para>
	<table frame='all'><title>dataset</title>
	  <tgroup cols='3' align='left' colsep='1' rowsep='1'>
	    <colspec colwidth="1*" colname='c1'/>
	    <colspec colwidth="2*" colname='c2'/>
	    <colspec colwidth="4*" colname='c3'/>
	    <thead>
	      <row>
		<entry>Field</entry>
		<entry>Type</entry>
		<entry>Description</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>dataset_id</entry>
		<entry>int(10) unsigned</entry>
		<entry>
		  Primary key, supplied automatically when the row is created.
		</entry>
	      </row>
	      <row>
		<entry>name</entry>
		<entry>varchar(20)</entry>
		<entry>The name of the  dataset.</entry>
	      </row>
	      <row>
		<entry>abstract</entry>
		<entry>varchar(100)</entry>
		<entry>A short description of the dataset.</entry>
	      </row>
	      <row>
		<entry>archive</entry>
		<entry>longblob</entry>
		<entry>
		  A text file containing the current and all previous
		  versions, in compressed RCS-compatible format.
		</entry>
	      </row>
	      <row>
		<entry>user_id</entry>
		<entry>int(10) unsigned</entry>
		<entry>
		  The user who owns this dataset. A foreign key to the
		  user table.
		</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
      </para>
      <bridgehead renderas="sect3">Transaction Processing Considerations</bridgehead>
      <para>
	The user, with the aid of the MDA, appends rows to this
	table.  The key field, <emphasis>dataset_id</emphasis>,
	is declared with the <command>auto_increment</command>
	modifier and the table has <command>TYPE=InnoDB</command>,
	hence MySQL insures that this field is unique.
      </para>
      <para>
	The application requires each of a user's datasets to have a
	different name. In order to avoid a potential concurrency
	problem where two copies of the MDA attempt to add a 
	dataset of the same name for the same user simultaneously,
	this table must be created with a
	<command>UNIQUE KEY user_id (user_id,name)</command>
	modifier. With the
	table thus defined, the responsibility for avoiding this
	race condition is assumed by MySQL, and applications do
	not have to be concerned with it.
      </para>
    </sect2>
    <sect2>
      <title>end</title>
      <para>
	The <emphasis>end</emphasis> table provides short and long text for
	the end condition.  No row is ever deleted from this table.
      </para>
      <para>
	<table frame='all'><title>end</title>
	  <tgroup cols='3' align='left' colsep='1' rowsep='1'>
	    <colspec colwidth="1*" colname='c1'/>
	    <colspec colwidth="2*" colname='c2'/>
	    <colspec colwidth="4*" colname='c3'/>
	    <thead>
	      <row>
		<entry>Field</entry>
		<entry>Type</entry>
		<entry>Description</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>end_code</entry>
		<entry>char(4)</entry>
		<entry>Primary key.</entry>
	      </row>
	      <row>
		<entry>end_name</entry>
		<entry>char(20)</entry>
		<entry>Expanded name.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
      </para>
      <bridgehead renderas="sect3">Transaction Processing Considerations</bridgehead>
      <para>
	This table is not updated by applications. There are no 
	transaction processing issues.
      </para>
    </sect2>
    <sect2>
      <title>history</title>
      <para>
	The <emphasis>history</emphasis> table records all changes of state
	of every job.  Each time that the <emphasis>state_code</emphasis>
	field of a row in the <emphasis>job</emphasis> table is changed,
	a row must be added to <emphasis>history</emphasis>.  Rows are
	never deleted from this table.
      </para>
      <para>
	<table frame='all'><title>history</title>
	  <tgroup cols='3' align='left' colsep='1' rowsep='1'>
	    <colspec colwidth="2*" colname='c1'/>
	    <colspec colwidth="3*" colname='c2'/>
	    <colspec colwidth="8*" colname='c3'/>
	    <thead>
	      <row>
		<entry>Field</entry>
		<entry>Type</entry>
		<entry>Description</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>history_id</entry>
		<entry>int(10) unsigned</entry>
		<entry>
		  Primary key. A unique positive integer, supplied
		  automatically when a row is created.
		</entry>
	      </row>
	      <row>
		<entry>event_time</entry>
		<entry>int(10) unsigned</entry>
		<entry>
		  The time at which the row was added to the table.
		  This value is the number of seconds since the year
		  1970 began, at the  prime meridian.
		</entry>
	      </row>
	      <row>
		<entry>state_code</entry>
		<entry>varchar(4)</entry>
		<entry>
		  The state to which the given job transitioned at the
		  given time.  A foreign key to the state table.
		</entry>
	      </row>
	      <row>
		<entry>job_id</entry>
		<entry>int(10) unsigned</entry>
		<entry>
		  The job that underwent a transition at the given 
		  time. A foreign key to the job table.
		</entry>
	      </row>
	      <row>
		<entry>host</entry>
		<entry>varchar(100)</entry>
		<entry>
		  The host name of the computer on which the job was running
		  at the time the event occurred.
		</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
      </para>
      <bridgehead renderas="sect3">Transaction Processing Considerations</bridgehead>
      <para>
	Applications append rows to this table. Once in the table,
	a row is never updated. The value of the key field,
	<emphasis>history_id</emphasis>, is provided automatically
	by MySQL. There are no transaction processing considerations.
      </para>
    </sect2>
    <sect2>
      <title>job</title>
      <para>
	Each row in this table represents an Spk job. It is updated
	each time the job makes a state transition.  Rows are never
	deleted from this table.
      </para>
      <para>
	<table frame='all'><title>job</title>
	  <tgroup cols='3' align='left' colsep='1' rowsep='1'>
	    <colspec colwidth="1*" colname='c1'/>
	    <colspec colwidth="2*" colname='c2'/>
	    <colspec colwidth="4*" colname='c3'/>
	    <thead>
	      <row>
		<entry>Field</entry>
		<entry>Type</entry>
		<entry>Description</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>job_id</entry>
		<entry>int(10) unsigned</entry>
		<entry>
		  Primary key. A unique positive number, supplied
		  automatically when the row is created.
		</entry>
	      </row>
	      <row>
		<entry>user_id</entry>
		<entry>int (10)</entry>
		<entry>
		  The user to whom the job belongs.  A foreign key
		  to the user table.
		</entry>
	      </row>
	      <row>
		<entry>abstract</entry>
		<entry>varchar(100)</entry>
		<entry>Short description of the job.</entry>
	      </row>
	      <row>
		<entry>dataset_id</entry>
		<entry>int(10)</entry>
		<entry>
		  The dataset, a version of which this job runs.
		  A foreign key to the dataset table.
		</entry>
	      </row>
	      <row>
		<entry>dataset_version</entry>
		<entry>varchar(10)</entry>
		<entry>
		  The rcs version code of the dataset being run.
		</entry>
	      </row>
	      <row>
		<entry>model_id</entry>
		<entry>int(10)</entry>
		<entry>
		  The model, a version of which this job runs.
		  A foreign key to the model table.
		</entry>
	      </row>
	      <row>
		<entry>model_version</entry>
		<entry>varchar(10)</entry>
		<entry>
		  The rcs version code of the model being run.
		</entry>
	      </row>
	      <row>
		<entry>xml_source</entry>
		<entry>longblob</entry>
		<entry>
		  An XML file containing source code for the model,
		  constraints, parameters and presentation directives
		  that is provided by the MDA when the row is
		  created. This file is input to the Aspk Compiler,
		  which translates it into the cpp_source field,
		  for use by the Cspk.
		</entry>
	      </row>
	      <row>
		<entry>checkpoint</entry>
		<entry>longblob</entry>
		<entry>
		  An XML file containing checkpoint information 
		  that was written to a file by the job after its
		  last iteration.  The runtime daemon copies the
		  file to the database.
		</entry>
	      </row>
	      <row>
		<entry>state_code</entry>
		<entry>varchar(4)</entry>
		<entry>
		  The current state of the job.  A foreign key 
		  to the state table.
		</entry>
	      </row>
	      <row>
		<entry>report</entry>
		<entry>longblob</entry>
		<entry>
		  The final report, expressed as XML, added to the row
		  at the time the job makes the transition to the
		  "End" state.  
		</entry>
	      </row>
	      <row>
		<entry>start_time</entry>
		<entry>int(10) unsigned</entry>
		<entry>
		  The time, to a resolution of one second, at which the 
		  job was first submitted to Spk.  The value stored is 
		  the number of seconds since the year 1970 began,
		  at the prime meridian.
		</entry>
	      </row>
	      <row>
		<entry>event_time</entry>
		<entry>int(10) unsigned</entry>
		<entry>
		  The time, to a resolution of one second, at which the 
		  job entered its current state.  The value stored is 
		  the number of seconds since the year 1970 began,
		  at the prime meridian.
		</entry>
	      </row>
	      <row>
		<entry>cpp_source</entry>
		<entry>longblob</entry>
		<entry>
		  An archive of files, containing c++ source code
		  and scientific data, 
		  which is output by the Aspk Compiler for the
		  use of the Cspk when the job enters the 
		  "Queued to Run" state.
		</entry>
	      </row>
	      <row>
		<entry>end_code</entry>
		<entry>varchar(4)</entry>
		<entry>
		  When the job reaches the 'end' state, the end_code is set
		  to indicate the type of completion that occurred.  A foreign
		  key to the end table.
		</entry>
	      </row>
	      <row>
		<entry>method_code</entry>
		<entry>char(2)</entry>
		<entry>
		  The method to be used for the calculation. A foreign key
		  to the method table.
		</entry>
	      </row>
	      <row>
		<entry>parent</entry>
		<entry>int(10)</entry>
		<entry>
		  The job_id of the parent job, if this job depends on
		  a previous one. A foreign key to the job table.
		</entry>
	      </row>
	      <row>
		<entry>mail</entry>
		<entry>tinyInt(1)</entry>
		<entry>
		  Whether or not the user wants an end-job email notice.
		</entry>
	      </row>
              <row>
		<entry>share_with</entry>
		<entry>int(10)</entry>
		<entry>
		  The user_id of the user whom the job is shared with.
		</entry>
	      </row>
              <row>
		<entry>parallel</entry>
		<entry>int(10)</entry>
		<entry>
		  The number of sub-tasks if the job runs in parallel processing mode.  
                  Being zero if the job runs in single process mode.
		</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
      </para>
      <bridgehead renderas="sect3">Transaction Processing Considerations</bridgehead>
      <para>
	Applications append rows to this table. This action does not
	have any transaction processing implications, because the 
	key field, <emphasis>job_id</emphasis>, is provided 
	automatically by MySQL, as long as <emphasis>job_id</emphasis>
	is declared with the <command>auto_increment</command>
	modifier and the table has
	<command>TYPE=InnoDB</command>.
      </para>
      <para>
	On the other hand,
	several Aspk Compilers may attempt to update the same row
	of the table simultaneously, in the act of selecting a 
	job to be compiled.  In order to maintain the integrity
	of the table, the code that performs queue selection and
	the associated update of the <emphasis>state_code</emphasis>
	field must executed in transaction state.  In other words,
	a SQL <command>begin</command> statement or its programming
	language equivalent, must be executed before the queue selection
	code starts, and a <command>commit</command> command must
	be executed afterward.
      </para>
      <para>
	Similarly, several Cspk process may attempt simultaneously
	to select the highest priority job that is ready to run.
	The situation is fully equivalent to that of selecting
	a job to compile, as described above, and the remedy is
	the same, as well.
      </para>
    </sect2>
    <sect2>
      <title>method</title>
      <para>
	The <emphasis>method</emphasis> table provides short and long text for
	the method of calculation.  No row is ever deleted from this table.
      </para>
      <para>
	<table frame='all'><title>method</title>
	  <tgroup cols='3' align='left' colsep='1' rowsep='1'>
	    <colspec colwidth="1*" colname='c1'/>
	    <colspec colwidth="2*" colname='c2'/>
	    <colspec colwidth="4*" colname='c3'/>
	    <thead>
	      <row>
		<entry>Field</entry>
		<entry>Type</entry>
		<entry>Description</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>method_code</entry>
		<entry>char(2)</entry>
		<entry>Primary key.</entry>
	      </row>
	      <row>
		<entry>method_name</entry>
		<entry>char(20)</entry>
		<entry>Expanded name.</entry>
	      </row>
	      <row>
		<entry>test_only</entry>
		<entry>tiny_int(1)</entry>
		<entry>
		  Whether or not this method can only be employed by a user
		  qualified by a true value in the test column of
		  his or her row in the user table.
		</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
      </para>
      <bridgehead renderas="sect3">Transaction Processing Considerations</bridgehead>
      <para>
	This table is not updated by applications. There are no 
	transaction processing issues.
      </para>
    </sect2>
    <sect2>
      <title>model</title>
      <para>
	Each row of the <emphasis>model</emphasis> table represents
	the source code for a scientific model.  A text file, 
	stored in the <emphasis>archive</emphasis> field, contains
	the current and all previous versions of the model, in 
	compressed RCS-compatible format.
      </para>
      <para>
	<table frame='all'><title>model</title>
	  <tgroup cols='3' align='left' colsep='1' rowsep='1'>
	    <colspec colwidth="1*" colname='c1'/>
	    <colspec colwidth="2*" colname='c2'/>
	    <colspec colwidth="4*" colname='c3'/>
	    <thead>
	      <row>
		<entry>Field</entry>
		<entry>Type</entry>
		<entry>Description</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>model_id</entry>
		<entry>int(10) unsigned</entry>
		<entry>
		  Primary key, supplied automatically when the row is created.
		</entry>
	      </row>
	      <row>
		<entry>name</entry>
		<entry>varchar(20)</entry>
		<entry>The name of the  model.</entry>
	      </row>
	      <row>
		<entry>abstract</entry>
		<entry>varchar(100)</entry>
		<entry>A short description of the model.</entry>
	      </row>
	      <row>
		<entry>archive</entry>
		<entry>longblob</entry>
		<entry>
		  A text file containing the current and all previous
		  versions, in compressed RCS-compatible format.
		</entry>
	      </row>
	      <row>
		<entry>user_id</entry>
		<entry>int(10) unsigned</entry>
		<entry>
		  The user who owns this model. A foreign key to the
		  user table.
		</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
      </para>
      <bridgehead renderas="sect3">Transaction Processing Considerations</bridgehead>
      <para>
	The user, with the aid of the MDA, appends rows to this
	table.  The key field, <emphasis>model_id</emphasis>,
	is declared with the <command>auto_increment</command>
	modifier and the table has <command>TYPE=InnoDB</command>,
	hence MySQL insures that this field is unique.
      </para>
      <para>
	The application requires each of a user's models to have a
	different name. In order to avoid a potential concurrency
	problem where two copies of the MDA attempt to add a 
	model of the same name for the same user simultaneously,
	this table must be created with a
	<command>UNIQUE KEY user_id (user_id,name)</command>
	modifier. With the
	table thus defined, the responsibility for avoiding this
	race condition is assumed by MySQL, and applications do
	not have to be concerned with it.
      </para>
    </sect2>
    <sect2>
      <title>state</title>
      <para>
	The <emphasis>state</emphasis> table provides short and
	long names for the states that a job can be in.  Rows
	must never be deleted from this table.
      </para>
      <para>
	<table frame='all'><title>state</title>
	  <tgroup cols='3' align='left' colsep='1' rowsep='1'>
	    <colspec colwidth="1*" colname='c1'/>
	    <colspec colwidth="2*" colname='c2'/>
	    <colspec colwidth="4*" colname='c3'/>
	    <thead>
	      <row>
		<entry>Field</entry>
		<entry>Type</entry>
		<entry>Description</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>state_code</entry>
		<entry>char(3)</entry>
		<entry>
		  Primary key.  The short name of a job state.
		</entry>
	      </row>
	      <row>
		<entry>state_name</entry>
		<entry>char(20)</entry>
		<entry>Long name for a state.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
      </para>
      <bridgehead renderas="sect3">Transaction Processing Considerations</bridgehead>
      <para>
	This table is not updated by applications. There are no 
	transaction processing issues.
      </para>
    </sect2>
    <sect2>
      <title>user</title>
      <para>
	The <emphasis>user</emphasis> table contains information about
	the user.  The MDA consults this table when a user logs in.
	This table identifies jobs and models.  Rows must never be
	deleted from this table.
      </para>
      <para>
	<table frame='all'><title>user</title>
	  <tgroup cols='3' align='left' colsep='1' rowsep='1'>
	    <colspec colwidth="1*" colname='c1'/>
	    <colspec colwidth="2*" colname='c2'/>
	    <colspec colwidth="4*" colname='c3'/>
	    <thead>
	      <row>
		<entry>Field</entry>
		<entry>Type</entry>
		<entry>Description</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>user_id</entry>
		<entry>int(10) unsigned</entry>
		<entry>
		  Primary key.  Provided automatically when the row is created.
		</entry>
	      </row>
	      <row>
		<entry>first_name</entry>
		<entry>varchar(30)</entry>
		<entry>The given name of this user.</entry>
	      </row>
	      <row>
		<entry>surname</entry>
		<entry>varchar(40)</entry>
		<entry>The family name of this user.</entry>
	      </row>
	      <row>
		<entry>password</entry>
		<entry>varchar(32)</entry>
		<entry>An encrypted password, used when logging in.</entry>
	      </row>
	      <row>
		<entry>username</entry>
		<entry>varchar(20)</entry>
		<entry>
		  A user name used for logging in.  Must be unique.
		</entry>
	      </row>
	      <row>
		<entry>company</entry>
		<entry>varchar(30)</entry>
		<entry>
		  The name of the company the user works for.
		</entry>
	      </row>
	      <row>
		<entry>country</entry>
		<entry>varchar(20)</entry>
		<entry>
		  The user's country.
		</entry>
	      </row>
	      <row>
		<entry>state</entry>
		<entry>varchar(20)</entry>
		<entry>
		  The user's country or province.
		</entry>
	      </row>
	      <row>
		<entry>email</entry>
		<entry>varchar(40)</entry>
		<entry>
		  The user's electronic mail address.
		</entry>
	      </row>
	      <row>
		<entry>test</entry>
		<entry>tinyint(1)</entry>
		<entry>
		  Whether or not the user is authorized to access features
		  that are still under test.
		</entry>
	      </row>
	      <row>
		<entry>dev</entry>
		<entry>tinyint(1)</entry>
		<entry>
		  Whether the user is one of the developers of this software.
		</entry>
	      </row>
	      <row>
		<entry>team_id</entry>
		<entry>int(10) unsigned</entry>
		<entry>
                  The team_id of the user, 0 if the user is not in a team.
                </entry>
	      </row>
	      <row>
		<entry>register_time</entry>
		<entry>timestamp</entry>
		<entry>
		  The time when the user is registered.
		</entry>
	      </row>
	      <row>
		<entry>contact</entry>
		<entry>tinyint(1)</entry>
		<entry>
		  Whether the user is in the contact list.
		</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
      </para>
      <bridgehead renderas="sect3">Transaction Processing Considerations</bridgehead>
      <para>
	Users are added by an administrative application.  The
	key field, <emphasis>user_id</emphasis>, is automatically
	assigned to be unique by MySQL, as long as the 
	<command>auto_increment</command> modifier is used
	and the table has <command>TYPE=InnoDB</command> when
	the table is created.  This insures that there are no
	concurrency issues when adding a user.
      </para>
      <para>
	Once a user is in the database, she can use an MDA to
	modify her record.  Because the <emphasis>username</emphasis>
	field must be unique within the table, there could be
	a race condition with two users trying to change to the
	same username. Problems are avoided by specifying
	<command>UNIQUE KEY (username)</command> and 
	<command>TYPE=InnoDB</command>.
      </para>
    </sect2>
    <sect2>
      <title>team</title>
      <para>
	The <emphasis>team</emphasis> table contains information about
	the team.  The MDA consults this table when a user logs in.
	This table identifies users of the team.  Rows must never be
	deleted from this table.
      </para>
      <para>
	<table frame='all'><title>team</title>
	  <tgroup cols='3' align='left' colsep='1' rowsep='1'>
	    <colspec colwidth="1*" colname='c1'/>
	    <colspec colwidth="2*" colname='c2'/>
	    <colspec colwidth="4*" colname='c3'/>
	    <thead>
	      <row>
		<entry>Field</entry>
		<entry>Type</entry>
		<entry>Description</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>team_id</entry>
		<entry>int(10) unsigned</entry>
		<entry>
		  Primary key.  Provided automatically when the row is created.
		</entry>
	      </row>
	      <row>
		<entry>team_name</entry>
		<entry>int(10) unsigned</entry>
		<entry>The given name of this team.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
      </para>
      <bridgehead renderas="sect3">Transaction Processing Considerations</bridgehead>
      <para>
	Teams are added by an administrative application.  The
	key field, <emphasis>team_id</emphasis>, is automatically
	assigned to be unique by MySQL, as long as the 
	<command>auto_increment</command> modifier is used
	and the table has <command>TYPE=InnoDB</command> when
	the table is created.  This insures that there are no
	concurrency issues when adding a team.
      </para>
      <para>
	Once a team is in the database, users can join the team. A team
        can have many users, but a user can join only one team. 
      </para>
    </sect2>
  </sect1>
</article>

<!--  LocalWords:  xml DOCTYPE DocBook uw articleinfo revhistory revnumber Spk
 -->
<!--  LocalWords:  authorinitials revremark spkdb SQL itemizedlist listitem url
 -->
<!--  LocalWords:  ulink orderedlist MDA MDAs Aspk Cspk cpp MyISAM cerr srun al
 -->
<!--  LocalWords:  timestamp varchar longblob InnoDB cmp username tgroup colsep
 -->
<!--  LocalWords:  rowsep colspec colwidth colname thead tbody MySQL linkend le
 -->
<!--  LocalWords:  tinyint dev Eval herr serr fo mc renderas rcs
 -->
